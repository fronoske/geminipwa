
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeminiPWA</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" id="theme-color-meta" content="#4a90e2">
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f0f2f5;
            --bg-tertiary: #fdfdfd;
            --bg-input: #ffffff;
            --bg-user-message: #dcf8c6;
            --bg-model-message: #e5e5ea;
            --bg-system-message: #f0f8ff;
            --bg-error-message: #ffebee;
            --bg-button: #4a90e2;
            --bg-button-hover: #357abd;
            --bg-button-disabled: #a0c3e8;
            --bg-button-action: #777777;
            --bg-button-action-hover: #555555;
            --bg-button-delete: #e53935;
            --bg-button-delete-hover: #c62828;
            --bg-button-retry: #43a047;
            --bg-button-retry-hover: #2e7d32;
            --bg-button-edit: #ff9800;
            --bg-button-edit-hover: #f57c00;
            --bg-button-copy: #e91e63;
            --bg-button-copy-hover: #c2185b;
            --bg-button-paste: #00bcd4;
            --bg-button-paste-hover: #0097a7;
            --bg-button-duplicate: #546e7a;
            --bg-button-duplicate-hover: #37474f;
            --bg-button-export: #1e88e5;
            --bg-button-export-hover: #1565c0;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #f44336;
            --bg-button-cancel-hover: #d32f2f;
            --bg-button-update: #1976d2;
            --bg-button-update-hover: #115293;
            --bg-header: #4a90e2;
            --overlay-base-rgb: 255, 255, 255;
            --chat-overlay-alpha: 0.65;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: #e53935;
            --bg-button-header-delete-hover: #c62828;
            --bg-button-header-copy: #e91e63;
            --bg-button-header-copy-hover: #c2185b;
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);


            --text-primary: #333333;
            --text-secondary: #777777;
            --text-light: #ffffff;
            --text-disabled: #e0e0e0;
            --text-error: #c62828;
            --text-link: #4a90e2;
            --text-placeholder: #999999;
            --text-system: #555;
            --text-memo: #000000;
            --bg-memo: #ffffff;


            --border-primary: #cccccc;
            --border-secondary: #dddddd;
            --border-tertiary: #eeeeee;
            --border-danger: #ffcdd2;
            --border-system: #add8e6;

            --shadow-primary: rgba(0, 0, 0, 0.1);
            --shadow-secondary: rgba(0,0,0,0.1);

            --message-max-width: 85%;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --message-body-font-size: 14px;
            --code-block-font-size: 13px;
            --chat-background-image: none;

            --bg-dialog-file-item: var(--bg-tertiary);
            --border-dialog-file-item: var(--border-secondary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(0, 0, 0, 0.03);
            --border-attachment-details: var(--border-tertiary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);

            --badge-color: #ffcc00;
            --badge-size: 12px;

            --memo-height: 300px;
            --clipboard-stack-height: 300px;
            --message-icon-size: 28px;
            --message-icon-offset-y: -10px;
            --icon-name-font-size: 10px;
            --icon-name-offset-y: -10px;

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --message-bubble-opacity: 1;
            --header-footer-opacity: 1;

            --bg-button-gold: #FFD700;
            --bg-button-gold-hover: #FFC700;
            --text-button-gold: #ffffff;
            --bg-button-purple: #800080;
            --bg-button-purple-hover: #6A006A;
            --text-button-purple: #ffffff;

            --message-toggle-button-top-width: 6px;
            --message-toggle-button-top-height: 40px;
            --message-toggle-button-top-font-size: 12px;
            --message-toggle-button-top-opacity: 0.6;
            --message-toggle-button-top-text-collapse: "-";
            --message-toggle-button-top-text-expand: "□";

            --message-toggle-button-bottom-font-size: 14px;
            --message-toggle-button-bottom-text-collapse: "非表示";
            --message-toggle-button-bottom-text-expand: "表示";

            --message-actions-base-rgb: 255, 255, 255;
            --message-actions-bg-opacity: 0.8;

            --user-name-bubble-bg: transparent;
            --ai-name-bubble-bg: transparent;
            --user-name-bubble-padding-y: 2px;
            --user-name-bubble-padding-x-ratio: 0.5;
            --user-name-bubble-border-radius: 5px;
            --ai-name-bubble-padding-y: 2px;
            --ai-name-bubble-padding-x-ratio: 0.5;
            --ai-name-bubble-border-radius: 5px;
            --default-user-name-bubble-custom-rgb: 255, 255, 255;
            --default-ai-name-bubble-custom-rgb: 255, 255, 255;
        }

        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #101010;
            --bg-tertiary: #252525;
            --bg-input: #303030;
            --bg-user-message: #056162;
            --bg-model-message: #3a3a3c;
            --bg-system-message: #2a3a4a;
            --bg-error-message: #5c1c1c;
            --bg-button: #007aff;
            --bg-button-hover: #005ecb;
            --bg-button-disabled: #4a5a70;
            --bg-button-action: #666666;
            --bg-button-action-hover: #888888;
            --bg-button-delete: #ff3b30;
            --bg-button-delete-hover: #d12c23;
            --bg-button-retry: #34c759;
            --bg-button-retry-hover: #249a41;
            --bg-button-edit: #ff9500;
            --bg-button-edit-hover: #d17d00;
            --bg-button-copy: #f06292;
            --bg-button-copy-hover: #ec407a;
            --bg-button-paste: #4dd0e1;
            --bg-button-paste-hover: #26c6da;
            --bg-button-duplicate: #8e8e93;
            --bg-button-duplicate-hover: #6b6b70;
            --bg-button-export: #0a84ff;
            --bg-button-export-hover: #0069d1;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #ff453a;
            --bg-button-cancel-hover: #d1332b;
            --bg-button-update: #0a84ff;
            --bg-button-update-hover: #0069d1;
            --bg-header: #007aff;
            --overlay-base-rgb: 30, 30, 30;
            --bg-memo: #2c2c2e;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --text-light: #ffffff;
            --text-disabled: #666666;
            --text-error: #ff8a80;
            --text-link: #00aaff;
            --text-placeholder: #777777;
            --text-system: #ccc;
            --text-memo: #e0e0e0;

            --border-primary: #444444;
            --border-secondary: #555555;
            --border-tertiary: #333333;
            --border-danger: #7a2e35;
            --border-system: #4682b4;

            --shadow-primary: rgba(255, 255, 255, 0.1);
            --shadow-secondary: rgba(0, 0, 0, 0.5);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: #b8860b;
            --bg-button-gold-hover: #daa520;
            --text-button-gold: #ffffff;
            --bg-button-purple: #6a0dad;
            --bg-button-purple-hover: #8a2be2;
            --text-button-purple: #ffffff;

            --message-actions-base-rgb: 50, 50, 50;
            --default-user-name-bubble-custom-rgb: 50, 50, 50;
            --default-ai-name-bubble-custom-rgb: 50, 50, 50;
        }


        body.pastel-pink-mode {
            --bg-primary: #fff5f8;
            --bg-secondary: #ffe6ea;
            --bg-tertiary: #fff0f3;
            --bg-input: #ffffff;
            --bg-user-message: #ffddee;
            --bg-model-message: #f3e8ff;
            --bg-system-message: #ffeef2;
            --bg-error-message: #ffccd5;
            --bg-button: #ff8fab;
            --bg-button-hover: #ff7096;
            --bg-button-disabled: #fcc2d7;
            --bg-button-action: #ffb3c1;
            --bg-button-action-hover: #ffa8b9;
            --bg-button-delete: #ff6b6b;
            --bg-button-delete-hover: #f06060;
            --bg-button-retry: #a0eade;
            --bg-button-retry-hover: #88d8c0;
            --bg-button-edit: #ffc974;
            --bg-button-edit-hover: #ffbd59;
            --bg-button-copy: #e5a9f0;
            --bg-button-copy-hover: #d998e3;
            --bg-button-paste: #b2e0ff;
            --bg-button-paste-hover: #a1d5f7;
            --bg-button-duplicate: #ffdaab;
            --bg-button-duplicate-hover: #ffce96;
            --bg-button-export: #c8a2c8;
            --bg-button-export-hover: #b991b9;
            --bg-button-save: #90ee90;
            --bg-button-save-hover: #78dd78;
            --bg-button-cancel: #ff9aa2;
            --bg-button-cancel-hover: #ff868e;
            --bg-button-update: #ff9a8b;
            --bg-button-update-hover: #ff8773;
            --bg-header: #ff8fab;
            --overlay-base-rgb: 255, 245, 248;
            --bg-memo: #fffafb;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #5c3c45;
            --text-secondary: #8c6b74;
            --text-light: #ffffff;
            --text-disabled: #d8b8c0;
            --text-error: #c5002f;
            --text-link: #ff69b4;
            --text-placeholder: #b28a94;
            --text-system: #7d5a65;
            --text-memo: #5c3c45;

            --border-primary: #ffc2d7;
            --border-secondary: #ffe0e7;
            --border-tertiary: #fff0f3;
            --border-danger: #ffb3c1;
            --border-system: #ffd1dc;

            --shadow-primary: rgba(200, 150, 160, 0.1);
            --shadow-secondary: rgba(200, 150, 160, 0.1);

            --bg-dialog-file-item: var(--bg-tertiary);
            --border-dialog-file-item: var(--border-secondary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(255, 230, 234, 0.5);
            --border-attachment-details: var(--border-tertiary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: #ffdd77;
            --bg-button-gold-hover: #ffcc55;
            --text-button-gold: #816200;
            --bg-button-purple: #d9a7e0;
            --bg-button-purple-hover: #c790d0;
            --text-button-purple: #ffffff;

            --message-actions-base-rgb: 255, 230, 234;

            --default-user-name-bubble-custom-rgb: 255, 230, 234;
            --default-ai-name-bubble-custom-rgb: 255, 230, 234;
        }


        body.pastel-blue-mode {
            --bg-primary: #f0f8ff;
            --bg-secondary: #e0f0ff;
            --bg-tertiary: #eaf5ff;
            --bg-input: #ffffff;
            --bg-user-message: #cff1ef;
            --bg-model-message: #e0e8ff;
            --bg-system-message: #e6f2ff;
            --bg-error-message: #d1e9ff;
            --bg-button: #87cefa;
            --bg-button-hover: #70b8e8;
            --bg-button-disabled: #b0dfff;
            --bg-button-action: #add8e6;
            --bg-button-action-hover: #9ccce0;
            --bg-button-delete: #ff7f7f;
            --bg-button-delete-hover: #ff6a6a;
            --bg-button-retry: #98fb98;
            --bg-button-retry-hover: #82f082;
            --bg-button-edit: #ffe082;
            --bg-button-edit-hover: #ffda6b;
            --bg-button-copy: #bca0dc;
            --bg-button-copy-hover: #ae8fcf;
            --bg-button-paste: #a0cfd8;
            --bg-button-paste-hover: #8ebfc9;
            --bg-button-duplicate: #c1e1c1;
            --bg-button-duplicate-hover: #add6ad;
            --bg-button-export: #b0c4de;
            --bg-button-export-hover: #a0b7d3;
            --bg-button-save: #90ee90;
            --bg-button-save-hover: #78dd78;
            --bg-button-cancel: #ff94a0;
            --bg-button-cancel-hover: #ff808c;
            --bg-button-update: #89cff0;
            --bg-button-update-hover: #70c0e0;
            --bg-header: #87cefa;
            --overlay-base-rgb: 240, 248, 255;
            --bg-memo: #f5faff;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #3a5679;
            --text-secondary: #6b87a9;
            --text-light: #ffffff;
            --text-disabled: #aec8e1;
            --text-error: #a52a2a;
            --text-link: #5f9ea0;
            --text-placeholder: #9ab0c9;
            --text-system: #5a7698;
            --text-memo: #3a5679;


            --border-primary: #b0dfff;
            --border-secondary: #d5eaff;
            --border-tertiary: #eaf5ff;
            --border-danger: #add8e6;
            --border-system: #c1d8e8;

            --shadow-primary: rgba(150, 180, 200, 0.1);
            --shadow-secondary: rgba(150, 180, 200, 0.1);

            --bg-dialog-file-item: var(--bg-tertiary);
            --border-dialog-file-item: var(--border-secondary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(224, 240, 255, 0.5);
            --border-attachment-details: var(--border-tertiary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: #ffe48c;
            --bg-button-gold-hover: #ffda70;
            --text-button-gold: #7a6200;
            --bg-button-purple: #c1b2d7;
            --bg-button-purple-hover: #b0a0cb;
            --text-button-purple: #ffffff;

            --message-actions-base-rgb: 224, 240, 255;

            --default-user-name-bubble-custom-rgb: 224, 240, 255;
            --default-ai-name-bubble-custom-rgb: 224, 240, 255;
        }


        body.pastel-yellow-mode {
            --bg-primary: #fffefa;
            --bg-secondary: #fffacd;
            --bg-tertiary: #fff8dc;
            --bg-input: #ffffff;
            --bg-user-message: #fff5ba;
            --bg-model-message: #ffe4b5;
            --bg-system-message: #fffbea;
            --bg-error-message: #ffebcd;
            --bg-button: #ffd700;
            --bg-button-hover: #ffc700;
            --bg-button-disabled: #fff0b3;
            --bg-button-action: #ffec8b;
            --bg-button-action-hover: #ffdf60;
            --bg-button-delete: #ffa07a;
            --bg-button-delete-hover: #ff8c69;
            --bg-button-retry: #b0e57c;
            --bg-button-retry-hover: #9acd32;
            --bg-button-edit: #ffa500;
            --bg-button-edit-hover: #ff8c00;
            --bg-button-copy: #ffb6c1;
            --bg-button-copy-hover: #ffaab5;
            --bg-button-paste: #add8e6;
            --bg-button-paste-hover: #9ccce0;
            --bg-button-duplicate: #f0e68c;
            --bg-button-duplicate-hover: #eadc67;
            --bg-button-export: #fff0b3;
            --bg-button-export-hover: #ffe78a;
            --bg-button-save: #98fb98;
            --bg-button-save-hover: #82f082;
            --bg-button-cancel: #ffdab9;
            --bg-button-cancel-hover: #ffceaa;
            --bg-button-update: #ffcc5c;
            --bg-button-update-hover: #ffbf40;
            --bg-header: #ffd700;
            --overlay-base-rgb: 255, 254, 250;
            --bg-memo: #fffef0;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);


            --text-primary: #5d4037;
            --text-secondary: #8d6e63;
            --text-light: #424242;
            --text-disabled: #bcaaa4;
            --text-error: #b71c1c;
            --text-link: #ff8f00;
            --text-placeholder: #a1887f;
            --text-system: #795548;
            --text-memo: #5d4037;

            --border-primary: #fff0b3;
            --border-secondary: #fff5ba;
            --border-tertiary: #fffacd;
            --border-danger: #ffcc80;
            --border-system: #fff9c4;

            --shadow-primary: rgba(200, 180, 130, 0.1);
            --shadow-secondary: rgba(200, 180, 130, 0.1);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: var(--bg-button);
            --bg-button-gold-hover: var(--bg-button-hover);
            --text-button-gold: var(--text-light);
            --bg-button-purple: #e6e6fa;
            --bg-button-purple-hover: #d8bfd8;
            --text-button-purple: #4b0082;

            --message-actions-base-rgb: 255, 250, 205;

            --default-user-name-bubble-custom-rgb: 255, 250, 205;
            --default-ai-name-bubble-custom-rgb: 255, 250, 205;
        }


        body.pastel-purple-mode {
            --bg-primary: #f3e5f5;
            --bg-secondary: #e1bee7;
            --bg-tertiary: #ede7f6;
            --bg-input: #ffffff;
            --bg-user-message: #d1c4e9;
            --bg-model-message: #c5cae9;
            --bg-system-message: #f3e8fd;
            --bg-error-message: #f8bbd0;
            --bg-button: #ab47bc;
            --bg-button-hover: #9c27b0;
            --bg-button-disabled: #ce93d8;
            --bg-button-action: #ba68c8;
            --bg-button-action-hover: #a54eb4;
            --bg-button-delete: #ec407a;
            --bg-button-delete-hover: #d81b60;
            --bg-button-retry: #81c784;
            --bg-button-retry-hover: #66bb6a;
            --bg-button-edit: #ffb74d;
            --bg-button-edit-hover: #ffa726;
            --bg-button-copy: #7e57c2;
            --bg-button-copy-hover: #673ab7;
            --bg-button-paste: #64b5f6;
            --bg-button-paste-hover: #42a5f5;
            --bg-button-duplicate: #9575cd;
            --bg-button-duplicate-hover: #7e57c2;
            --bg-button-export: #b39ddb;
            --bg-button-export-hover: #9d80cf;
            --bg-button-save: #a5d6a7;
            --bg-button-save-hover: #81c784;
            --bg-button-cancel: #ef9a9a;
            --bg-button-cancel-hover: #e57373;
            --bg-button-update: #7986cb;
            --bg-button-update-hover: #5c6bc0;
            --bg-header: #ab47bc;
            --overlay-base-rgb: 243, 229, 245;
            --bg-memo: #fbfaff;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #4a148c;
            --text-secondary: #6a1b9a;
            --text-light: #ffffff;
            --text-disabled: #b39ddb;
            --text-error: #c2185b;
            --text-link: #7b1fa2;
            --text-placeholder: #9078a0;
            --text-system: #6a1b9a;
            --text-memo: #4a148c;

            --border-primary: #ce93d8;
            --border-secondary: #e1bee7;
            --border-tertiary: #f3e5f5;
            --border-danger: #f48fb1;
            --border-system: #d1c4e9;

            --shadow-primary: rgba(170, 150, 200, 0.1);
            --shadow-secondary: rgba(170, 150, 200, 0.1);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: #ffee58;
            --bg-button-gold-hover: #fdd835;
            --text-button-gold: #424242;
            --bg-button-purple: var(--bg-button);
            --bg-button-purple-hover: var(--bg-button-hover);
            --text-button-purple: var(--text-light);

            --message-actions-base-rgb: 225, 190, 231;

            --default-user-name-bubble-custom-rgb: 225, 190, 231;
            --default-ai-name-bubble-custom-rgb: 225, 190, 231;
        }


        body.pastel-rainbow-mode {
            --bg-primary: #fdfdfd;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #fafafa;
            --bg-input: #ffffff;
            --bg-user-message: #e0fff0;
            --bg-model-message: #e0f0ff;
            --bg-system-message: #fff0f8;
            --bg-error-message: #fff8e0;
            --bg-button: #ff80c0;
            --bg-button-hover: #ff60a0;
            --bg-button-disabled: #ffc0e0;
            --bg-button-action: #80d0ff;
            --bg-button-action-hover: #60b0e0;
            --bg-button-delete: #ff8080;
            --bg-button-delete-hover: #ff6060;
            --bg-button-retry: #80ff80;
            --bg-button-retry-hover: #60e060;
            --bg-button-edit: #ffc080;
            --bg-button-edit-hover: #ffa060;
            --bg-button-copy: #c080ff;
            --bg-button-copy-hover: #a060e0;
            --bg-button-paste: #ffff80;
            --bg-button-paste-hover: #e0e060;
            --bg-button-duplicate: #80ffff;
            --bg-button-duplicate-hover: #60e0e0;
            --bg-button-export: #ff80ff;
            --bg-button-export-hover: #e060e0;
            --bg-button-save: #c0ff80;
            --bg-button-save-hover: #a0e060;
            --bg-button-cancel: #ffc0c0;
            --bg-button-cancel-hover: #ffa0a0;
            --bg-button-update: #80c0ff;
            --bg-button-update-hover: #60a0e0;
            --bg-header: linear-gradient(to right, #ffadad, #ffd6a5, #fdffb6, #caffbf, #9bf6ff, #a0c4ff, #bdb2ff, #ffc6ff, #ffadad);
            --overlay-base-rgb: 253, 253, 253;
            --bg-memo: #f0fff0;
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #333;
            --text-secondary: #555;
            --text-light: #fff;
            --text-disabled: #aaa;
            --text-error: #c00;
            --text-link: #007bff;
            --text-placeholder: #888;
            --text-system: #444;
            --text-memo: #333;

            --border-primary: #e0e0e0;
            --border-secondary: #f0f0f0;
            --border-tertiary: #fafafa;
            --border-danger: #ffdddd;
            --border-system: #e0e8f0;

            --bg-button-gold: #ffcc00;
            --text-button-gold: #333;
            --bg-button-purple: #cc99ff;
            --text-button-purple: #fff;

            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);

            --bg-dialog-file-item: var(--bg-tertiary);
            --border-dialog-file-item: var(--border-secondary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(240, 240, 240, 0.5);
            --border-attachment-details: var(--border-tertiary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --message-actions-base-rgb: 245, 245, 245;

            --default-user-name-bubble-custom-rgb: 245, 245, 245;
            --default-ai-name-bubble-custom-rgb: 245, 245, 245;
        }



        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            font-family: var(--font-family);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            overscroll-behavior-y: contain;
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden;
        }
        button {
            cursor: pointer;
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            font-size: 14px;
            background-color: var(--bg-button);
            color: var(--text-light);
            transition: background-color 0.2s ease, color 0.2s ease;
            line-height: 1.4;
        }
        button:hover:not(:disabled) {
            background-color: var(--bg-button-hover);
        }
        button:disabled {
            background-color: var(--bg-button-disabled);
            cursor: not-allowed;
            color: var(--text-disabled);
        }
        input[type="text"],
        input[type="password"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-primary);
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            background-color: var(--bg-input);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        textarea {
            min-height: 80px;
            resize: vertical;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
            color: var(--text-primary);
        }
        ::placeholder { color: var(--text-placeholder); opacity: 1; }
        :-ms-input-placeholder { color: var(--text-placeholder); }
        ::-ms-input-placeholder { color: var(--text-placeholder); }
        .hidden { display: none !important; }

        .app-container {
            display: flex;
            position: relative;
            height: 100%;
            max-width: 800px;
            margin: 0 auto;
            background-color: var(--bg-primary);
            box-shadow: 0 0 10px var(--shadow-secondary);
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .app-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: rgba(var(--bg-header-rgb, 74, 144, 226), var(--header-footer-opacity, 1));
            color: var(--text-light);
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 10;
            transition: background-color 0.3s ease;
            gap: 8px;
        }
        body.pastel-rainbow-mode .app-header {
            background: var(--bg-header);
        }

        .app-header h1 {
            font-size: 18px;
            font-weight: bold;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            text-align: left;
            margin: 0;
            margin-right: auto;
            flex-shrink: 1;
            min-width: 60px;
        }
        .header-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 20px;
            padding: 5px;
            line-height: 1;
            min-width: 30px;
            flex-shrink: 0;
        }
        #goto-settings-btn {
            order: 99;
            margin-left: 5px;
        }


        .app-header #toggle-clipboard-stack-btn,
        .app-header #toggle-memo-btn,
        .app-header .scroll-jump-button,
        .app-header #toggle-all-content-btn {
            background-color: transparent !important;
            color: var(--text-light);
            box-shadow: none !important;
            border: 1px solid transparent;
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }
        .app-header #toggle-clipboard-stack-btn:hover,
        .app-header #toggle-memo-btn:hover,
        .app-header .scroll-jump-button:hover,
        .app-header #toggle-all-content-btn:hover {
            background-color: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
        }
        body.pastel-yellow-mode .app-header #toggle-clipboard-stack-btn,
        body.pastel-yellow-mode .app-header #toggle-memo-btn,
        body.pastel-yellow-mode .app-header .scroll-jump-button,
        body.pastel-yellow-mode .app-header #toggle-all-content-btn {
            color: #424242;
        }
        body.pastel-yellow-mode .app-header #toggle-clipboard-stack-btn:hover,
        body.pastel-yellow-mode .app-header #toggle-memo-btn:hover,
        body.pastel-yellow-mode .app-header .scroll-jump-button:hover,
        body.pastel-yellow-mode .app-header #toggle-all-content-btn:hover {
            background-color: rgba(0, 0, 0, 0.05) !important;
            border-color: rgba(0, 0, 0, 0.1) !important;
        }
        body.dark-mode .app-header #toggle-clipboard-stack-btn:hover,
        body.dark-mode .app-header #toggle-memo-btn:hover,
        body.dark-mode .app-header .scroll-jump-button:hover,
        body.dark-mode .app-header #toggle-all-content-btn:hover {
            background-color: rgba(255, 255, 255, 0.08) !important;
            border-color: rgba(255, 255, 255, 0.2) !important;
        }


        #history-screen .app-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: rgba(var(--bg-header-rgb, 74, 144, 226), var(--header-footer-opacity, 1));
            color: var(--text-light);
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 10;
            transition: background-color 0.3s ease;
            gap: 10px;
            flex-direction: row-reverse;
            justify-content: flex-start;
        }
        body.pastel-rainbow-mode #history-screen .app-header {
            background: var(--bg-header);
        }

        #history-screen .app-header h1#history-title {
            font-size: 18px;
            font-weight: bold;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            text-align: right;
            margin: 0;
            margin-left: auto;
            order: 2;
        }
        #history-screen .app-header #back-to-chat-from-history {
            order: 1;
        }

        #history-screen .app-header #export-all-sessions-btn {
            order: 3;
        }
        #history-screen .app-header #import-all-sessions-btn {
            order: 4;
        }
        #history-screen .app-header #import-history-btn {
            order: 5;
            margin-right: 0;
        }

        .history-action-button.gold {
            background-color: var(--bg-button-gold);
            color: var(--text-button-gold);
        }
        .history-action-button.gold:hover:not(:disabled) {
            background-color: var(--bg-button-gold-hover);
        }
        .history-action-button.purple {
            background-color: var(--bg-button-purple);
            color: var(--text-button-purple);
        }
        .history-action-button.purple:hover:not(:disabled) {
            background-color: var(--bg-button-purple-hover);
        }
        body.dark-mode .history-action-button.gold {
            background-color: var(--bg-button-gold);
            color: var(--text-button-gold);
        }
        body.dark-mode .history-action-button.gold:hover:not(:disabled) {
            background-color: var(--bg-button-gold-hover);
        }
        body.dark-mode .history-action-button.purple {
            background-color: var(--bg-button-purple);
            color: var(--text-button-purple);
        }
        body.dark-mode .history-action-button.purple:hover:not(:disabled) {
            background-color: var(--bg-button-purple-hover);
        }
        body.pastel-pink-mode .history-action-button.gold,
        body.pastel-blue-mode .history-action-button.gold,
        body.pastel-yellow-mode .history-action-button.gold,
        body.pastel-purple-mode .history-action-button.gold,
        body.pastel-rainbow-mode .history-action-button.gold {
            background-color: var(--bg-button-gold);
            color: var(--text-button-gold);
        }
        body.pastel-pink-mode .history-action-button.gold:hover:not(:disabled),
        body.pastel-blue-mode .history-action-button.gold:hover:not(:disabled),
        body.pastel-yellow-mode .history-action-button.gold:hover:not(:disabled),
        body.pastel-purple-mode .history-action-button.gold:hover:not(:disabled),
        body.pastel-rainbow-mode .history-action-button.gold:hover:not(:disabled) {
            background-color: var(--bg-button-gold-hover);
        }
        body.pastel-pink-mode .history-action-button.purple,
        body.pastel-blue-mode .history-action-button.purple,
        body.pastel-yellow-mode .history-action-button.purple,
        body.pastel-purple-mode .history-action-button.purple,
        body.pastel-rainbow-mode .history-action-button.purple {
            background-color: var(--bg-button-purple);
            color: var(--text-button-purple);
        }
        body.pastel-pink-mode .history-action-button.purple:hover:not(:disabled),
        body.pastel-blue-mode .history-action-button.purple:hover:not(:disabled),
        body.pastel-yellow-mode .history-action-button.purple:hover:not(:disabled),
        body.pastel-purple-mode .history-action-button.purple:hover:not(:disabled),
        body.pastel-rainbow-mode .history-action-button.purple:hover:not(:disabled) {
            background-color: var(--bg-button-purple-hover);
        }

        .header-save-button {
            padding: 4px 12px;
            font-size: 13px;
            background-color: var(--bg-button-save);
            color: var(--text-light);
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }
        .header-save-button:hover:not(:disabled) {
            background-color: var(--bg-button-save-hover);
        }
        body.dark-mode .header-save-button {
             background-color: var(--bg-button-save);
        }
        body.dark-mode .header-save-button:hover:not(:disabled) {
             background-color: var(--bg-button-save-hover);
        }
        .header-notice {
            font-size: 11px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.8);
            text-align: right;
            white-space: nowrap;
            flex-shrink: 0;
        }
        body.dark-mode .header-notice {
            color: rgba(255, 255, 255, 0.7);
        }
        body.pastel-pink-mode .header-notice,
        body.pastel-blue-mode .header-notice,
        body.pastel-yellow-mode .header-notice,
        body.pastel-purple-mode .header-notice,
        body.pastel-rainbow-mode .header-notice {
            color: var(--text-light);
            opacity: 0.9;
        }
        body.pastel-yellow-mode .header-button,
        body.pastel-yellow-mode .header-notice {
            color: #424242;
        }
        body.pastel-yellow-mode .new-chat-button,
        body.pastel-yellow-mode .app-header .action-button-in-header,
        body.pastel-yellow-mode .header-save-button {
            color: #424242;
        }
        body.pastel-rainbow-mode .header-button,
        body.pastel-rainbow-mode .header-notice,
        body.pastel-rainbow-mode .new-chat-button,
        body.pastel-rainbow-mode .app-header .action-button-in-header,
        body.pastel-rainbow-mode .header-save-button {
            color: var(--text-light);
        }


        .new-chat-button {
            font-size: 14px;
            padding: 5px 10px;
            background-color: var(--bg-button-save);
            color: var(--text-light);
            flex-shrink: 0;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .new-chat-button:hover {
            background-color: var(--bg-button-save-hover);
        }
        body.dark-mode .new-chat-button {
            background-color: var(--bg-button-save);
        }
        body.dark-mode .new-chat-button:hover {
            background-color: var(--bg-button-save-hover);
        }
        .app-header .action-button-in-header {
            padding: 5px 10px;
            font-size: 14px;
            color: var(--text-light);
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }
        .app-header #delete-session-btn {
            background-color: var(--bg-button-header-delete);
        }
        .app-header #delete-session-btn:hover:not(:disabled) {
            background-color: var(--bg-button-header-delete-hover);
        }
        .app-header #copy-session-btn {
            background-color: var(--bg-button-header-copy);
        }
        .app-header #copy-session-btn:hover:not(:disabled) {
            background-color: var(--bg-button-header-copy-hover);
        }

        .main-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            position: relative;
            z-index: 1;
            touch-action: pan-y;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-in-out;
            background-color: var(--bg-primary);
            z-index: 0;
        }
        .screen.active {
            transform: translateX(0);
            z-index: 1;
        }
        #chat-screen { transform: translateX(0); }
        #history-screen { transform: translateX(-100%); }
        #settings-screen { transform: translateX(100%); }

        #chat-screen {
            position: relative;
            z-index: 0;
            background-image: var(--chat-background-image);
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            transition: background-image 0.3s ease, transform 0.3s ease-in-out;
        }

        #chat-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(var(--overlay-base-rgb), var(--chat-overlay-alpha));
            z-index: 0;
            transition: background-color 0.3s ease;
            pointer-events: none;
        }

        #chat-screen .main-content {
            z-index: 1;
            background-color: transparent;
            overflow-y: scroll;
            overflow-x: auto;
            touch-action: pan-x pan-y pinch-zoom;
            flex-grow: 1;
        }
        #chat-screen .app-header { z-index: 2; }
        #chat-screen .chat-input-area {
            z-index: 2;
            background-color: rgba(var(--bg-secondary-rgb, 240, 242, 245), var(--header-footer-opacity, 1));
        }
        #history-screen .main-content,
        #settings-screen .main-content {
            touch-action: pan-y;
        }

        #memo-area {
            position: relative;
            width: 100%;
            min-height: 80px;
            max-height: var(--memo-height);
            background-color: var(--bg-memo);
            border-bottom: 1px solid var(--border-secondary);
            padding: 10px 15px;
            z-index: 5;
            box-shadow: 0 1px 3px var(--shadow-primary);
            overflow: auto;
            display: flex;
            flex-direction: column;
            transition: max-height 0.3s ease-out, padding-top 0.3s ease-out, padding-bottom 0.3s ease-out, opacity 0.3s ease-out, border-width 0.3s ease-out;
            resize: vertical;
            margin-bottom: 0;
        }

        #memo-area.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            max-height: 0 !important;
            min-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            border-width: 0 !important;
            overflow: hidden;
        }

        .memo-actions-container {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding-bottom: 8px;
            flex-shrink: 0;
        }
        .memo-actions-container button {
            padding: 4px 10px;
            font-size: 12px;
        }
        .memo-actions-container .delete-memo-btn {
            background-color: var(--bg-button-delete);
        }
        .memo-actions-container .delete-memo-btn:hover {
            background-color: var(--bg-button-delete-hover);
        }
        .memo-actions-container .copy-memo-btn {
            background-color: var(--bg-button-copy);
        }
        .memo-actions-container .copy-memo-btn:hover {
            background-color: var(--bg-button-copy-hover);
        }
        .memo-actions-container .paste-memo-btn {
            background-color: var(--bg-button-paste);
        }
        .memo-actions-container .paste-memo-btn:hover {
            background-color: var(--bg-button-paste-hover);
        }

        #memo-editor {
            flex-grow: 1;
            width: 100%;
            border: none;
            resize: none;
            background-color: transparent;
            color: var(--text-memo);
            font-family: inherit;
            font-size: 14px;
            outline: none;
            padding: 0;
            margin: 0;
            min-height: 50px;
            display: block;
        }

        #clipboard-stack-area {
            position: relative;
            width: 100%;
            min-height: 80px;
            max-height: var(--clipboard-stack-height);
            background-color: var(--bg-memo);
            border-bottom: 1px solid var(--border-secondary);
            padding: 10px 15px;
            z-index: 4;
            box-shadow: 0 1px 3px var(--shadow-primary);
            overflow: auto;
            display: flex;
            flex-direction: column;
            transition: max-height 0.3s ease-out, padding-top 0.3s ease-out, padding-bottom 0.3s ease-out, opacity 0.3s ease-out, border-width 0.3s ease-out;
            resize: vertical;
            margin-bottom: 0;
        }

        #clipboard-stack-area.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            max-height: 0 !important;
            min-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            border-width: 0 !important;
            overflow: hidden;
        }

        .clipboard-stack-actions-container {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding-bottom: 8px;
            flex-shrink: 0;
        }
        .clipboard-stack-actions-container button {
            padding: 4px 10px;
            font-size: 12px;
        }
        .clipboard-stack-actions-container .delete-clipboard-stack-btn {
            background-color: var(--bg-button-delete);
        }
        .clipboard-stack-actions-container .delete-clipboard-stack-btn:hover {
            background-color: var(--bg-button-delete-hover);
        }
        .clipboard-stack-actions-container .copy-clipboard-stack-btn {
            background-color: var(--bg-button-copy);
        }
        .clipboard-stack-actions-container .copy-clipboard-stack-btn:hover {
            background-color: var(--bg-button-copy-hover);
        }
        .clipboard-stack-actions-container .paste-clipboard-stack-btn {
            background-color: var(--bg-button-paste);
        }
        .clipboard-stack-actions-container .paste-clipboard-stack-btn:hover {
            background-color: var(--bg-button-paste-hover);
        }

        #clipboard-stack-editor {
            flex-grow: 1;
            width: 100%;
            border: none;
            resize: none;
            background-color: transparent;
            color: var(--text-memo);
            font-family: inherit;
            font-size: 14px;
            outline: none;
            padding: 0;
            margin: 0;
            min-height: 50px;
            display: block;
        }


        .system-prompt-area {
            padding: 10px 15px;
            margin-bottom: 15px;
            border: 1px solid var(--border-system);
            border-radius: 8px;
            background-color: var(--bg-system-message);
            color: var(--text-system);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease;
            position: relative;
            z-index: 1;
            overflow: hidden;
            max-height: 500px;
        }
        .system-prompt-area.hidden {
            padding-top: 0;
            padding-bottom: 0;
            margin-bottom: 0;
            border-width: 0;
            max-height: 0;
            opacity: 0;
            visibility: hidden;
        }
        .system-prompt-area details {
            width: 100%;
        }
        .system-prompt-area summary {
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-primary);
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }
        .system-prompt-area summary::-webkit-details-marker { display: none; }
        .system-prompt-area summary::marker { display: none; }
        .system-prompt-area summary::after {
            content: '▼';
            font-size: 10px;
            margin-left: 5px;
            transition: transform 0.2s ease;
        }
        .system-prompt-area details[open] summary::after {
            transform: rotate(180deg);
        }
        .system-prompt-content {
            margin-top: 10px;
        }
        .system-prompt-content textarea {
            width: 100%;
            min-height: 60px;
            max-height: 200px;
            margin-bottom: 8px;
            font-size: 13px;
            background-color: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--border-primary);
        }
        .system-prompt-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .system-prompt-actions button {
            padding: 4px 10px;
            font-size: 12px;
        }
        .system-prompt-actions .save-system-prompt-btn { background-color: var(--bg-button-save); }
        .system-prompt-actions .save-system-prompt-btn:hover { background-color: var(--bg-button-save-hover); }
        .system-prompt-actions .cancel-system-prompt-btn { background-color: var(--bg-button-cancel); }
        .system-prompt-actions .cancel-system-prompt-btn:hover { background-color: var(--bg-button-cancel-hover); }

        .message-container {
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }
        .message {
            padding: 10px 15px;
            border-radius: 15px;
            max-width: var(--message-max-width);
            min-width: 30%;
            min-height: 40px;
            position: relative;
            word-wrap: break-word;
            margin-top: 35px;
            margin-bottom: 35px;
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, opacity 0.3s ease;
            z-index: 1;
            box-shadow: 0 1px 2px var(--shadow-primary);
        }
        .message-icon {
            width: var(--message-icon-size);
            height: var(--message-icon-size);
            border-radius: 50%;
            object-fit: cover;
            position: absolute;
            top: calc( (var(--message-icon-size) / -2 + 2px) + var(--message-icon-offset-y, 0px) );
            border: 1px solid var(--border-secondary);
            background-color: var(--bg-tertiary);
            box-shadow: 0 1px 2px var(--shadow-primary);
            z-index: 2;
        }
        .message.user .message-icon {
            right: 5px;
        }
        .message.model .message-icon {
            left: 5px;
        }

        .message-icon-name {
            position: absolute;
            font-size: var(--icon-name-font-size, 10px);
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 80px;
            z-index: 2;
            top: calc(var(--message-icon-size) + var(--message-icon-offset-y, 0px) - (var(--message-icon-size) / 4) + var(--icon-name-offset-y, 0px) );
            padding: 0;
            background-color: transparent;
            border-radius: 0;
            line-height: 1.3;
        }
        .message.user .message-icon-name {
            left: auto;
            right: calc(var(--message-icon-size) + 8px);
            text-align: right;
        }
        .message.model .message-icon-name {
            left: calc(var(--message-icon-size) + 8px);
            right: auto;
            text-align: left;
        }

        .message.user .message-icon-name.has-bubble {
            background-color: var(--user-name-bubble-bg);
            padding-top: var(--user-name-bubble-padding-y);
            padding-bottom: var(--user-name-bubble-padding-y);
            padding-left: calc(var(--icon-name-font-size, 10px) * var(--user-name-bubble-padding-x-ratio));
            padding-right: calc(var(--icon-name-font-size, 10px) * var(--user-name-bubble-padding-x-ratio));
            border-radius: var(--user-name-bubble-border-radius);
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
        }

        .message.model .message-icon-name.has-bubble {
            background-color: var(--ai-name-bubble-bg);
            padding-top: var(--ai-name-bubble-padding-y);
            padding-bottom: var(--ai-name-bubble-padding-y);
            padding-left: calc(var(--icon-name-font-size, 10px) * var(--ai-name-bubble-padding-x-ratio));
            padding-right: calc(var(--icon-name-font-size, 10px) * var(--ai-name-bubble-padding-x-ratio));
            border-radius: var(--ai-name-bubble-border-radius);
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
        }


        .message.message-hidden-by-toggle {
            visibility: hidden;
            opacity: 0;
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            border-width: 0 !important;
            overflow: hidden;
        }
        .message.message-hidden-by-toggle .message-actions,
        .message.message-hidden-by-toggle .message-cascade-controls,
        .message.message-hidden-by-toggle .message-toggle-button,
        .message.message-hidden-by-toggle .message-icon,
        .message.message-hidden-by-toggle .message-icon-name {
            display: none !important;
        }

        .message:first-child {
            margin-top: 0;
        }
        .message pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: inherit;
            font-size: var(--message-body-font-size);
            margin: 0;
            color: inherit;
            transition: opacity 0.2s ease;
        }
        .message.user {
            background-color: rgba(var(--bg-user-message-rgb, 220, 248, 198), var(--message-bubble-opacity, 1));
            align-self: flex-end;
            border-bottom-right-radius: 5px;
            body:not(.dark-mode):not(.pastel-pink-mode):not(.pastel-blue-mode):not(.pastel-yellow-mode):not(.pastel-purple-mode):not(.pastel-rainbow-mode) & { color: #333; }
            body.dark-mode & { color: #e0e0e0; }
            body.pastel-pink-mode &, body.pastel-blue-mode &, body.pastel-yellow-mode &, body.pastel-purple-mode &, body.pastel-rainbow-mode & { color: var(--text-primary); }
        }
        .message.model {
            background-color: rgba(var(--bg-model-message-rgb, 229, 229, 234), var(--message-bubble-opacity, 1));
            align-self: flex-start;
            border-bottom-left-radius: 5px;
            max-width: 90%;
        }
        .message.error {
            background-color: var(--bg-error-message);
            color: var(--text-error);
            align-self: flex-start;
            border-bottom-left-radius: 5px;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .message-content.collapsed {
            max-height: 50px;
            overflow: hidden;
            position: relative;
        }
        .message-content.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            pointer-events: none;
        }
        body:not(.dark-mode):not(.pastel-pink-mode):not(.pastel-blue-mode):not(.pastel-yellow-mode):not(.pastel-purple-mode):not(.pastel-rainbow-mode) .message.user .message-content.collapsed::after {
             background: linear-gradient(to bottom, rgba(255,255,255,0) 0%, var(--bg-user-message) 100%);
        }
        body:not(.dark-mode):not(.pastel-pink-mode):not(.pastel-blue-mode):not(.pastel-yellow-mode):not(.pastel-purple-mode):not(.pastel-rainbow-mode) .message.model .message-content.collapsed::after {
             background: linear-gradient(to bottom, rgba(255,255,255,0) 0%, var(--bg-model-message) 100%);
        }
        body.dark-mode .message.user .message-content.collapsed::after {
             background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-user-message) 100%);
        }
        body.dark-mode .message.model .message-content.collapsed::after {
             background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-model-message) 100%);
        }
        body.pastel-pink-mode .message.user .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-user-message) 100%);
        }
        body.pastel-pink-mode .message.model .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-model-message) 100%);
        }
        body.pastel-blue-mode .message.user .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-user-message) 100%);
        }
        body.pastel-blue-mode .message.model .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-model-message) 100%);
        }
        body.pastel-yellow-mode .message.user .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-user-message) 100%);
        }
        body.pastel-yellow-mode .message.model .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-model-message) 100%);
        }
        body.pastel-purple-mode .message.user .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-user-message) 100%);
        }
        body.pastel-purple-mode .message.model .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-model-message) 100%);
        }
        body.pastel-rainbow-mode .message.user .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-user-message) 100%);
        }
        body.pastel-rainbow-mode .message.model .message-content.collapsed::after {
            background: linear-gradient(to bottom, rgba(var(--overlay-base-rgb),0) 0%, var(--bg-model-message) 100%);
        }


        .message-toggle-button {
            position: absolute;
            background-color: var(--bg-toggle-button);
            color: var(--text-toggle-button);
            border: none;
            border-radius: 4px;
            padding: 16px 1px;
            line-height: 1;
            cursor: pointer;
            z-index: 3;
            opacity: 0.6;
            transition: opacity 0.2s ease, background-color 0.2s ease;
            pointer-events: auto;
            min-width: auto;
            white-space: nowrap;
        }
        .message-toggle-button:hover {
            background-color: var(--bg-toggle-button-hover);
        }
        .message:hover .message-toggle-button.top,
        .message.show-actions .message-toggle-button.top {
             opacity: calc(var(--message-toggle-button-top-opacity) + 0.1);
        }
        .message:hover .message-toggle-button.bottom,
        .message.show-actions .message-toggle-button.bottom {
            opacity: 1;
        }


        .message-toggle-button.top {
            top: 3px;
            right: 3px;
            left: auto;
            z-index: 3;
            font-size: var(--message-toggle-button-top-font-size);
            width: var(--message-toggle-button-top-width);
            height: var(--message-toggle-button-top-height);
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: var(--message-toggle-button-top-opacity);
        }

        .message-toggle-button.bottom {
            position: static;
            flex-shrink: 0;
            padding: 4px 10px;
            font-size: var(--message-toggle-button-bottom-font-size);
            line-height: 1.5;
        }

        .message-actions {
            position: absolute;
            bottom: -30px;
            display: none;
            flex-wrap: nowrap;
            gap: 5px;
            background-color: rgba(var(--message-actions-base-rgb), var(--message-actions-bg-opacity));
            padding: 1px 1px 1px 1px;
            border-radius: 5px;
            box-shadow: 0 1px 3px var(--shadow-primary);
            z-index: 2;
            transition: opacity 0.2s ease, background-color 0.3s ease;
        }

        .message.user .message-actions {
            right: 0;
            left: auto;
            justify-content: flex-end;
        }
        .message.model .message-actions {
            left: 0;
            right: auto;
            justify-content: flex-start;
        }
        .message-actions button {
            background-color: var(--bg-button-action);
            color: var(--text-light);
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 4px;
            white-space: nowrap;
            line-height: 1.5;
        }
        body.pastel-yellow-mode .message-actions button,
        body.pastel-yellow-mode .message-cascade-controls button,
        body.pastel-yellow-mode .message-edit-actions button {
            color: var(--text-light);
        }


        .message-actions button:hover {
            background-color: var(--bg-button-action-hover);
        }
        .message-actions .js-edit-btn { background-color: var(--bg-button-edit); }
        .message-actions .js-edit-btn:hover { background-color: var(--bg-button-edit-hover); }
        .message-actions .js-delete-btn { background-color: var(--bg-button-delete); }
        .message-actions .js-delete-btn:hover { background-color: var(--bg-button-delete-hover); }
        .message-actions .js-retry-btn { background-color: var(--bg-button-retry); }
        .message-actions .js-retry-btn:hover { background-color: var(--bg-button-retry-hover); }
        .message-actions .js-copy-btn {
            background-color: var(--bg-button-copy);
        }
        .message-actions .js-copy-btn:hover {
            background-color: var(--bg-button-copy-hover);
        }

        .message-cascade-controls {
            position: absolute;
            top: -35px;
            left: 0;
            display: none;
            align-items: center;
            flex-wrap: nowrap;
            gap: 5px;
            background-color: rgba(var(--message-actions-base-rgb), var(--message-actions-bg-opacity));
            padding: 5px 8px 10px 8px;
            border-radius: 5px;
            box-shadow: 0 -1px 3px var(--shadow-primary);
            z-index: 2;
            transition: opacity 0.2s ease, background-color 0.3s ease;
        }
        .message.model:hover .message-cascade-controls,
        .message.model.show-actions .message-cascade-controls {
            display: flex;
        }
        .message-cascade-controls button {
            background-color: var(--bg-cascade-button);
            color: var(--text-light);
            padding: 4px 8px;
            font-size: 14px;
            border-radius: 4px;
            line-height: 1;
            min-width: 25px;
        }
        .message-cascade-controls button:hover:not(:disabled) {
            background-color: var(--bg-cascade-button-hover);
        }
        .message-cascade-controls button:disabled {
            background-color: var(--bg-button-disabled);
            cursor: not-allowed;
            opacity: 0.5;
        }
        .message-cascade-controls .cascade-indicator {
            font-size: 11px;
            color: var(--text-cascade-indicator);
            padding: 0 5px;
            white-space: nowrap;
            font-weight: 500;
        }
        .message-cascade-controls .cascade-delete-btn {
            background-color: var(--bg-cascade-delete-button);
            margin-left: 5px;
        }
        .message-cascade-controls .cascade-delete-btn:hover {
            background-color: var(--bg-cascade-delete-button-hover);
        }

        .message.editing pre {
            opacity: 0;
            height: 0;
            overflow: hidden;
            pointer-events: none;
        }
        .message.editing .message-actions,
        .message.editing .message-cascade-controls,
        .message.editing .message-toggle-button {
             opacity: 0;
             pointer-events: none;
             display: none !important;
        }
        .message-edit-area {
            margin-top: 5px;
        }
        .message-edit-area textarea {
            min-height: 60px;
            margin-bottom: 5px;
            width: 100%;
        }
        .message-edit-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 5px;
        }
        .message-edit-actions button {
            padding: 4px 10px;
            font-size: 12px;
        }
        .message-edit-actions .save-edit-btn { background-color: var(--bg-button-save); }
        .message-edit-actions .save-edit-btn:hover { background-color: var(--bg-button-save-hover); }
        .message-edit-actions .cancel-edit-btn { background-color: var(--bg-button-cancel); }
        .message-edit-actions .cancel-edit-btn:hover { background-color: var(--bg-button-cancel-hover); }

        .chat-input-area {
            display: flex;
            align-items: flex-end;
            padding: 10px 15px;
            border-top: 1px solid var(--border-primary);
            flex-shrink: 0;
            box-sizing: border-box;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            gap: 10px;
        }
        .footer-action-button {
            height: 40px;
            width: 40px;
            padding: 0;
            font-size: 20px;
            font-weight: bold;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-button-action);
            color: var(--text-light);
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .footer-action-button:hover:not(:disabled) {
            background-color: var(--bg-button-action-hover);
        }
        body.pastel-yellow-mode .footer-action-button {
            color: #424242;
        }
        .chat-input-area button#attach-file-btn {
            position: relative;
        }
        .chat-input-area button#paste-to-input-btn {
            font-size: 16px;
        }

        .attachment-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            width: var(--badge-size);
            height: var(--badge-size);
            background-color: var(--badge-color);
            border-radius: 50%;
            border: 1px solid var(--bg-primary);
            display: none;
            pointer-events: none;
        }
        .chat-input-area button#attach-file-btn.has-attachments .attachment-badge {
            display: block;
        }
        .chat-input-area textarea {
            flex-grow: 1;
            min-height: 40px;
            max-height: 120px;
            height: 40px;
            resize: none;
            margin-bottom: 0;
            padding: 8px 10px;
            overflow-y: auto;
        }
        .chat-input-area button#send-button {
            height: 40px;
            width: 40px;
            padding: 0;
            font-size: 18px;
            font-weight: bold;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .chat-input-area button#send-button.sending {
            background-color: #ffc107;
            color: #333;
        }
        .chat-input-area button#send-button.sending:hover {
            background-color: #ffa000;
        }
        body.dark-mode .chat-input-area button#send-button.sending {
            background-color: #ffd60a;
            color: #1a1a1a;
        }
        body.dark-mode .chat-input-area button#send-button.sending:hover {
            background-color: #ffca28;
        }
        body.pastel-pink-mode .chat-input-area button#send-button.sending,
        body.pastel-blue-mode .chat-input-area button#send-button.sending,
        body.pastel-yellow-mode .chat-input-area button#send-button.sending,
        body.pastel-purple-mode .chat-input-area button#send-button.sending,
        body.pastel-rainbow-mode .chat-input-area button#send-button.sending {
            background-color: #ffee88;
            color: #554400;
        }
        body.pastel-pink-mode .chat-input-area button#send-button.sending:hover,
        body.pastel-blue-mode .chat-input-area button#send-button.sending:hover,
        body.pastel-yellow-mode .chat-input-area button#send-button.sending:hover,
        body.pastel-purple-mode .chat-input-area button#send-button.sending:hover,
        body.pastel-rainbow-mode .chat-input-area button#send-button.sending:hover {
            background-color: #ffe766;
        }


        #loading-indicator {
            position: fixed;
            bottom: 65px;
            right: 20px;
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            font-style: normal;
            font-weight: 500;
            z-index: 3;
            box-shadow: 0 2px 5px var(--shadow-primary);
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s ease;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            pointer-events: none;
        }
        #loading-indicator:not(.hidden) {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        body.dark-mode #loading-indicator {
            background-color: var(--bg-input);
            color: var(--text-secondary);
            box-shadow: 0 2px 6px var(--shadow-secondary);
        }

        #history-screen {
             background-color: var(--bg-primary);
             transition: transform 0.3s ease-in-out;
        }
        #history-screen .main-content {
             background-color: transparent;
        }

        .history-list {
            list-style: none;
            padding: 0;
        }
        .history-item {
            padding: 12px;
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            margin-bottom: 10px;
            background-color: var(--bg-primary);
            transition: background-color 0.2s ease, border-color 0.3s ease;
            cursor: pointer;
        }
        .history-item:hover {
            background-color: var(--bg-tertiary);
        }
        .history-item-details {
            overflow: hidden;
            min-width: 0;
            width: 100%;
            margin-bottom: 8px;
        }
        .history-item-title {
            font-size: 15px;
            font-weight: bold;
            margin-bottom: 0px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            display: block;
            color: var(--text-primary);
        }
        .history-item-bottom-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        .history-item-dates {
            font-size: 9px;
            color: var(--text-secondary);
            flex-shrink: 0;
            line-height: 1.3;
            text-align: left;
        }
        .history-item-dates span {
            display: block;
            white-space: nowrap;
        }
        .history-item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
            flex-wrap: nowrap;
            cursor: default;
        }
        .history-item-actions button {
             cursor: pointer;
        }
        .history-item-actions .js-edit-title-btn {
            background-color: var(--bg-button-edit);
            font-size: 16px;
            padding: 6px 8px;
        }
        .history-item-actions .js-edit-title-btn:hover { background-color: var(--bg-button-edit-hover); }
        .history-item-actions .js-delete-btn { background-color: var(--bg-button-delete); }
        .history-item-actions .js-delete-btn:hover { background-color: var(--bg-button-delete-hover); }
        .history-item-actions .js-duplicate-btn { background-color: var(--bg-button-duplicate); }
        .history-item-actions .js-duplicate-btn:hover { background-color: var(--bg-button-duplicate-hover); }
        .history-item-actions .js-export-btn { background-color: var(--bg-button-export); }
        .history-item-actions .js-export-btn:hover { background-color: var(--bg-button-export-hover); }

        .js-history-item-template {
             display: none !important;
        }
        #no-history-message {
            text-align: center;
            color: var(--text-secondary);
            margin-top: 20px;
        }

        #settings-screen {
             background-color: var(--bg-primary);
             transition: transform 0.3s ease-in-out;
        }
         #settings-screen .main-content {
             background-color: transparent;
        }

        .settings-group {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid var(--border-tertiary);
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .settings-group h3 {
            margin-bottom: 15px;
            font-size: 16px;
            color: var(--text-link);
            border-bottom: 1px solid var(--border-tertiary);
            padding-bottom: 5px;
            transition: color 0.3s ease, border-color 0.3s ease;
        }
        .settings-actions {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-tertiary);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .settings-actions.bottom {
            margin-bottom: 20px;
        }
        .settings-actions button {
            width: 100%;
        }
        .danger-zone {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid var(--border-danger);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .danger-zone button {
            width: 100%;
        }
        #update-app-btn {
            background-color: var(--bg-button-update);
        }
        #update-app-btn:hover {
            background-color: var(--bg-button-update-hover);
        }
        #clear-data-btn {
            background-color: var(--bg-button-delete);
        }
        #clear-data-btn:hover {
            background-color: var(--bg-button-delete-hover);
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            color: var(--text-primary);
        }
        .checkbox-label input[type="checkbox"] {
            width: auto;
            margin-bottom: 0;
            cursor: pointer;
        }
        .param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }

        .image-upload-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .settings-action-button {
            background-color: var(--bg-button-action);
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            font-size: 14px;
            color: var(--text-light);
            cursor: pointer;
        }
        .settings-action-button:hover {
            background-color: var(--bg-button-action-hover);
        }
        .settings-delete-button {
            background-color: var(--bg-button-delete);
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            font-size: 14px;
            color: var(--text-light);
            cursor: pointer;
            margin-left: auto;
        }
        .settings-delete-button:hover {
            background-color: var(--bg-button-delete-hover);
        }
        .background-thumbnail {
            max-width: 100px;
            max-height: 60px;
            border-radius: 4px;
            border: 1px solid var(--border-tertiary);
            object-fit: cover;
            vertical-align: middle;
        }
        .icon-thumbnail {
            max-width: 40px;
            max-height: 40px;
            border-radius: 50%;
            border: 1px solid var(--border-tertiary);
            object-fit: cover;
            vertical-align: middle;
            margin-left: 10px;
        }

        @media (prefers-color-scheme: dark) {
          body:not(.light-mode-forced):not(.pastel-pink-mode):not(.pastel-blue-mode):not(.pastel-yellow-mode):not(.pastel-purple-mode):not(.pastel-rainbow-mode) {
            --bg-primary: #1a1a1a;
            --text-primary: #e0e0e0;
          }
        }

        .message-content {
            font-size: var(--message-body-font-size);
            line-height: 1.6;
            color: inherit;
            word-wrap: break-word;
            overflow-wrap: break-word;
            position: relative;
            z-index: 1;
        }
        .message-content > *:first-child { margin-top: 0; }
        .message-content > *:last-child { margin-bottom: 0; }
        .message-content h1, .message-content h2, .message-content h3, .message-content h4, .message-content h5, .message-content h6 {
            margin-top: 1.2em;
            margin-bottom: 0.6em;
            font-weight: bold;
            line-height: 1.3;
            color: inherit;
        }
        .message-content h1 { font-size: 1.8em; }
        .message-content h2 { font-size: 1.5em; }
        .message-content h3 { font-size: 1.3em; }
        .message-content h4 { font-size: 1.1em; }
        .message-content p {
            margin-bottom: 0.8em;
        }
        .message-content ul, .message-content ol {
            margin-bottom: 0.8em;
            padding-left: 2em;
        }
        .message-content li {
            margin-bottom: 0.3em;
        }
        .message-content li > ul, .message-content li > ol {
             margin-top: 0.3em;
             margin-bottom: 0.3em;
        }
        .message-content pre {
            background-color: var(--bg-secondary);
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1em 0;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: var(--code-block-font-size);
            border: 1px solid var(--border-tertiary);
            color: var(--text-secondary);
            position: relative;
        }
        .message-content pre .code-copy-button {
            position: absolute;
            bottom: 5px;
            right: 5px;
            padding: 3px 8px;
            font-size: 10px;
            background-color: var(--bg-code-copy-button);
            color: var(--text-code-copy-button);
            border: none;
            border-radius: 3px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        .message-content pre:hover .code-copy-button {
            opacity: 1;
        }
        .message-content pre .code-copy-button:hover {
            background-color: var(--bg-code-copy-button-hover);
        }
        body.pastel-yellow-mode .message-content pre .code-copy-button {
            color: var(--text-light);
        }

        .message.user .message-content pre {
             background-color: transparent;
             padding: 0;
             margin: 0;
             border: none;
             border-radius: 0;
             color: inherit;
             font-family: inherit;
             font-size: var(--message-body-font-size);
             line-height: inherit;
             white-space: pre-wrap;
             word-wrap: break-word;
             overflow-x: visible;
             position: static;
        }
        .message.user .message-content pre .code-copy-button {
            display: none;
        }
        .message-content code:not(pre > code) {
            background-color: var(--bg-secondary);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            border: 1px solid var(--border-tertiary);
            color: var(--text-secondary);
        }
        .message-content blockquote {
            margin: 1em 0;
            padding-left: 1em;
            border-left: 4px solid var(--border-primary);
            color: var(--text-secondary);
        }
        .message-content blockquote > *:first-child { margin-top: 0; }
        .message-content blockquote > *:last-child { margin-bottom: 0; }
        .message-content a {
            color: var(--text-link);
            text-decoration: underline;
        }
        .message-content strong {
            font-weight: bold;
        }
        .message-content em {
            font-style: italic;
        }
        .message-content table {
            border-collapse: collapse;
            margin: 1em 0;
            width: auto;
            border: 1px solid var(--border-secondary);
        }
        .message-content th, .message-content td {
            border: 1px solid var(--border-secondary);
            padding: 6px 10px;
            text-align: left;
        }
        .message-content th {
            background-color: var(--bg-tertiary);
            font-weight: bold;
        }
        .message-content hr {
            border: none;
            border-top: 1px solid var(--border-secondary);
            margin: 1.5em 0;
        }

        .message:hover .message-actions,
        .message.show-actions .message-actions {
            display: flex;
        }
        .message.model:hover .message-cascade-controls,
        .message.model.show-actions .message-cascade-controls {
             display: flex;
        }
        .message:hover .message-toggle-button.top,
        .message.show-actions .message-toggle-button.top {
             opacity: calc(var(--message-toggle-button-top-opacity) + 0.1);
        }
        .message:hover .message-toggle-button.bottom,
        .message.show-actions .message-toggle-button.bottom {
             opacity: 1;
        }


        .message.editing.show-actions .message-actions,
        .message.editing.show-actions .message-cascade-controls,
        .message.editing.show-actions .message-toggle-button {
            display: none !important;
        }
        .message.retrying-hidden {
            display: none !important;
        }
        body.dark-mode .message-content pre {
            background-color: var(--bg-tertiary);
            border-color: var(--border-primary);
            color: var(--text-secondary);
        }
         body.dark-mode .message-content code:not(pre > code) {
            background-color: var(--bg-tertiary);
            border-color: var(--border-primary);
            color: var(--text-secondary);
        }
        body.dark-mode .message-content blockquote {
            border-left-color: var(--border-primary);
            color: var(--text-secondary);
        }
         body.dark-mode .message-content a {
            color: var(--text-link);
         }
        body.dark-mode .message-content table,
        body.dark-mode .message-content th,
        body.dark-mode .message-content td {
            border-color: var(--border-primary);
        }
        body.dark-mode .message-content th {
            background-color: var(--bg-secondary);
        }
        body.dark-mode .message-content hr {
            border-top-color: var(--border-primary);
        }
        body.pastel-pink-mode .message-content pre,
        body.pastel-blue-mode .message-content pre,
        body.pastel-yellow-mode .message-content pre,
        body.pastel-purple-mode .message-content pre,
        body.pastel-rainbow-mode .message-content pre {
            background-color: var(--bg-tertiary);
            border-color: var(--border-secondary);
            color: var(--text-secondary);
        }
        body.pastel-pink-mode .message-content code:not(pre > code),
        body.pastel-blue-mode .message-content code:not(pre > code),
        body.pastel-yellow-mode .message-content code:not(pre > code),
        body.pastel-purple-mode .message-content code:not(pre > code),
        body.pastel-rainbow-mode .message-content code:not(pre > code) {
            background-color: var(--bg-tertiary);
            border-color: var(--border-secondary);
            color: var(--text-secondary);
        }
        body.pastel-pink-mode .message-content blockquote,
        body.pastel-blue-mode .message-content blockquote,
        body.pastel-yellow-mode .message-content blockquote,
        body.pastel-purple-mode .message-content blockquote,
        body.pastel-rainbow-mode .message-content blockquote {
            border-left-color: var(--border-primary);
            color: var(--text-secondary);
        }
        body.pastel-pink-mode .message-content th,
        body.pastel-blue-mode .message-content th,
        body.pastel-yellow-mode .message-content th,
        body.pastel-purple-mode .message-content th,
        body.pastel-rainbow-mode .message-content th {
            background-color: var(--bg-secondary);
        }


        .message-actions .token-count-display {
            font-size: 0.7rem;
            color: var(--text-secondary);
            vertical-align: middle;
            line-height: 1.5;
            white-space: nowrap;
        }

        .custom-dialog {
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 25px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            box-shadow: 0 5px 20px var(--shadow-secondary);
            min-width: 280px;
            max-width: 500px;
            width: fit-content;
            box-sizing: border-box;
            margin-left: auto;
            margin-right: auto;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            position: relative;
            z-index: 100;
        }
        .custom-dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
            transition: background-color 0.3s ease;
            z-index: 99;
        }

        body.dark-mode .custom-dialog::backdrop {
            background-color: rgba(30, 30, 30, 0.7);
        }
        body.pastel-pink-mode .custom-dialog::backdrop,
        body.pastel-blue-mode .custom-dialog::backdrop,
        body.pastel-yellow-mode .custom-dialog::backdrop,
        body.pastel-purple-mode .custom-dialog::backdrop,
        body.pastel-rainbow-mode .custom-dialog::backdrop {
            background-color: rgba(var(--overlay-base-rgb), 0.4);
        }

        .custom-dialog[open] {
            animation: dialog-fade-in 0.3s ease forwards;
        }
        @keyframes dialog-fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .custom-dialog .dialog-message {
            margin: 0 0 20px 0;
            font-size: 15px;
            line-height: 1.6;
            display: block;
            text-align: left;
        }
        .custom-dialog .dialog-input {
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 20px;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            font-size: 14px;
            background-color: var(--bg-input);
            color: var(--text-primary);
        }
        .custom-dialog .dialog-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }
        .custom-dialog button {
            padding: 8px 18px;
            font-weight: 500;
            min-width: 80px;
        }
        .custom-dialog .dialog-ok-btn {
            background-color: var(--bg-button);
            color: var(--text-light);
        }
        body.pastel-yellow-mode .custom-dialog .dialog-ok-btn,
        body.pastel-rainbow-mode .custom-dialog .dialog-ok-btn {
             color: var(--text-light);
        }
        .custom-dialog .dialog-ok-btn:hover:not(:disabled) {
            background-color: var(--bg-button-hover);
        }
         .custom-dialog .dialog-cancel-btn {
            background-color: var(--bg-button-action);
            color: var(--text-light);
        }
        body.pastel-yellow-mode .custom-dialog .dialog-cancel-btn,
        body.pastel-rainbow-mode .custom-dialog .dialog-cancel-btn {
             color: var(--text-light);
        }
        .custom-dialog .dialog-cancel-btn:hover:not(:disabled) {
            background-color: var(--bg-button-action-hover);
        }
        .citation-details {
            margin-top: 15px;
            font-size: 12px;
            border-top: 1px dashed var(--border-secondary);
            padding-top: 8px;
        }
        .citation-details summary {
            cursor: pointer;
            font-weight: normal;
            color: var(--text-secondary);
            list-style: none;
            display: inline-block;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }
        .citation-details summary::-webkit-details-marker { display: none; }
        .citation-details summary::marker { display: none; }
        .citation-details summary:hover {
            text-decoration: underline;
        }
        .citation-list {
            list-style: none;
            padding-left: 0;
            margin-top: 8px;
            margin-bottom: 0;
        }
        .citation-list li {
            margin-bottom: 5px;
            overflow-wrap: break-word;
        }
        .citation-list li a {
            color: var(--text-link);
            text-decoration: none;
            display: block;
        }
        .citation-list li a:hover {
            text-decoration: underline;
        }
        body.dark-mode .citation-details {
            border-top-color: var(--border-primary);
        }
        body.dark-mode .citation-details summary {
            color: var(--text-secondary);
        }
        body.dark-mode .citation-list li a {
            color: var(--text-link);
        }
        body.dark-mode .message-content table,
        body.dark-mode .message-content th,
        body.dark-mode .message-content td {
            border-color: var(--border-primary);
        }
        body.dark-mode .message-content th {
            background-color: var(--bg-secondary);
        }
        body.dark-mode .message-content hr {
            border-top-color: var(--border-primary);
        }
        .attachment-details {
            margin-top: 10px;
            font-size: 12px;
            border: 1px solid var(--border-attachment-details);
            border-radius: 5px;
            background-color: var(--bg-attachment-details);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .attachment-details summary {
            cursor: pointer;
            font-weight: normal;
            color: var(--text-attachment-summary);
            list-style: none;
            padding: 5px 10px;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .attachment-details summary::-webkit-details-marker { display: none; }
        .attachment-details summary::marker { display: none; }
        .attachment-details summary::before {
            content: '📎';
            font-size: 14px;
            display: inline-block;
        }
        .attachment-details[open] summary {
            border-bottom: 1px solid var(--border-attachment-details);
        }
        .attachment-list {
            list-style: none;
            padding: 8px 10px 5px 10px;
            margin: 0;
        }
        .attachment-list li {
            margin-bottom: 4px;
            font-size: 10px;
            color: var(--text-attachment-filename);
            overflow-wrap: break-word;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
        }

        #fileUploadDialog {
            min-width: 320px;
            max-width: 600px;
            width: 90%;
        }
        .dialog-content {
            margin-bottom: 20px;
        }
        .file-upload-area {
            margin-bottom: 15px;
            text-align: center;
        }
        .file-upload-area .dialog-button {
            padding: 10px 20px;
            font-size: 14px;
        }
        .file-upload-area #select-files-btn {
            background-color: var(--bg-dialog-button-select);
        }
        .file-upload-area #select-files-btn:hover {
            background-color: var(--bg-dialog-button-select-hover);
        }
        #selected-files-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-secondary);
            border-radius: 5px;
            background-color: var(--bg-secondary);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .selected-file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-dialog-file-item);
            background-color: var(--bg-dialog-file-item);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .selected-file-item:last-child {
            border-bottom: none;
        }
        .selected-file-info {
            flex-grow: 1;
            overflow: hidden;
            margin-right: 10px;
        }
        .selected-file-name {
            display: block;
            font-size: 14px;
            color: var(--text-dialog-file-name);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .selected-file-size {
            display: block;
            font-size: 11px;
            color: var(--text-dialog-file-size);
        }
        .remove-file-btn {
            background-color: var(--bg-button-delete);
            color: var(--text-light);
            border: none;
            border-radius: 15%;
            width: 22px;
            height: 22px;
            min-width: 0 !important;
            font-size: 14px;
            line-height: 1;
            padding: 0;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        body.pastel-yellow-mode .remove-file-btn,
        body.pastel-rainbow-mode .remove-file-btn {
            color: var(--text-light);
        }
        .remove-file-btn:hover {
            background-color: var(--bg-button-delete-hover);
        }
        #file-upload-notice {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 10px;
            text-align: center;
        }
        #fileUploadDialog .dialog-actions {
            margin-top: 20px;
        }
        #fileUploadDialog .dialog-actions #confirm-attach-btn {
            background-color: var(--bg-dialog-button-confirm);
        }
        #fileUploadDialog .dialog-actions #confirm-attach-btn:hover:not(:disabled) {
            background-color: var(--bg-dialog-button-confirm-hover);
        }
        #fileUploadDialog .dialog-actions #cancel-attach-btn {
            background-color: var(--bg-dialog-button-cancel);
        }
        #fileUploadDialog .dialog-actions #cancel-attach-btn:hover:not(:disabled) {
            background-color: var(--bg-button-cancel-hover);
        }
        .orange-button {
            background-color: var(--bg-button-edit);
            color: var(--text-light);
        }
        .orange-button:hover:not(:disabled) {
            background-color: var(--bg-button-edit-hover);
        }
        body.dark-mode .orange-button {
            background-color: var(--bg-button-edit);
            color: var(--text-light);
        }
        body.dark-mode .orange-button:hover:not(:disabled) {
            background-color: var(--bg-button-edit-hover);
        }
        body.pastel-pink-mode .orange-button,
        body.pastel-blue-mode .orange-button,
        body.pastel-yellow-mode .orange-button,
        body.pastel-purple-mode .orange-button,
        body.pastel-rainbow-mode .orange-button {
            background-color: var(--bg-button-edit);
            color: var(--text-light);
        }
        body.pastel-pink-mode .orange-button:hover:not(:disabled),
        body.pastel-blue-mode .orange-button:hover:not(:disabled),
        body.pastel-yellow-mode .orange-button:hover:not(:disabled),
        body.pastel-purple-mode .orange-button:hover:not(:disabled),
        body.pastel-rainbow-mode .orange-button:hover:not(:disabled) {
            background-color: var(--bg-button-edit-hover);
        }
        body.pastel-yellow-mode .orange-button {
            color: #ffffff;
        }
        .danger-zone .orange-button {
            margin-top: 10px;
            width: 100%;
        }
        .interactive-title-content-style {
            margin-left: 3px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
    </style>
    <script src="marked.js"></script>
</head>
<body>
    <div class="app-container">

        <div id="chat-screen" class="screen active">
            <header class="app-header">
                <button id="goto-history-btn" class="header-button" aria-label="履歴一覧へ">☰</button>
                <h1 id="chat-title">新規チャット</h1>
                <button id="new-chat-btn" class="new-chat-button" title="新規チャットを開始">新</button>
                <button id="delete-session-btn" class="action-button-in-header" title="現在のチャットを削除">削</button>
                <button id="copy-session-btn" class="action-button-in-header" title="チャット全体をコピー">コ</button>
                <button id="scroll-to-top-btn" class="header-button scroll-jump-button" aria-label="最上部へスクロール" title="最上部へ">🔼</button>
                <button id="scroll-to-bottom-btn" class="header-button scroll-jump-button" aria-label="最下部へスクロール" title="最下部へ">🔽</button>
                <button id="toggle-all-content-btn" class="header-button" aria-label="全メッセージ表示切替" title="全メッセージの表示/非表示を切り替え">🖼️</button>
                <button id="toggle-clipboard-stack-btn" class="header-button" aria-label="クリップボードスタックを開閉">🗒️</button>
                <button id="toggle-memo-btn" class="header-button" aria-label="メモを開閉">📝</button>
                <button id="goto-settings-btn" class="header-button" aria-label="設定へ">⚙</button>
            </header>

            <div id="memo-area" class="hidden">
                <div class="memo-actions-container">
                    <button id="delete-memo-btn" class="delete-memo-btn" title="メモの内容を全て削除">全削除</button>
                    <button id="copy-memo-btn" class="copy-memo-btn" title="メモをコピー">コピー</button>
                    <button id="paste-memo-btn" class="paste-memo-btn" title="メモに貼り付け">貼付け</button>
                </div>
                <textarea id="memo-editor" aria-label="メモ入力エリア" placeholder="ここに一時的なメモを入力...（保存されません）"></textarea>
            </div>

            <div id="clipboard-stack-area" class="hidden">
                <div class="clipboard-stack-actions-container">
                    <button id="delete-clipboard-stack-btn" class="delete-clipboard-stack-btn" title="スタックの内容を全て削除">全削除</button>
                    <button id="copy-clipboard-stack-btn" class="copy-clipboard-stack-btn" title="スタック全体をコピー">全コピー</button>
                    <button id="paste-clipboard-stack-btn" class="paste-clipboard-stack-btn" title="スタックに貼り付け">貼付け</button>
                </div>
                <textarea id="clipboard-stack-editor" aria-label="クリップボードスタック入力エリア" placeholder="ここにコピーされたメッセージが蓄積されます...（保存されません）"></textarea>
            </div>

            <main class="main-content">
                <div id="system-prompt-area" class="system-prompt-area">
                    <details id="system-prompt-details">
                        <summary>システムプロンプト</summary>
                        <div class="system-prompt-content">
                            <textarea id="system-prompt-editor" aria-label="システムプロンプト編集"></textarea>
                            <div class="system-prompt-actions">
                                <button id="cancel-system-prompt-btn" class="cancel-system-prompt-btn">キャンセル</button>
                                <button id="save-system-prompt-btn" class="save-system-prompt-btn">保存</button>
                            </div>
                        </div>
                    </details>
                </div>
                <div id="message-container" class="message-container">
                </div>
                <div id="loading-indicator" class="loading-indicator hidden" aria-live="polite">応答中</div>
            </main>
            <footer class="chat-input-area">
                <button id="paste-to-input-btn" title="入力欄に貼り付け" class="footer-action-button">貼</button>
                <textarea id="user-input" placeholder="メッセージを入力..." rows="1" aria-label="メッセージ入力"></textarea>
                <button id="attach-file-btn" title="ファイルを添付" class="footer-action-button">+<span class="attachment-badge"></span></button>
                <button id="send-button" title="送信">送</button>
            </footer>
        </div>

        <div id="history-screen" class="screen">
            <header class="app-header">
                <button id="back-to-chat-from-history" class="header-button" aria-label="チャットへ戻る">＞</button>
                <h1 id="history-title">履歴一覧</h1>

                <button id="export-all-sessions-btn" class="header-save-button history-action-button gold" title="全セッションをJSON形式で出力">全出力</button>

                <button id="import-all-sessions-btn" class="header-save-button history-action-button purple" title="全セッションをJSON形式で取込">全取込</button>
                <input type="file" id="import-all-sessions-input" accept=".json" class="hidden">

                <button id="import-history-btn" class="header-save-button" title="単一履歴をテキスト形式でインポート">インポート</button>
                <input type="file" id="import-history-input" accept=".txt" class="hidden">
            </header>
            <main class="main-content">
                <ul id="history-list" class="history-list">
                    <li class="js-history-item-template history-item">
                        <div class="history-item-details">
                            <span class="history-item-title"></span>
                        </div>
                        <div class="history-item-bottom-row">
                            <div class="history-item-dates">
                                <span class="created-date"></span>
                                <span class="updated-date"></span>
                            </div>
                            <div class="history-item-actions">
                                <button class="js-edit-title-btn" title="タイトル編集">✎</button>
                                <button class="js-export-btn" title="出力">出力</button>
                                <button class="js-duplicate-btn" title="複製">複製</button>
                                <button class="js-delete-btn" title="削除">削除</button>
                            </div>
                        </div>
                    </li>
                </ul>
                 <p id="no-history-message" class="hidden" style="text-align: center; color: var(--text-secondary); margin-top: 20px;">チャット履歴はありません。</p>
            </main>
        </div>

        <div id="settings-screen" class="screen">
            <header class="app-header">
                 <button id="back-to-chat-from-settings" class="header-button" aria-label="チャットへ戻る">＜</button>
                 <h1>設定</h1>
                 <span id="settings-save-notice" class="header-notice">※反映には保存が必要</span>
                 <button class="js-save-settings-btn header-save-button" title="設定を保存">設定を保存</button>
            </header>
            <main class="main-content">
                <div class="settings-group">
                    <h3>基本設定</h3>
                    <label for="api-key">Gemini APIキー:</label>
                    <input type="password" id="api-key" placeholder="APIキーを入力" aria-label="Gemini APIキー">

                    <label for="model-name">モデル名:</label>
                    <select id="model-name" aria-label="モデル名">
                        <optgroup label="無料">
                            <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                            <option value="gemini-2.5-flash-preview-04-17">gemini-2.5-flash-preview-04-17</option>
                            <option value="gemini-2.5-pro-exp-03-25">gemini-2.5-pro-exp-03-25</option>
                        </optgroup>
                        <optgroup label="有料">
                            <option value="gemini-2.5-pro-preview-03-25">gemini-2.5-pro-preview-03-25</option>
                            <option value="gemini-2.5-pro-preview-05-06">gemini-2.5-pro-preview-05-06</option>
                        </optgroup>
                        <optgroup label="ユーザー指定" id="user-defined-models-group">
                        </optgroup>
                    </select>

                    <label class="checkbox-label">
                        <input type="checkbox" id="streaming-output">
                        ストリーミング出力を使用する
                    </label>

                    <label for="streaming-speed">文字送り速度 (ミリ秒/文字):</label>
                    <input type="number" id="streaming-speed" min="0" step="1" placeholder="例: 30 (0で無効)" aria-label="文字送り速度">
                </div>

                <div class="settings-group">
                    <h3>パラメータ</h3>
                    <label for="system-prompt-default">システムプロンプト (デフォルト):</label>
                    <textarea id="system-prompt-default" placeholder="例: あなたは親切なアシスタントです。新規チャット作成時に適用されます。" aria-label="システムプロンプト (デフォルト)"></textarea>

                    <div class="param-grid">
                        <div>
                            <label for="max-tokens">Max Tokens:</label>
                            <input type="number" id="max-tokens" step="1" min="1" placeholder="例:1024" aria-label="Max Tokens">
                        </div>
                        <div>
                            <label for="temperature">Temperature:</label>
                            <input type="number" id="temperature" step="0.1" min="0" max="2" placeholder="例:0.9(0.0-2.0)" aria-label="Temperature">
                        </div>
                        <div>
                            <label for="top-k">Top K:</label>
                            <input type="number" id="top-k" step="1" min="1" placeholder="例:40(1-40)" aria-label="Top K">
                        </div>
                        <div>
                            <label for="top-p">Top P:</label>
                            <input type="number" id="top-p" step="0.01" min="0" max="1" placeholder="例:0.95(0.0 - 1.0)" aria-label="Top P">
                        </div>
                    </div>

                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; font-weight: normal; font-size: 14px; color: var(--text-link); margin-bottom: 10px;">その他パラメータ</summary>
                        <div class="param-grid">
                             <div>
                                <label for="presence-penalty">Presence Penalty:</label>
                                <input type="number" id="presence-penalty" step="0.1" min="-2.0" max="1.9" placeholder="例:0.0 (-2.0～2.0未満)" aria-label="Presence Penalty">
                             </div>
                             <div>
                                <label for="frequency-penalty">Frequency Penalty:</label>
                                <input type="number" id="frequency-penalty" step="0.1" min="-2.0" max="1.9" placeholder="例:0.0 (-2.0～2.0未満)" aria-label="Frequency Penalty">
                            </div>
                        </div>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">
                            ※ Presence/Frequency Penaltyは一部モデルでは非対応、APIエラーとなる場合あり
                        </p>
                        <p style="height:16px;"></p>
                        <div class="param-grid">
                            <div>
                                <label for="thinking-budget">Thinking Budget:</label>
                                <input type="number" id="thinking-budget" step="1" min="0" placeholder="例: 5000 (0～24576整数)" aria-label="Thinking Budget">
                            </div>
                        </div>
                        <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">
                            ※ Thinking Budgetは新しいGeminiモデルのみ対応。0明示でthinkingをOFF。<br>
                            ※ 1～1024指定時は固定で1024になる
                        </p>
                    </details>
                </div>

                <div class="settings-group">
                   <h3>アドバンスド</h3>
                   <label for="dummy-user">ダミー User プロンプト (送信時のみ追加):</label>
                   <textarea id="dummy-user" placeholder="API送信直前に user ロールとして履歴末尾に追加されます" aria-label="ダミー User プロンプト"></textarea>

                   <label for="dummy-model">ダミー Model プロンプト (送信時のみ追加):</label>
                   <textarea id="dummy-model" placeholder="API送信直前に model ロールとして履歴最末尾に追加されます" aria-label="ダミー Model プロンプト"></textarea>

                   <label class="checkbox-label">
                       <input type="checkbox" id="concat-dummy-model">
                       ダミーモデルと回答を連結
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※チェック時、モデル応答の先頭に上記ダミーModelの内容を付与。
                   </p>

                   <label class="checkbox-label">
                       <input type="checkbox" id="pseudo-streaming">
                       疑似ストリーミングを使用<br> (ストリーミングON時のみ有効)
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※実際には一括生成を呼び、応答はストリーミング再生を行う。<br>
                       普通のストリーミングより生成待ち時間は長くなる。
                   </p>
                </div>
                <div class="settings-group">
                    <h3>検索</h3>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enable-grounding-toggle">
                        ネットから情報を取得させる (Google Search)
                    </label>
                    <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                        ※ チェック時、モデルは回答生成のためにWeb検索を行う。<br>
                        ※ 2.0以降でのみ対応(1.5以前は互換なし。エラーになる)<br>
                        ※ 推論モデルは推論内で検索する場合があり、引用データが帰らない場合がある。
                    </p>
                </div>
                <div class="settings-group">
                    <h3>イメージ画像</h3>
                    <label>チャット画面の背景画像:</label>
                    <div class="image-upload-controls">
                        <input type="file" id="background-image-input" accept="image/jpeg, image/png, image/gif, image/webp" class="hidden">
                        <button id="upload-background-btn" class="settings-action-button" type="button">画像を選択...</button>
                        <img id="background-thumbnail" src="" alt="背景画像プレビュー" class="background-thumbnail hidden">
                        <button id="delete-background-btn" class="settings-delete-button hidden" type="button">画像を削除</button>
                    </div>
                     <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">
                       ※ 画像はブラウザ内のデータベースに保存。<br>
                       ※ 可読性のため画像の上に半透明のレイヤーを表示。
                     </p>
                </div>

                <div class="settings-group">
                    <h3>チャットアイコン設定</h3>
                    <label class="checkbox-label">
                        <input type="checkbox" id="show-user-icon-toggle">
                        ユーザーアイコンを表示する
                    </label>
                    <div class="image-upload-controls" style="margin-bottom: 5px;">
                        <input type="file" id="user-icon-input" accept="image/jpeg, image/png, image/gif, image/webp" class="hidden">
                        <button id="upload-user-icon-btn" class="settings-action-button" type="button">ユーザーアイコン選択...</button>
                        <img id="user-icon-thumbnail" src="" alt="ユーザーアイコンプレビュー" class="icon-thumbnail hidden">
                        <button id="delete-user-icon-btn" class="settings-delete-button hidden" type="button">削除</button>
                    </div>
                    <label class="checkbox-label" style="margin-top: 5px;">
                        <input type="checkbox" id="show-user-name-toggle">
                        ユーザー名を表示する
                    </label>
                    <label for="user-name-input">表示するユーザー名:</label>
                    <input type="text" id="user-name-input" placeholder="例: あなた" aria-label="表示するユーザー名">


                    <label class="checkbox-label" style="margin-top: 20px;">
                        <input type="checkbox" id="show-ai-icon-toggle">
                        AIアイコンを表示する
                    </label>
                    <div class="image-upload-controls" style="margin-bottom: 5px;">
                        <input type="file" id="ai-icon-input" accept="image/jpeg, image/png, image/gif, image/webp" class="hidden">
                        <button id="upload-ai-icon-btn" class="settings-action-button" type="button">AIアイコン選択...</button>
                        <img id="ai-icon-thumbnail" src="" alt="AIアイコンプレビュー" class="icon-thumbnail hidden">
                        <button id="delete-ai-icon-btn" class="settings-delete-button hidden" type="button">削除</button>
                    </div>
                    <label class="checkbox-label" style="margin-top: 5px;">
                        <input type="checkbox" id="show-ai-name-toggle">
                        AI名を表示する
                    </label>
                    <label for="ai-name-input">表示するAI名:</label>
                    <input type="text" id="ai-name-input" placeholder="例: Gemini" aria-label="表示するAI名">

                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; font-weight: normal; font-size: 14px; color: var(--text-link);">アイコン表示調整</summary>
                        <div style="padding-left: 15px; margin-top: 10px;">
                            <div style="margin-top: 10px;">
                                <label for="icon-name-font-size">アイコン下の名前の文字サイズ (px):</label>
                                <input type="number" id="icon-name-font-size" min="1" max="46" step="1" placeholder="例: 10" aria-label="アイコン下の名前の文字サイズ（上限あり）">
                            </div>
                            <div style="margin-top: 10px;">
                                <label for="icon-name-offset-y">名前の垂直オフセット (px, 上が正):</label>
                                <input type="number" id="icon-name-offset-y" step="1" placeholder="例: 10" aria-label="名前の垂直オフセット（上限あり）">
                            </div>
                            <div style="margin-top: 20px;">
                                <label for="message-icon-size">アイコン表示サイズ (px):</label>
                                <input type="number" id="message-icon-size" min="1" max="300" step="1" placeholder="例: 28" aria-label="アイコン表示サイズ（上限あり）">
                            </div>
                            <div style="margin-top: 15px;">
                                <label for="message-icon-offset-y">アイコン垂直オフセット (px, 上が正):</label>
                                <input type="number" id="message-icon-offset-y" step="1" placeholder="例: 0 (上下に調整)" aria-label="アイコン垂直オフセット（上限あり）">
                            </div>
                            <hr style="margin: 20px 0;">
                            <h4>ユーザー名の背景バブル</h4>
                            <label class="checkbox-label">
                                <input type="checkbox" id="user-name-bubble-toggle">
                                バブルを表示する
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" id="user-name-bubble-use-theme-color-toggle">
                                テーマのメッセージ色に合わせる
                            </label>
                            <div id="user-name-bubble-custom-color-settings">
                                <label for="user-name-bubble-color">背景色 (上記OFF時):</label>
                                <input type="text" id="user-name-bubble-color" placeholder="#FFFFFF">
                            </div>
                            <label for="user-name-bubble-opacity">透過度 (0.0-1.0):</label>
                            <input type="number" id="user-name-bubble-opacity" min="0" max="1" step="0.1" placeholder="0.8">

                            <h4 style="margin-top: 15px;">AI名の背景バブル</h4>
                            <label class="checkbox-label">
                                <input type="checkbox" id="ai-name-bubble-toggle">
                                バブルを表示する
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" id="ai-name-bubble-use-theme-color-toggle">
                                テーマのメッセージ色に合わせる
                            </label>
                            <div id="ai-name-bubble-custom-color-settings">
                                <label for="ai-name-bubble-color">背景色 (上記OFF時):</label>
                                <input type="text" id="ai-name-bubble-color" placeholder="#FFFFFF">
                            </div>
                            <label for="ai-name-bubble-opacity">透過度 (0.0-1.0):</label>
                            <input type="number" id="ai-name-bubble-opacity" min="0" max="1" step="0.1" placeholder="0.8">
                        </div>
                     </details>
                     </p>
                     <p style="font-size: 11px; color: var(--text-secondary); margin-top: 15px;">
                       ※ アイコン画像はブラウザ内のデータベースに保存されます。<br>
                       ※ 表示時は円形に切り取られます。デフォルトサイズ: 28px。
                     </p>
                </div>

                <div class="settings-group">
                    <h3>メモ・スタック機能</h3>
                    <label class="checkbox-label">
                        <input type="checkbox" id="show-memo-button-toggle">
                        ヘッダーにメモボタン(📝)を表示する
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="show-clipboard-stack-button-toggle">
                        ヘッダーにクリップボードスタックボタン(🗒️)を表示する
                    </label>
                    <div>
                        <label for="memo-height">メモの縦の幅 (例: 200px, 30vh):</label>
                        <input type="text" id="memo-height" placeholder="例: 200px, 30vh (縦にリサイズ可能)" aria-label="メモの縦の幅（上限あり）">
                    </div>
                    <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">
                        ※ 高さはピクセル(px)またはビューポート高さ(vh)で指定できます。<br>
                        ※ デフォルト: 300px。各エリアは縦方向にリサイズ可能です。（上限あり）
                    </p>
                </div>

                <div class="settings-group">
                   <h3>その他設定</h3>
                   <label class="checkbox-label">
                       <input type="checkbox" id="enter-to-send">
                       Enterキーで送信する
                   </label>

                   <label class="checkbox-label">
                       <input type="checkbox" id="auto-scroll-on-new-message">
                       メッセージ送受信時に自動スクロールする
                   </label>
                   <p style="height:10px"></p>
                   <label class="checkbox-label">
                       <input type="checkbox" id="swipe-navigation-toggle">
                       チャット画面から左右スワイプで画面移動
                   </label>
                   <label class="checkbox-label">
                       <input type="checkbox" id="prevent-zoom-toggle">
                       ズームを禁止する (テキスト入力時の自動ズーム防止)
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※ スマホ等でテキスト入力時に意図せずズームするのを防ぎます。
                   </p>
                   <label class="checkbox-label">
                        <input type="checkbox" id="show-paste-button-in-edit-toggle">
                        メッセージ編集ツールバーに「貼付け」ボタンを表示する
                    </label>
                   <p style="height:10px"></p>
                   <label for="theme-select">表示テーマ:</label>
                   <select id="theme-select" aria-label="表示テーマ">
                       <option value="light">ライトモード</option>
                       <option value="dark">ダークモード</option>
                       <option value="pastel-pink">パステルモード🩷</option>
                       <option value="pastel-blue">パステルモード🩵</option>
                       <option value="pastel-yellow">パステルモード🟡</option>
                       <option value="pastel-purple">パステルモード🟣</option>
                       <option value="pastel-rainbow">パステルモード🌈</option>
                   </select>
                   <p style="height:10px"></p>
                   <label class="checkbox-label">
                       <input type="checkbox" id="show-new-chat-button-toggle">
                       ヘッダーに「新規」ボタンを表示する（「新」ボタン）
                   </label>
                   <label class="checkbox-label">
                       <input type="checkbox" id="show-delete-session-button-toggle">
                       ヘッダーに「全削除」ボタンを表示する（「削」ボタン）
                   </label>
                   <label class="checkbox-label">
                       <input type="checkbox" id="show-copy-session-button-toggle">
                       ヘッダーに「全コピー」ボタンを表示する（「コ」ボタン）
                   </label>
                   <label class="checkbox-label">
                       <input type="checkbox" id="show-scroll-to-top-button-toggle">
                       ヘッダーに「最上部へ(🔼)」ボタンを表示する
                   </label>
                   <label class="checkbox-label">
                       <input type="checkbox" id="show-scroll-to-bottom-button-toggle">
                       ヘッダーに「最下部へ(🔽)」ボタンを表示する
                   </label>
                   <label class="checkbox-label">
                       <input type="checkbox" id="show-toggle-all-content-button-toggle">
                       ヘッダーに「全表示/非表示(🖼️)」ボタンを表示する
                   </label>
                   <label class="checkbox-label">
                        <input type="checkbox" id="show-bulk-history-actions-toggle">
                        履歴画面に「全出力」「全取込」ボタンを表示する
                    </label>
                   <label class="checkbox-label">
                       <input type="checkbox" id="show-paste-button-in-footer-toggle">
                       フッターに「貼付け」ボタンを表示する
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※ 以上のボタン類は必要な物のみオンにしてください。（ヘッダーを圧迫し⚙ボタンが画面から溢れ、“チャット画面から左右スワイプで画面移動”オプションもオフにしている場合、設定画面に入れなくなる恐れがあります）
                   <p style="height:10px"></p>
                   <label class="checkbox-label">
                       <input type="checkbox" id="hide-system-prompt-toggle">
                       システムプロンプト非表示
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※ 没入感を高めたい場合に。非表示でも機能は有効。
                   </p>
                    <label class="checkbox-label">
                       <input type="checkbox" id="show-collapse-buttons-toggle">
                       メッセージ折りたたみボタンを表示する
                   </label>
                    <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※ 各メッセージの上部と下部にテキストを折りたたむボタンを表示。
                   </p>
                   <details style="margin-top: 5px; margin-bottom: 15px;">
                        <summary style="cursor: pointer; font-weight: normal; font-size: 14px; color: var(--text-link);">折りたたみボタン詳細設定</summary>
                        <div style="padding-left: 15px; margin-top: 10px;">
                            <label class="checkbox-label" style="margin-top: 10px; margin-bottom: 15px;">
                                <input type="checkbox" id="persist-message-collapse-state">
                                メッセージの折り畳み状態を記憶する
                            </label>
                            <hr style="margin-bottom: 15px;">
                            <label for="toggle-button-top-width">右上ボタン 横幅 (px):</label>
                            <input type="number" id="toggle-button-top-width" min="1" max="100" step="1" placeholder="例: 6">
                            <label for="toggle-button-top-height">右上ボタン 縦幅 (px):</label>
                            <input type="number" id="toggle-button-top-height" min="1" max="100" step="1" placeholder="例: 40">
                            <label for="toggle-button-top-font-size">右上ボタン フォントサイズ (px):</label>
                            <input type="number" id="toggle-button-top-font-size" min="1" max="50" step="1" placeholder="例: 12">
                            <label for="toggle-button-top-text-collapse">右上ボタン 折りたたみ時テキスト:</label>
                            <input type="text" id="toggle-button-top-text-collapse" placeholder="例: -">
                            <label for="toggle-button-top-text-expand">右上ボタン 展開時テキスト:</label>
                            <input type="text" id="toggle-button-top-text-expand" placeholder="例: □">

                            <hr style="margin: 15px 0;">

                            <label for="toggle-button-bottom-font-size">下部ボタン フォントサイズ (px):</label>
                            <input type="number" id="toggle-button-bottom-font-size" min="1" max="34" step="1" placeholder="例: 14">
                            <label for="toggle-button-bottom-text-collapse">下部ボタン 折りたたみ時テキスト:</label>
                            <input type="text" id="toggle-button-bottom-text-collapse" placeholder="例: 非表示">
                            <label for="toggle-button-bottom-text-expand">下部ボタン 展開時テキスト:</label>
                            <input type="text" id="toggle-button-bottom-text-expand" placeholder="例: 表示">
                        </div>
                   </details>
                   <label for="history-sort-order">履歴のソート順:</label>
                   <select id="history-sort-order" aria-label="履歴のソート順">
                       <option value="updatedAt">更新日時 (新しい順)</option>
                       <option value="createdAt">作成日時 (新しい順)</option>
                   </select>
                   <label for="font-family-input">アプリのフォント:</label>
                   <input type="text" id="font-family-input" placeholder="例: 'Meiryo', sans-serif" aria-label="アプリ全体のフォント">
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 5px;">
                       ※ 端末またはPCにインストールされているフォント名を指定。
                   </p>
                   <label for="message-body-font-size-input">メッセージ本文のフォントサイズ (px):</label>
                   <input type="number" id="message-body-font-size-input" placeholder="例: 14 (デフォルト)" aria-label="メッセージ本文のフォントサイズ">
                   <label for="code-block-font-size-input">コードブロックのフォントサイズ (px):</label>
                   <input type="number" id="code-block-font-size-input" placeholder="例: 13 (デフォルト)" aria-label="コードブロックのフォントサイズ">
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※ 空欄でデフォルト値。
                   </p>
                   <label for="additional-models">追加モデル (カンマ区切り):</label>
                   <textarea id="additional-models" placeholder="例: gemini-2.0-pro,gemini-2.0-flash-lite" aria-label="追加モデル"></textarea>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※ 追加後は設定を保存の上、ページをリロード。
                   </p>
                   <details style="margin-top: 15px; margin-bottom: 15px;">
                        <summary style="cursor: pointer; font-weight: normal; font-size: 14px; color: var(--text-link);">各種透明度設定</summary>
                        <div style="padding-left: 15px; margin-top: 10px;">
                            <label for="message-bubble-opacity">メッセージバブルの透明度 (0.0-1.0):</label>
                            <input type="number" id="message-bubble-opacity" min="0" max="1" step="0.05" placeholder="例: 0.8" aria-label="メッセージバブルの透明度">
                            <label for="message-actions-background-opacity">メッセージツールバーの透明度（除ボタン） (0.0-1.0):</label>
                            <input type="number" id="message-actions-background-opacity" min="0" max="1" step="0.05" placeholder="例: 0.8" aria-label="メッセージツールバーの透明度（除ボタン）">
                            <label for="chat-overlay-opacity">チャット背景オーバーレイの透明度 (0.0-1.0):</label>
                            <input type="number" id="chat-overlay-opacity" min="0" max="1" step="0.05" placeholder="例: 0.6" aria-label="チャット背景オーバーレイの透明度">
                            <label for="header-footer-opacity">ヘッダー/フッターの透明度 (0.0-1.0):</label>
                            <input type="number" id="header-footer-opacity" min="0" max="1" step="0.05" placeholder="例: 0.9" aria-label="ヘッダー/フッターの透明度">
                            <label for="toggle-button-top-opacity">右上折りたたみボタンの透明度 (0.0-1.0):</label>
                            <input type="number" id="toggle-button-top-opacity" min="0" max="1" step="0.05" placeholder="例: 0.6" aria-label="右上折りたたみボタンの透明度">
                        </div>
                   </details>
                </div>

                <div class="danger-zone">

                     <p style="text-align: center; color: var(--text-secondary); font-size: 12px; margin-bottom: 10px;">
                         バージョン: <span id="app-version"></span>
                     </p>
                     <button id="update-app-btn">アプリを更新 (キャッシュクリア)</button>
                     <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px; text-align:center;">
                         ※ サーバー側のhtmlファイルなどはブラウザにキャッシュされるため、<BR>
                         このボタンで明示的にサーバーから再取得しない限り更新されない。
                     </p>
                     <details style="text-align:center;">
                         <summary style="cursor: pointer; font-weight: normal; font-size: 14px; color: var(--text-link); margin-bottom: 10px;">※取り扱い注意項目※</summary>
                         <button id="clear-history-btn" class="orange-button">全履歴削除</button>
                         <p style="font-size: 11px; color: var(--text-secondary); margin-top:5px; margin-bottom: 10px;">
                             ※ ブラウザに保存されているチャット履歴を全て削除します。設定は保持されます。<BR>
                         </p>
                         <button id="clear-data-btn">⚠⚠⚠全データクリア (履歴と設定)⚠⚠⚠</button>
                         <p style="font-size: 11px; color: var(--text-secondary); margin-top:5px; margin-bottom: 10px;">
                             ※ ブラウザに保存されている設定や履歴を全て削除。<BR>
                             ！！間違えて押そうとしていないか注意！！
                         </p>

                     </details>
                </div>
            </main>
        </div>
    </div>

    <dialog id="alertDialog" class="custom-dialog">
        <p class="dialog-message"></p>
        <div class="dialog-actions">
            <button value="ok" class="dialog-ok-btn">OK</button>
        </div>
    </dialog>

    <dialog id="confirmDialog" class="custom-dialog">
        <p class="dialog-message"></p>
        <div class="dialog-actions">
            <button value="cancel" class="dialog-cancel-btn">キャンセル</button>
            <button value="ok" class="dialog-ok-btn">OK</button>
        </div>
    </dialog>

    <dialog id="promptDialog" class="custom-dialog">
        <label class="dialog-message" for="promptInput"></label>
        <input type="text" id="promptInput" class="dialog-input">
        <div class="dialog-actions">
            <button value="cancel" class="dialog-cancel-btn">キャンセル</button>
            <button value="ok" class="dialog-ok-btn">OK</button>
        </div>
    </dialog>

    <dialog id="fileUploadDialog" class="custom-dialog">
        <div class="dialog-content">
            <div class="file-upload-area">
                <input type="file" id="file-input" multiple accept="image/*,text/*,application/pdf,video/*,audio/*" class="hidden">
                <button id="select-files-btn" class="dialog-button">ファイルを選択</button>
            </div>
            <ul id="selected-files-list">
            </ul>
            <p id="file-upload-notice">画像、テキスト、PDF、動画、音声などを添付可能</p>
        </div>
        <div class="dialog-actions">
            <button id="cancel-attach-btn" value="cancel" class="dialog-cancel-btn">キャンセル</button>
            <button id="confirm-attach-btn" value="ok" class="dialog-ok-btn" disabled>添付して閉じる</button>
        </div>
    </dialog>

    <script>
        const DB_NAME = 'GeminiPWA_DB';
        const DB_VERSION = 8;
        const SETTINGS_STORE = 'settings';
        const CHATS_STORE = 'chats';
        const CHAT_UPDATEDAT_INDEX = 'updatedAtIndex';
        const CHAT_CREATEDAT_INDEX = 'createdAtIndex';
        const DEFAULT_MODEL = 'gemini-2.0-flash';
        const DEFAULT_STREAMING_SPEED = 12;
        const DEFAULT_TEMPERATURE = 0.5;
        const DEFAULT_MAX_TOKENS = 4000;
        const DEFAULT_TOP_K = 40;
        const DEFAULT_TOP_P = 0.95;
        const DEFAULT_FONT_FAMILY = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
        const DEFAULT_MESSAGE_BODY_FONT_SIZE = 14;
        const DEFAULT_CODE_BLOCK_FONT_SIZE = 13;
        const DEFAULT_MEMO_HEIGHT = '300px';
        const DEFAULT_CLIPBOARD_STACK_HEIGHT = '300px';
        const DEFAULT_MESSAGE_ICON_SIZE = 28;
        const DEFAULT_MESSAGE_ICON_OFFSET_Y = -10;
        const DEFAULT_USER_NAME = "あなた";
        const DEFAULT_AI_NAME = "AI";
        const DEFAULT_ICON_NAME_FONT_SIZE = 10;
        const DEFAULT_ICON_NAME_OFFSET_Y = -10;
        const DEFAULT_USER_NAME_BUBBLE_COLOR = '#FFFFFF';
        const DEFAULT_USER_NAME_BUBBLE_OPACITY = 0.8;
        const DEFAULT_AI_NAME_BUBBLE_COLOR = '#FFFFFF';
        const DEFAULT_AI_NAME_BUBBLE_OPACITY = 0.8;
        const CHAT_TITLE_LENGTH = 15;
        const TEXTAREA_MAX_HEIGHT = 120;
        const GEMINI_API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/';
        const DUPLICATE_SUFFIX = ' (コピー)';
        const IMPORT_PREFIX = '(取込) ';

        const LIGHT_THEME_COLOR = '#4a90e2';
        const DARK_THEME_COLOR = '#007aff';
        const PASTEL_PINK_THEME_COLOR = '#ff8fab';
        const PASTEL_BLUE_THEME_COLOR = '#87cefa';
        const PASTEL_YELLOW_THEME_COLOR = '#ffd700';
        const PASTEL_PURPLE_THEME_COLOR = '#ab47bc';
        const PASTEL_RAINBOW_THEME_COLOR = '#ffadad';


        const DARK_MODE_USER_MESSAGE_COLOR = '#056162';
        const DARK_MODE_MODEL_MESSAGE_COLOR = '#3a3a3c';
        const DARK_MODE_SECONDARY_COLOR = '#101010';
        const DARK_MODE_PRIMARY_COLOR = '#1a1a1a';

        const PASTEL_PINK_USER_MESSAGE_COLOR = '#ffddee';
        const PASTEL_PINK_MODEL_MESSAGE_COLOR = '#f3e8ff';
        const PASTEL_PINK_SECONDARY_COLOR = '#ffe6ea';
        const PASTEL_PINK_HEADER_COLOR = '#ff8fab';
        const PASTEL_PINK_PRIMARY_COLOR = '#fff5f8';

        const PASTEL_BLUE_USER_MESSAGE_COLOR = '#cff1ef';
        const PASTEL_BLUE_MODEL_MESSAGE_COLOR = '#e0e8ff';
        const PASTEL_BLUE_SECONDARY_COLOR = '#e0f0ff';
        const PASTEL_BLUE_HEADER_COLOR = '#87cefa';
        const PASTEL_BLUE_PRIMARY_COLOR = '#f0f8ff';

        const PASTEL_YELLOW_USER_MESSAGE_COLOR = '#fff5ba';
        const PASTEL_YELLOW_MODEL_MESSAGE_COLOR = '#ffe4b5';
        const PASTEL_YELLOW_SECONDARY_COLOR = '#fffacd';
        const PASTEL_YELLOW_HEADER_COLOR = '#ffd700';
        const PASTEL_YELLOW_PRIMARY_COLOR = '#fffefa';

        const PASTEL_PURPLE_USER_MESSAGE_COLOR = '#d1c4e9';
        const PASTEL_PURPLE_MODEL_MESSAGE_COLOR = '#c5cae9';
        const PASTEL_PURPLE_SECONDARY_COLOR = '#e1bee7';
        const PASTEL_PURPLE_HEADER_COLOR = '#ab47bc';
        const PASTEL_PURPLE_PRIMARY_COLOR = '#f3e5f5';

        const PASTEL_RAINBOW_USER_MESSAGE_COLOR = '#e0fff0';
        const PASTEL_RAINBOW_MODEL_MESSAGE_COLOR = '#e0f0ff';
        const PASTEL_RAINBOW_SECONDARY_COLOR = '#f0f0f0';
        const PASTEL_RAINBOW_HEADER_COLOR = '#ffadad';
        const PASTEL_RAINBOW_PRIMARY_COLOR = '#fdfdfd';


        const LIGHT_MODE_USER_MESSAGE_COLOR = '#dcf8c6';
        const LIGHT_MODE_MODEL_MESSAGE_COLOR = '#e5e5ea';
        const LIGHT_MODE_SECONDARY_COLOR = '#f0f2f5';
        const LIGHT_MODE_HEADER_COLOR = '#4a90e2';
        const LIGHT_MODE_PRIMARY_COLOR = '#ffffff';


        const APP_VERSION = "0.25ti";
        const SWIPE_THRESHOLD = 50;
        const ZOOM_THRESHOLD = 1.01;
        const MAX_FILE_SIZE = 10 * 1024 * 1024;
        const MAX_TOTAL_ATTACHMENT_SIZE = 50 * 1024 * 1024;
        const COLLAPSED_HEIGHT = 50;
        const DEFAULT_MESSAGE_BUBBLE_OPACITY = 0.9;
        const DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY = 0.9;
        const DEFAULT_HEADER_FOOTER_OPACITY = 0.35;
        const DEFAULT_CHAT_OVERLAY_OPACITY = 0.7;

        const DEFAULT_TOGGLE_BUTTON_TOP_WIDTH = 6;
        const DEFAULT_TOGGLE_BUTTON_TOP_HEIGHT = 40;
        const DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE = 12;
        const DEFAULT_TOGGLE_BUTTON_TOP_OPACITY = 0.6;
        const DEFAULT_TOGGLE_BUTTON_TOP_TEXT_COLLAPSE = "-";
        const DEFAULT_TOGGLE_BUTTON_TOP_TEXT_EXPAND = "◻︎";
        const DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE = 14;
        const DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_COLLAPSE = "_";
        const DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_EXPAND = "□";
        const DEFAULT_AUTO_SCROLL_ON_NEW_MESSAGE = true;
        const DEFAULT_PERSIST_MESSAGE_COLLAPSE_STATE = true;

        const extensionToMimeTypeMap = {
            'pdf': 'application/pdf', 'js': 'text/javascript', 'py': 'text/x-python',
            'txt': 'text/plain', 'html': 'text/html', 'htm': 'text/html', 'css': 'text/css',
            'md': 'text/md', 'csv': 'text/csv', 'xml': 'text/xml', 'rtf': 'text/rtf',
            'png': 'image/png', 'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'webp': 'image/webp',
            'heic': 'image/heic', 'heif': 'image/heif',
            'mp4': 'video/mp4', 'mpeg': 'video/mpeg', 'mov': 'video/mov', 'avi': 'video/avi',
            'flv': 'video/x-flv', 'mpg': 'video/mpg', 'webm': 'video/webm', 'wmv': 'video/wmv',
            '3gp': 'video/3gpp', '3gpp': 'video/3gpp',
            'wav': 'audio/wav', 'mp3': 'audio/mp3', 'aiff': 'audio/aiff', 'aac': 'audio/aac',
            'ogg': 'audio/ogg', 'flac': 'audio/flac',
        };

        const elements = {
            appContainer: document.querySelector('.app-container'),
            chatScreen: document.getElementById('chat-screen'),
            historyScreen: document.getElementById('history-screen'),
            settingsScreen: document.getElementById('settings-screen'),
            chatTitle: document.getElementById('chat-title'),
            messageContainer: document.getElementById('message-container'),
            userInput: document.getElementById('user-input'),
            sendButton: document.getElementById('send-button'),
            loadingIndicator: document.getElementById('loading-indicator'),
            historyList: document.getElementById('history-list'),
            historyTitle: document.getElementById('history-title'),
            noHistoryMessage: document.getElementById('no-history-message'),
            historyItemTemplate: document.querySelector('.js-history-item-template'),
            themeColorMeta: document.getElementById('theme-color-meta'),
            systemPromptArea: document.getElementById('system-prompt-area'),
            systemPromptDetails: document.getElementById('system-prompt-details'),
            systemPromptEditor: document.getElementById('system-prompt-editor'),
            saveSystemPromptBtn: document.getElementById('save-system-prompt-btn'),
            cancelSystemPromptBtn: document.getElementById('cancel-system-prompt-btn'),
            apiKeyInput: document.getElementById('api-key'),
            modelNameSelect: document.getElementById('model-name'),
            userDefinedModelsGroup: document.getElementById('user-defined-models-group'),
            streamingOutputCheckbox: document.getElementById('streaming-output'),
            streamingSpeedInput: document.getElementById('streaming-speed'),
            systemPromptDefaultTextarea: document.getElementById('system-prompt-default'),
            temperatureInput: document.getElementById('temperature'),
            maxTokensInput: document.getElementById('max-tokens'),
            topKInput: document.getElementById('top-k'),
            topPInput: document.getElementById('top-p'),
            presencePenaltyInput: document.getElementById('presence-penalty'),
            frequencyPenaltyInput: document.getElementById('frequency-penalty'),
            thinkingBudgetInput: document.getElementById('thinking-budget'),
            dummyUserInput: document.getElementById('dummy-user'),
            dummyModelInput: document.getElementById('dummy-model'),
            concatDummyModelCheckbox: document.getElementById('concat-dummy-model'),
            additionalModelsTextarea: document.getElementById('additional-models'),
            pseudoStreamingCheckbox: document.getElementById('pseudo-streaming'),
            enterToSendCheckbox: document.getElementById('enter-to-send'),
            autoScrollOnNewMessageCheckbox: document.getElementById('auto-scroll-on-new-message'),
            historySortOrderSelect: document.getElementById('history-sort-order'),
            themeSelect: document.getElementById('theme-select'),
            fontFamilyInput: document.getElementById('font-family-input'),
            messageBodyFontSizeInput: document.getElementById('message-body-font-size-input'),
            codeBlockFontSizeInput: document.getElementById('code-block-font-size-input'),
            hideSystemPromptToggle: document.getElementById('hide-system-prompt-toggle'),
            enableGroundingToggle: document.getElementById('enable-grounding-toggle'),
            swipeNavigationToggle: document.getElementById('swipe-navigation-toggle'),
            preventZoomToggle: document.getElementById('prevent-zoom-toggle'),
            showNewChatButtonToggle: document.getElementById('show-new-chat-button-toggle'),
            showDeleteSessionButtonToggle: document.getElementById('show-delete-session-button-toggle'),
            showCopySessionButtonToggle: document.getElementById('show-copy-session-button-toggle'),
            showScrollToTopButtonToggle: document.getElementById('show-scroll-to-top-button-toggle'),
            showScrollToBottomButtonToggle: document.getElementById('show-scroll-to-bottom-button-toggle'),
            showToggleAllContentButtonToggle: document.getElementById('show-toggle-all-content-button-toggle'),
            showBulkHistoryActionsToggle: document.getElementById('show-bulk-history-actions-toggle'),
            showPasteButtonInFooterToggle: document.getElementById('show-paste-button-in-footer-toggle'),
            showPasteButtonInEditToggle: document.getElementById('show-paste-button-in-edit-toggle'),
            messageBubbleOpacityInput: document.getElementById('message-bubble-opacity'),
            chatOverlayOpacityInput: document.getElementById('chat-overlay-opacity'),
            headerFooterOpacityInput: document.getElementById('header-footer-opacity'),
            messageActionsBackgroundOpacityInput: document.getElementById('message-actions-background-opacity'),
            appVersionSpan: document.getElementById('app-version'),
            backgroundImageInput: document.getElementById('background-image-input'),
            uploadBackgroundBtn: document.getElementById('upload-background-btn'),
            backgroundThumbnail: document.getElementById('background-thumbnail'),
            deleteBackgroundBtn: document.getElementById('delete-background-btn'),
            gotoHistoryBtn: document.getElementById('goto-history-btn'),
            gotoSettingsBtn: document.getElementById('goto-settings-btn'),
            backToChatFromHistoryBtn: document.getElementById('back-to-chat-from-history'),
            backToChatFromSettingsBtn: document.getElementById('back-to-chat-from-settings'),
            newChatBtn: document.getElementById('new-chat-btn'),
            deleteSessionBtn: document.getElementById('delete-session-btn'),
            copySessionBtn: document.getElementById('copy-session-btn'),
            scrollToTopBtn: document.getElementById('scroll-to-top-btn'),
            scrollToBottomBtn: document.getElementById('scroll-to-bottom-btn'),
            toggleAllContentBtn: document.getElementById('toggle-all-content-btn'),
            saveSettingsBtns: document.querySelectorAll('.js-save-settings-btn'),
            updateAppBtn: document.getElementById('update-app-btn'),
            clearDataBtn: document.getElementById('clear-data-btn'),
            clearHistoryBtn: document.getElementById('clear-history-btn'),
            importHistoryBtn: document.getElementById('import-history-btn'),
            importHistoryInput: document.getElementById('import-history-input'),
            exportAllSessionsBtn: document.getElementById('export-all-sessions-btn'),
            importAllSessionsBtn: document.getElementById('import-all-sessions-btn'),
            importAllSessionsInput: document.getElementById('import-all-sessions-input'),
            alertDialog: document.getElementById('alertDialog'),
            alertMessage: document.getElementById('alertDialog').querySelector('.dialog-message'),
            alertOkBtn: document.getElementById('alertDialog').querySelector('.dialog-ok-btn'),
            confirmDialog: document.getElementById('confirmDialog'),
            confirmMessage: document.getElementById('confirmDialog').querySelector('.dialog-message'),
            confirmOkBtn: document.getElementById('confirmDialog').querySelector('.dialog-ok-btn'),
            confirmCancelBtn: document.getElementById('confirmDialog').querySelector('.dialog-cancel-btn'),
            promptDialog: document.getElementById('promptDialog'),
            promptMessage: document.getElementById('promptDialog').querySelector('.dialog-message'),
            promptInput: document.getElementById('promptDialog').querySelector('.dialog-input'),
            promptOkBtn: document.getElementById('promptDialog').querySelector('.dialog-ok-btn'),
            promptCancelBtn: document.getElementById('promptDialog').querySelector('.dialog-cancel-btn'),
            attachFileBtn: document.getElementById('attach-file-btn'),
            pasteToInputBtn: document.getElementById('paste-to-input-btn'),
            fileUploadDialog: document.getElementById('fileUploadDialog'),
            fileInput: document.getElementById('file-input'),
            selectFilesBtn: document.getElementById('select-files-btn'),
            selectedFilesList: document.getElementById('selected-files-list'),
            confirmAttachBtn: document.getElementById('confirm-attach-btn'),
            cancelAttachBtn: document.getElementById('cancel-attach-btn'),
            toggleMemoBtn: document.getElementById('toggle-memo-btn'),
            memoArea: document.getElementById('memo-area'),
            memoEditor: document.getElementById('memo-editor'),
            copyMemoBtn: document.getElementById('copy-memo-btn'),
            pasteMemoBtn: document.getElementById('paste-memo-btn'),
            deleteMemoBtn: document.getElementById('delete-memo-btn'),
            showMemoButtonToggle: document.getElementById('show-memo-button-toggle'),
            memoHeightInput: document.getElementById('memo-height'),
            showCollapseButtonsToggle: document.getElementById('show-collapse-buttons-toggle'),
            persistMessageCollapseStateCheckbox: document.getElementById('persist-message-collapse-state'),
            toggleClipboardStackBtn: document.getElementById('toggle-clipboard-stack-btn'),
            clipboardStackArea: document.getElementById('clipboard-stack-area'),
            clipboardStackEditor: document.getElementById('clipboard-stack-editor'),
            deleteClipboardStackBtn: document.getElementById('delete-clipboard-stack-btn'),
            copyClipboardStackBtn: document.getElementById('copy-clipboard-stack-btn'),
            pasteClipboardStackBtn: document.getElementById('paste-clipboard-stack-btn'),
            showClipboardStackButtonToggle: document.getElementById('show-clipboard-stack-button-toggle'),
            showUserIconToggle: document.getElementById('show-user-icon-toggle'),
            userIconInput: document.getElementById('user-icon-input'),
            uploadUserIconBtn: document.getElementById('upload-user-icon-btn'),
            userIconThumbnail: document.getElementById('user-icon-thumbnail'),
            deleteUserIconBtn: document.getElementById('delete-user-icon-btn'),
            showUserNameToggle: document.getElementById('show-user-name-toggle'),
            userNameInput: document.getElementById('user-name-input'),
            showAiIconToggle: document.getElementById('show-ai-icon-toggle'),
            aiIconInput: document.getElementById('ai-icon-input'),
            uploadAiIconBtn: document.getElementById('upload-ai-icon-btn'),
            aiIconThumbnail: document.getElementById('ai-icon-thumbnail'),
            deleteAiIconBtn: document.getElementById('delete-ai-icon-btn'),
            showAiNameToggle: document.getElementById('show-ai-name-toggle'),
            aiNameInput: document.getElementById('ai-name-input'),
            iconNameFontSizeInput: document.getElementById('icon-name-font-size'),
            iconNameOffsetYInput: document.getElementById('icon-name-offset-y'),
            messageIconSizeInput: document.getElementById('message-icon-size'),
            messageIconOffsetYInput: document.getElementById('message-icon-offset-y'),
            userNameBubbleToggle: document.getElementById('user-name-bubble-toggle'),
            userNameBubbleUseThemeColorToggle: document.getElementById('user-name-bubble-use-theme-color-toggle'),
            userNameBubbleColorInput: document.getElementById('user-name-bubble-color'),
            userNameBubbleOpacityInput: document.getElementById('user-name-bubble-opacity'),
            aiNameBubbleToggle: document.getElementById('ai-name-bubble-toggle'),
            aiNameBubbleUseThemeColorToggle: document.getElementById('ai-name-bubble-use-theme-color-toggle'),
            aiNameBubbleColorInput: document.getElementById('ai-name-bubble-color'),
            aiNameBubbleOpacityInput: document.getElementById('ai-name-bubble-opacity'),
            toggleButtonTopWidthInput: document.getElementById('toggle-button-top-width'),
            toggleButtonTopHeightInput: document.getElementById('toggle-button-top-height'),
            toggleButtonTopFontSizeInput: document.getElementById('toggle-button-top-font-size'),
            toggleButtonTopTextCollapseInput: document.getElementById('toggle-button-top-text-collapse'),
            toggleButtonTopTextExpandInput: document.getElementById('toggle-button-top-text-expand'),
            toggleButtonBottomFontSizeInput: document.getElementById('toggle-button-bottom-font-size'),
            toggleButtonBottomTextCollapseInput: document.getElementById('toggle-button-bottom-text-collapse'),
            toggleButtonBottomTextExpandInput: document.getElementById('toggle-button-bottom-text-expand'),
            toggleButtonTopOpacityInput: document.getElementById('toggle-button-top-opacity'),
        };

        const state = {
            db: null,
            currentChatId: null,
            currentMessages: [],
            currentSystemPrompt: '',
            settings: {
                apiKey: '',
                modelName: DEFAULT_MODEL,
                streamingOutput: true,
                streamingSpeed: DEFAULT_STREAMING_SPEED,
                systemPrompt: '',
                temperature: null,
                maxTokens: null,
                topK: null,
                topP: null,
                presencePenalty: null,
                frequencyPenalty: null,
                thinkingBudget: null,
                dummyUser: '',
                dummyModel: '',
                concatDummyModel: false,
                additionalModels: '',
                pseudoStreaming: false,
                enterToSend: true,
                autoScrollOnNewMessage: DEFAULT_AUTO_SCROLL_ON_NEW_MESSAGE,
                historySortOrder: 'updatedAt',
                theme: 'light',
                backgroundImageBlob: null,
                fontFamily: '',
                messageBodyFontSize: DEFAULT_MESSAGE_BODY_FONT_SIZE,
                codeBlockFontSize: DEFAULT_CODE_BLOCK_FONT_SIZE,
                hideSystemPromptInChat: false,
                enableGrounding: false,
                enableSwipeNavigation: true,
                preventZoom: true,
                showNewChatButton: true,
                showDeleteSessionButton: false,
                showCopySessionButton: false,
                showScrollToTopButton: true,
                showScrollToBottomButton: true,
                showToggleAllContentButton: false,
                showBulkHistoryActions: true,
                showPasteButtonInFooter: false,
                showPasteButtonInEdit: false,
                showMemoButton: false,
                memoHeight: DEFAULT_MEMO_HEIGHT,
                showClipboardStackButton: false,
                clipboardStackHeight: DEFAULT_CLIPBOARD_STACK_HEIGHT,
                showUserIcon: false,
                userIconBlob: null,
                showUserName: false,
                userName: DEFAULT_USER_NAME,
                showAiIcon: false,
                aiIconBlob: null,
                showAiName: false,
                aiName: DEFAULT_AI_NAME,
                iconNameFontSize: DEFAULT_ICON_NAME_FONT_SIZE,
                iconNameOffsetY: DEFAULT_ICON_NAME_OFFSET_Y,
                messageIconSize: DEFAULT_MESSAGE_ICON_SIZE,
                messageIconOffsetY: DEFAULT_MESSAGE_ICON_OFFSET_Y,
                showUserNameBubble: false,
                userNameBubbleUseThemeColor: false,
                userNameBubbleColor: DEFAULT_USER_NAME_BUBBLE_COLOR,
                userNameBubbleOpacity: DEFAULT_USER_NAME_BUBBLE_OPACITY,
                showAiNameBubble: false,
                aiNameBubbleUseThemeColor: false,
                aiNameBubbleColor: DEFAULT_AI_NAME_BUBBLE_COLOR,
                aiNameBubbleOpacity: DEFAULT_AI_NAME_BUBBLE_OPACITY,
                showCollapseButtons: true,
                persistMessageCollapseState: DEFAULT_PERSIST_MESSAGE_COLLAPSE_STATE,
                messageBubbleOpacity: DEFAULT_MESSAGE_BUBBLE_OPACITY,
                chatOverlayOpacity: DEFAULT_CHAT_OVERLAY_OPACITY,
                headerFooterOpacity: DEFAULT_HEADER_FOOTER_OPACITY,
                messageActionsBackgroundOpacity: DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY,
                toggleButtonTopWidth: DEFAULT_TOGGLE_BUTTON_TOP_WIDTH,
                toggleButtonTopHeight: DEFAULT_TOGGLE_BUTTON_TOP_HEIGHT,
                toggleButtonTopFontSize: DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE,
                toggleButtonTopOpacity: DEFAULT_TOGGLE_BUTTON_TOP_OPACITY,
                toggleButtonTopTextCollapse: DEFAULT_TOGGLE_BUTTON_TOP_TEXT_COLLAPSE,
                toggleButtonTopTextExpand: DEFAULT_TOGGLE_BUTTON_TOP_TEXT_EXPAND,
                toggleButtonBottomFontSize: DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE,
                toggleButtonBottomTextCollapse: DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_COLLAPSE,
                toggleButtonBottomTextExpand: DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_EXPAND,
            },
            backgroundImageUrl: null,
            userIconUrl: null,
            aiIconUrl: null,
            isSending: false,
            abortController: null,
            partialStreamContent: '',
            editingMessageIndex: null,
            isEditingSystemPrompt: false,
            touchStartX: 0,
            touchStartY: 0,
            touchEndX: 0,
            touchEndY: 0,
            isSwiping: false,
            isZoomed: false,
            currentScreen: 'chat',
            selectedFilesForUpload: [],
            pendingAttachments: [],
            isMemoVisible: false,
            isClipboardStackVisible: false,
            clipboardStackContent: "",
            areAllMessagesHidden: false,
            messageCollapsedStates: new Map(),
        };

        function updateMessageMaxWidthVar() {
            const container = elements.messageContainer;
            if (!container) return;
            let maxWidthPx = container.clientWidth * 0.8;
            document.documentElement.style.setProperty('--message-max-width', `${maxWidthPx}px`);
        }

        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(updateMessageMaxWidthVar, 150);
        });

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(registration => {
                            navigator.serviceWorker.addEventListener('message', event => {
                                if (event.data && event.data.action === 'reloadPage') {
                                    alert('アプリが更新されました。ページをリロードします。');
                                    window.location.reload();
                                }
                            });
                        })
                        .catch(err => {
                            console.error('ServiceWorker registration failed: ', err);
                        });
                });
            }
        }

        const dbUtils = {
            openDB() {
                return new Promise((resolve, reject) => {
                    if (state.db) {
                        resolve(state.db);
                        return;
                    }
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = (event) => reject(`IndexedDBエラー: ${event.target.error}`);
                    request.onsuccess = (event) => {
                        state.db = event.target.result;
                        state.db.onerror = (event) => { console.error(`データベースエラー: ${event.target.error}`); };
                        resolve(state.db);
                    };
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        const transaction = event.target.transaction;
                        if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
                            db.createObjectStore(SETTINGS_STORE, { keyPath: 'key' });
                        }
                        let chatStore;
                        if (!db.objectStoreNames.contains(CHATS_STORE)) {
                            chatStore = db.createObjectStore(CHATS_STORE, { keyPath: 'id', autoIncrement: true });
                        } else {
                             if (transaction) {
                                try { chatStore = transaction.objectStore(CHATS_STORE); } catch (e) { console.error("チャットストア取得エラー(upgradeneeded):", e); return; }
                            }
                        }
                        if (chatStore && !chatStore.indexNames.contains(CHAT_UPDATEDAT_INDEX)) {
                            chatStore.createIndex(CHAT_UPDATEDAT_INDEX, 'updatedAt', { unique: false });
                        }
                        if (chatStore && !chatStore.indexNames.contains(CHAT_CREATEDAT_INDEX)) {
                            chatStore.createIndex(CHAT_CREATEDAT_INDEX, 'createdAt', { unique: false });
                        }
                    };
                });
            },
            _getStore(storeName, mode = 'readonly') {
                if (!state.db) throw new Error("データベースが開かれていません");
                const transaction = state.db.transaction([storeName], mode);
                return transaction.objectStore(storeName);
            },
            async saveSetting(key, value) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                     try {
                        const store = this._getStore(SETTINGS_STORE, 'readwrite');
                        const request = store.put({ key, value });
                        request.onsuccess = () => resolve();
                        request.onerror = (event) => reject(`設定 ${key} の保存エラー: ${event.target.error}`);
                    } catch (error) {
                        reject(`設定 ${key} 保存のためのストアアクセスエラー: ${error}`);
                    }
                });
            },
            async loadSettings() {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(SETTINGS_STORE);
                    const request = store.getAll();
                    request.onsuccess = (event) => {
                        const settingsArray = event.target.result;
                        const loadedSettings = {};
                        settingsArray.forEach(item => {
                            loadedSettings[item.key] = item.value;
                        });
                        const defaultSettings = { ...state.settings };
                        state.settings = { ...defaultSettings };

                        if (loadedSettings.hasOwnProperty('darkMode') && !loadedSettings.hasOwnProperty('theme')) {
                            state.settings.theme = loadedSettings.darkMode === true ? 'dark' : 'light';
                        }

                        for (const key in loadedSettings) {
                             if (key === 'darkMode') continue;
                             if (key === 'memoWidth') continue;

                             if (key in defaultSettings) {
                                const loadedValue = loadedSettings[key];
                                const defaultValue = defaultSettings[key];

                                if (key === 'backgroundImageBlob' || key === 'userIconBlob' || key === 'aiIconBlob') {
                                    if (loadedValue instanceof Blob) {
                                         state.settings[key] = loadedValue;
                                    } else {
                                         state.settings[key] = null;
                                    }
                                } else if (key === 'theme') {
                                    if (['light', 'dark', 'pastel-pink', 'pastel-blue', 'pastel-yellow', 'pastel-purple', 'pastel-rainbow'].includes(loadedValue)) {
                                        state.settings[key] = loadedValue;
                                    } else {
                                        state.settings[key] = defaultValue;
                                    }
                                } else if (key === 'hideSystemPromptInChat' || key === 'enableGrounding' || key === 'enableSwipeNavigation' ||
                                           key === 'preventZoom' ||
                                           key === 'showNewChatButton' || key === 'showDeleteSessionButton' || key === 'showCopySessionButton' ||
                                           key === 'showScrollToTopButton' || key === 'showScrollToBottomButton' || key === 'showToggleAllContentButton' ||
                                           key === 'showBulkHistoryActions' || key === 'showPasteButtonInFooter' || key === 'showPasteButtonInEdit' ||
                                           key === 'showMemoButton' || key === 'showClipboardStackButton' || key === 'showUserIcon' || key === 'showAiIcon' ||
                                           key === 'showUserName' || key === 'showAiName' || key === 'showCollapseButtons' || key === 'persistMessageCollapseState' ||
                                           key === 'streamingOutput' || key === 'pseudoStreaming' || key === 'enterToSend' ||
                                           key === 'concatDummyModel' || key === 'autoScrollOnNewMessage' ||
                                           key === 'showUserNameBubble' || key === 'showAiNameBubble' ||
                                           key === 'userNameBubbleUseThemeColor' || key === 'aiNameBubbleUseThemeColor') {
                                     state.settings[key] = loadedValue === true;
                                } else if (key === 'toggleButtonTopFontSize' || key === 'toggleButtonBottomFontSize' || key === 'toggleButtonTopWidth' || key === 'toggleButtonTopHeight') {
                                    let num = parseInt(loadedValue, 10);
                                    if (isNaN(num)) {
                                        state.settings[key] = defaultValue;
                                    } else {
                                        if (key === 'toggleButtonTopFontSize' && (num < 1 || num > 50)) num = defaultValue;
                                        if (key === 'toggleButtonBottomFontSize' && (num < 1 || num > 34)) num = defaultValue;
                                        if ((key === 'toggleButtonTopWidth' || key === 'toggleButtonTopHeight') && (num < 1 || num > 100)) num = defaultValue;
                                        state.settings[key] = num;
                                    }
                                } else if (key === 'toggleButtonTopTextCollapse' || key === 'toggleButtonTopTextExpand' ||
                                           key === 'toggleButtonBottomTextCollapse' || key === 'toggleButtonBottomTextExpand') {
                                    state.settings[key] = typeof loadedValue === 'string' && loadedValue.trim() !== '' ? loadedValue : defaultValue;
                                } else if (typeof defaultValue === 'number' || defaultValue === null) {
                                     let num;
                                     if (key === 'temperature' || key === 'topP' || key === 'presencePenalty' || key === 'frequencyPenalty' ||
                                         key === 'messageBubbleOpacity' || key === 'chatOverlayOpacity' || key === 'headerFooterOpacity' ||
                                         key === 'messageActionsBackgroundOpacity' || key === 'toggleButtonTopOpacity' ||
                                         key === 'messageIconSize' || key === 'messageIconOffsetY' || key === 'iconNameFontSize' || key === 'iconNameOffsetY' ||
                                         key === 'userNameBubbleOpacity' || key === 'aiNameBubbleOpacity' ||
                                         key === 'messageBodyFontSize' || key === 'codeBlockFontSize') {
                                         num = parseFloat(loadedValue);
                                     } else {
                                         num = parseInt(loadedValue, 10);
                                     }
                                     if (isNaN(num)) {
                                         if ((key === 'temperature' || key === 'maxTokens' || key === 'topK' || key === 'topP' ||
                                             key === 'presencePenalty' || key === 'frequencyPenalty' || key === 'thinkingBudget' ||
                                             key === 'messageBubbleOpacity' || key === 'chatOverlayOpacity' || key === 'headerFooterOpacity' ||
                                             key === 'messageActionsBackgroundOpacity' || key === 'toggleButtonTopOpacity' ||
                                             key === 'userNameBubbleOpacity' || key === 'aiNameBubbleOpacity' ||
                                             key === 'messageBodyFontSize' || key === 'codeBlockFontSize'
                                             ) && (loadedValue === null || loadedValue === '')) {
                                              state.settings[key] = null;
                                         } else {
                                              state.settings[key] = defaultValue;
                                         }
                                     } else {
                                          if (key === 'temperature' && (num < 0 || num > 2)) num = defaultValue;
                                          if (key === 'maxTokens' && num < 1) num = defaultValue;
                                          if (key === 'topK' && num < 1) num = defaultValue;
                                          if (key === 'topP' && (num < 0 || num > 1)) num = defaultValue;
                                          if (key === 'streamingSpeed' && num < 0) num = defaultValue;
                                          if ((key === 'presencePenalty' || key === 'frequencyPenalty') && (num < -2.0 || num >= 2.0)) num = defaultValue;
                                          if (key === 'thinkingBudget' && (num < 0 || !Number.isInteger(num))) num = defaultValue;
                                          if ((key === 'messageBubbleOpacity' || key === 'chatOverlayOpacity' || key === 'headerFooterOpacity' ||
                                              key === 'messageActionsBackgroundOpacity' || key === 'toggleButtonTopOpacity' ||
                                              key === 'userNameBubbleOpacity' || key === 'aiNameBubbleOpacity'
                                              ) && (num < 0 || num > 1)) num = defaultValue;
                                          if (key === 'messageIconSize' && (num < 1 || num > 300)) num = defaultValue;
                                          if (key === 'messageIconOffsetY' && (num < -200 || num > 200)) num = defaultValue;
                                          if (key === 'iconNameFontSize' && (num < 1 || num > 46)) num = defaultValue;
                                          if (key === 'iconNameOffsetY' && (num < -200 || num > 200)) num = defaultValue;
                                          if ((key === 'messageBodyFontSize' || key === 'codeBlockFontSize') && (num < 8 || num > 32)) num = defaultValue;
                                          state.settings[key] = num;
                                     }
                                } else if (typeof defaultValue === 'string') {
                                     state.settings[key] = typeof loadedValue === 'string' ? loadedValue : defaultValue;
                                } else {
                                    state.settings[key] = loadedValue;
                                }
                            }
                        }
                        if (!['light', 'dark', 'pastel-pink', 'pastel-blue', 'pastel-yellow', 'pastel-purple', 'pastel-rainbow'].includes(state.settings.theme)) {
                            state.settings.theme = window.matchMedia?.('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
                        }
                        resolve(state.settings);
                    };
                    request.onerror = (event) => reject(`設定読み込みエラー: ${event.target.error}`);
                });
            },
            async saveChat(optionalTitle = null) {
                await this.openDB();
                if ((!state.currentMessages || state.currentMessages.length === 0) && !state.currentSystemPrompt) {
                    return Promise.resolve(state.currentChatId);
                }
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE, 'readwrite');
                    const now = Date.now();
                    const messagesToSave = state.currentMessages.map(msg => ({
                        role: msg.role, content: msg.content, timestamp: msg.timestamp,
                        ...(msg.finishReason && { finishReason: msg.finishReason }),
                        ...(msg.safetyRatings && { safetyRatings: msg.safetyRatings }),
                        ...(msg.error && { error: msg.error }),
                        ...(msg.isCascaded !== undefined && { isCascaded: msg.isCascaded }),
                        ...(msg.isSelected !== undefined && { isSelected: msg.isSelected }),
                        ...(msg.siblingGroupId !== undefined && { siblingGroupId: msg.siblingGroupId }),
                        ...(msg.groundingMetadata && { groundingMetadata: msg.groundingMetadata }),
                        ...(msg.attachments && msg.attachments.length > 0 && { attachments: msg.attachments }),
                        ...(msg.usageMetadata && { usageMetadata: msg.usageMetadata }),
                    }));
                    const determineTitleAndSave = (existingChatData = null) => {
                        let title;
                        if (optionalTitle !== null) {
                            title = optionalTitle;
                        } else if (existingChatData && existingChatData.title) {
                            title = existingChatData.title;
                        } else {
                            const firstUserMessage = state.currentMessages.find(m => m.role === 'user');
                            title = firstUserMessage ? firstUserMessage.content.substring(0, 50) : "無題のチャット";
                        }
                        const chatIdForOperation = existingChatData ? existingChatData.id : state.currentChatId;
                        const chatData = {
                            messages: messagesToSave, systemPrompt: state.currentSystemPrompt,
                            updatedAt: now, createdAt: existingChatData ? existingChatData.createdAt : now,
                            title: title,
                        };
                        if (state.settings.persistMessageCollapseState) {
                            chatData.collapsedStates = Object.fromEntries(state.messageCollapsedStates);
                        } else if (existingChatData && existingChatData.collapsedStates) {
                             chatData.collapsedStates = undefined;
                        }

                        if (chatIdForOperation) {
                            chatData.id = chatIdForOperation;
                        }
                        const request = store.put(chatData);
                        request.onsuccess = (event) => {
                            const savedId = event.target.result;
                            if (!state.currentChatId && savedId) {
                                state.currentChatId = savedId;
                            }
                            if ((state.currentChatId || savedId) === (chatIdForOperation || savedId)) {
                                uiUtils.updateChatTitle(chatData.title);
                            }
                            resolve(state.currentChatId || savedId);
                        };
                        request.onerror = (event) => reject(`チャット保存putエラー: ${event.target.error.name} - ${event.target.error.message}`);
                    };
                    if (state.currentChatId) {
                        const getRequest = store.get(state.currentChatId);
                        getRequest.onsuccess = (event) => {
                            const existingChat = event.target.result;
                             if (!existingChat) {
                                 state.currentChatId = null;
                                 determineTitleAndSave(null);
                            } else {
                                determineTitleAndSave(existingChat);
                            }
                        };
                        getRequest.onerror = (event) => {
                            console.error("チャット取得エラー(保存時):", event.target.error);
                            state.currentChatId = null;
                            determineTitleAndSave(null);
                        };
                    } else {
                        determineTitleAndSave(null);
                    }
                    store.transaction.onerror = (event) => reject(`チャット保存トランザクション失敗: ${event.target.error.name} - ${event.target.error.message}`);
                });
            },
            async updateChatTitleDb(id, newTitle) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE, 'readwrite');
                    const getRequest = store.get(id);
                    getRequest.onsuccess = (event) => {
                        const chatData = event.target.result;
                        if (chatData) {
                            chatData.title = newTitle;
                            chatData.updatedAt = Date.now();
                            const putRequest = store.put(chatData);
                            putRequest.onsuccess = () => resolve();
                            putRequest.onerror = (event) => reject(`タイトル更新エラー: ${event.target.error}`);
                        } else {
                            reject(`チャットが見つかりません: ${id}`);
                        }
                    };
                    getRequest.onerror = (event) => reject(`タイトル更新用チャット取得エラー: ${event.target.error}`);
                    store.transaction.onerror = (event) => reject(`タイトル更新トランザクション失敗: ${event.target.error}`);
                });
            },
            async getChat(id) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE);
                    const request = store.get(id);
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(`チャット ${id} 取得エラー: ${event.target.error}`);
                });
            },
            async getAllChats(sortBy = 'updatedAt') {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE);
                    const indexName = sortBy === 'createdAt' ? CHAT_CREATEDAT_INDEX : CHAT_UPDATEDAT_INDEX;
                    if (!store.indexNames.contains(indexName)) {
                         const getAllRequest = store.getAll();
                         getAllRequest.onsuccess = (event) => resolve(event.target.result.reverse());
                         getAllRequest.onerror = (event) => reject(`全チャット取得エラー(フォールバック): ${event.target.error}`);
                         return;
                    }
                    const index = store.index(indexName);
                    const request = index.openCursor(null, 'prev');
                    const chats = [];
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            chats.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(chats);
                        }
                    };
                    request.onerror = (event) => reject(`全チャット取得エラー (${sortBy}順): ${event.target.error}`);
                });
            },
            async deleteChat(id) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE, 'readwrite');
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`チャット ${id} 削除エラー: ${event.target.error}`);
                });
            },
            async clearAllData() {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const transaction = state.db.transaction([SETTINGS_STORE, CHATS_STORE], 'readwrite');
                    let storesCleared = 0;
                    const totalStores = 2;

                    const onComplete = () => {
                        if (++storesCleared === totalStores) {
                            resolve();
                        }
                    };
                    const onError = (storeName, event) => reject(`${storeName} クリアエラー: ${event.target.error}`);

                    const settingsStore = transaction.objectStore(SETTINGS_STORE);
                    const chatsStore = transaction.objectStore(CHATS_STORE);

                    const clearSettingsReq = settingsStore.clear();
                    const clearChatsReq = chatsStore.clear();

                    clearSettingsReq.onsuccess = onComplete;
                    clearSettingsReq.onerror = (e) => onError(SETTINGS_STORE, e);
                    clearChatsReq.onsuccess = onComplete;
                    clearChatsReq.onerror = (e) => onError(CHATS_STORE, e);
                    transaction.onerror = (event) => reject(`データクリアトランザクション失敗: ${event.target.error}`);
                });
            },
            async clearAllChatsStore() {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const transaction = state.db.transaction([CHATS_STORE], 'readwrite');
                    const chatsStore = transaction.objectStore(CHATS_STORE);
                    const clearChatsReq = chatsStore.clear();

                    clearChatsReq.onsuccess = () => resolve();
                    clearChatsReq.onerror = (e) => reject(`CHATS_STORE クリアエラー: ${e.target.error}`);
                    transaction.onerror = (event) => reject(`チャット履歴クリアトランザクション失敗: ${event.target.error}`);
                });
            }
        };

        const uiUtils = {
            renderChatMessages(maintainScroll = false) {
                const mainContent = elements.chatScreen.querySelector('.main-content');
                const oldScrollTop = maintainScroll ? mainContent.scrollTop : null;
                const oldScrollHeight = maintainScroll ? mainContent.scrollHeight : null;

                if (state.editingMessageIndex !== null) {
                    const messageElement = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                    if(messageElement) appLogic.cancelEditMessage(state.editingMessageIndex, messageElement);
                    else state.editingMessageIndex = null;
                }

                elements.messageContainer.innerHTML = '';
                let currentSiblingGroupId = null;
                let siblingsInGroup = [];
                let siblingIndex = 0;

                for (let i = 0; i < state.currentMessages.length; i++) {
                    const msg = state.currentMessages[i];
                    if (msg.role === 'model' && msg.isCascaded && msg.siblingGroupId) {
                        if (msg.siblingGroupId !== currentSiblingGroupId) {
                            currentSiblingGroupId = msg.siblingGroupId;
                            siblingsInGroup = state.currentMessages.filter(m => m.role === 'model' && m.isCascaded && m.siblingGroupId === currentSiblingGroupId);
                            siblingIndex = 0;
                        }
                        const currentIndexInGroup = siblingsInGroup.findIndex(m => m === msg);
                        if (currentIndexInGroup !== -1) {
                            siblingIndex = currentIndexInGroup + 1;
                        }

                        if (msg.isSelected) {
                            this.appendMessage(msg.role, msg.content, i, false, {
                                currentIndex: siblingIndex,
                                total: siblingsInGroup.length,
                                siblingGroupId: currentSiblingGroupId
                            }, msg.attachments);
                        }
                    } else {
                        currentSiblingGroupId = null;
                        siblingsInGroup = [];
                        this.appendMessage(msg.role, msg.content, i, false, null, msg.attachments);
                    }
                }
                if (maintainScroll && oldScrollTop !== null) {
                    requestAnimationFrame(() => {
                        const newScrollHeight = mainContent.scrollHeight;
                        mainContent.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
                    });
                }
            },
            appendMessage(role, content, index, isStreamingPlaceholder = false, cascadeInfo = null, attachments = null) {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message', role);
                messageDiv.dataset.index = index;

                if (role === 'user') {
                    if (state.settings.showUserIcon && state.userIconUrl) {
                        const iconImg = document.createElement('img');
                        iconImg.src = state.userIconUrl;
                        iconImg.alt = "User Icon";
                        iconImg.classList.add('message-icon');
                        messageDiv.appendChild(iconImg);
                    }
                    if (state.settings.showUserName && state.settings.userName) {
                        const nameSpan = document.createElement('span');
                        nameSpan.classList.add('message-icon-name');
                        if (state.settings.showUserNameBubble) {
                            nameSpan.classList.add('has-bubble');
                        }
                        nameSpan.textContent = state.settings.userName;
                        messageDiv.appendChild(nameSpan);
                    }
                } else if (role === 'model') {
                    if (state.settings.showAiIcon && state.aiIconUrl) {
                        const iconImg = document.createElement('img');
                        iconImg.src = state.aiIconUrl;
                        iconImg.alt = "AI Icon";
                        iconImg.classList.add('message-icon');
                        messageDiv.appendChild(iconImg);
                    }
                    if (state.settings.showAiName && state.settings.aiName) {
                        const nameSpan = document.createElement('span');
                        nameSpan.classList.add('message-icon-name');
                        if (state.settings.showAiNameBubble) {
                            nameSpan.classList.add('has-bubble');
                        }
                        nameSpan.textContent = state.settings.aiName;
                        messageDiv.appendChild(nameSpan);
                    }
                }

                if (state.areAllMessagesHidden && (role === 'user' || role === 'model') && !isStreamingPlaceholder) {
                    messageDiv.classList.add('message-hidden-by-toggle');
                }

                const isCurrentlyCollapsed = state.messageCollapsedStates.get(index) || false;

                if (role !== 'error' && state.settings.showCollapseButtons) {
                    const toggleButtonTop = document.createElement('button');
                    toggleButtonTop.classList.add('message-toggle-button', 'top');
                    toggleButtonTop.dataset.index = index;
                    toggleButtonTop.dataset.action = 'toggle-collapse';
                    toggleButtonTop.textContent = isCurrentlyCollapsed ? state.settings.toggleButtonTopTextExpand : state.settings.toggleButtonTopTextCollapse;
                    const topTitle = isCurrentlyCollapsed ? 'メッセージを展開' : 'メッセージを折りたたむ';
                    toggleButtonTop.title = topTitle;
                    toggleButtonTop.setAttribute('aria-label', topTitle);
                    messageDiv.appendChild(toggleButtonTop);
                }

                const contentDiv = document.createElement('div');
                contentDiv.classList.add('message-content');

                if (isCurrentlyCollapsed) {
                    contentDiv.classList.add('collapsed');
                    const toggleButtonTopElement = messageDiv.querySelector('.message-toggle-button.top');
                    if (toggleButtonTopElement) {
                        toggleButtonTopElement.textContent = state.settings.toggleButtonTopTextExpand;
                        toggleButtonTopElement.title = 'メッセージを展開';
                        toggleButtonTopElement.setAttribute('aria-label', 'メッセージを展開');
                    }
                }


                if (role === 'user' && attachments && attachments.length > 0) {
                    const details = document.createElement('details');
                    details.classList.add('attachment-details');
                    const summary = document.createElement('summary');
                    summary.textContent = `添付ファイル (${attachments.length}件)`;
                    details.appendChild(summary);
                    const list = document.createElement('ul');
                    list.classList.add('attachment-list');
                    attachments.forEach(att => {
                        const listItem = document.createElement('li');
                        listItem.textContent = att.name;
                        listItem.title = `${att.name} (${att.mimeType})`;
                        list.appendChild(listItem);
                    });
                    details.appendChild(list);
                    contentDiv.appendChild(details);
                    if (content && content.trim() !== '') {
                        const pre = document.createElement('pre');
                        pre.textContent = content;
                        pre.style.marginTop = '8px';
                        contentDiv.appendChild(pre);
                    }
                } else {
                    try {
                        if (role === 'model' && !isStreamingPlaceholder && typeof marked !== 'undefined') {
                            contentDiv.innerHTML = marked.parse(content || '');
                            this.processInteractiveTitles(contentDiv);
                            this.addCopyButtonsToCodeBlocks(contentDiv);
                        } else                             if (role === 'user') {
                            const pre = document.createElement('pre'); pre.textContent = contentthis.addCopyButtonsToCodeBlocks(contentDiv);
                        } else if (role === 'user') {
                            const pre = document.createElement('pre'); pre.textContent = content; contentDiv.appendChild(pre);
                        } else if (role === 'error') {
                             const p = document.createElement('p'); p.textContent = content; contentDiv.appendChild(p);
                        } else if (; contentDiv.appendChild(pre);
                        } else if (role === 'error') {
                             const pisStreamingPlaceholder) {
                            contentDiv.innerHTML = '';
                        } else {
                            const pre = document = document.createElement('p'); p.textContent = content; contentDiv.appendChild(p);
                        } else if (isStreamingPlaceholder) {
                            contentDiv.innerHTML = '';
                        } else {
                            const pre = document.createElement('pre'); pre.textContent = content; contentDiv.innerHTML = ''; contentDiv.appendChild(pre);.createElement('pre'); pre.textContent = content; contentDiv.innerHTML = ''; contentDiv.appendChild(pre);
                        }
                    } catch (e) {
                         console.error("Markdown parse error:", e);
                         const pre = document.createElement('pre'); pre.textContent = content; contentDiv.innerHTML = ''; contentDiv
                        }
                    } catch (e) {
                         console.error("Markdown parse error:", e);
                         const pre = document.createElement('pre'); pre.textContent = content; contentDiv.innerHTML = ''; contentDiv.appendChild(pre);
                    }
                }
                messageDiv.appendChild(contentDiv);

                const.appendChild(pre);
                    }
                }
                messageDiv.appendChild(contentDiv);

                const messageData = state.currentMessages[index];
                if (role === 'model' && messageData && messageData.ground messageData = state.currentMessages[index];
                if (role === 'model' && messageData && messageData.groundingMetadata &&
                    ( (messageData.groundingMetadata.groundingChunks && messageData.groundingMetadata.groundingingMetadata &&
                    ( (messageData.groundingMetadata.groundingChunks && messageData.groundingMetadata.groundingChunks.length > 0) ||
                      (messageData.groundingMetadata.webSearchQueries && messageDataChunks.length > 0) ||
                      (messageData.groundingMetadata.webSearchQueries && messageData.groundingMetadata.webSearchQueries.length > 0) )
                   )
                {
                    try.groundingMetadata.webSearchQueries.length > 0) )
                   )
                {
                    try {
                        const details = document.createElement('details');
                        details.classList.add('citation-details');
                        const summary = document.createElement('summary');
                        summary.textContent = '引用元/検索クエリ';
                         {
                        const details = document.createElement('details');
                        details.classList.add('citation-details');details.appendChild(summary);
                        let detailsHasContent = false;

                        if (messageData.grounding
                        const summary = document.createElement('summary');
                        summary.textContent = '引用元/検索クエリMetadata.groundingChunks && messageData.groundingMetadata.groundingChunks.length > 0) {
';
                        details.appendChild(summary);
                        let detailsHasContent = false;

                        if (messageData.groundingMetadata.groundingChunks && messageData.groundingMetadata.groundingChunks.length > 0                            const citationList = document.createElement('ul');
                            citationList.classList.add('citation-list');) {
                            const citationList = document.createElement('ul');
                            citationList.classList.add('citation

                            const citationMap = new Map();
                            let displayIndexCounter = 1;

                            if (message-list');

                            const citationMap = new Map();
                            let displayIndexCounter = 1;

                            Data.groundingMetadata.groundingSupports) {
                                messageData.groundingMetadata.groundingSupports.forEach(support => {
                                    if (support.groundingChunkIndices) {
                                        support.groundif (messageData.groundingMetadata.groundingSupports) {
                                messageData.groundingMetadata.groundingSupports.forEach(support => {
                                    if (support.groundingChunkIndices) {
                                        ingChunkIndices.forEach(chunkIndex => {
                                            if (!citationMap.has(chunkIndex) &&support.groundingChunkIndices.forEach(chunkIndex => {
                                            if (!citationMap.has(chunkIndex) && chunkIndex >= 0 && chunkIndex < messageData.groundingMetadata.groundingChunks.length) {
                                                const chunk = messageData.groundingMetadata.groundingChunks[chunkIndex];
                                                if ( chunkIndex >= 0 && chunkIndex < messageData.groundingMetadata.groundingChunks.length) {
chunk?.web?.uri) {
                                                    citationMap.set(chunkIndex, {
                                                        uri:                                                const chunk = messageData.groundingMetadata.groundingChunks[chunkIndex];
                                                if ( chunk.web.uri,
                                                        title: chunk.web.title || 'タイトル不明',
                                                        chunk?.web?.uri) {
                                                    citationMap.set(chunkIndex, {
                                                        uri:displayIndex: displayIndexCounter++
                                                    });
                                                }
                                            }
                                        });
 chunk.web.uri,
                                                        title: chunk.web.title || 'タイトル不明',
                                                                                            }
                                });
                            }

                            const sortedCitations = Array.from(citationMap.entriesdisplayIndex: displayIndexCounter++
                                                    });
                                                }
                                            }
                                        });
())
                                                        .sort(([, a], [, b]) => a.displayIndex - b.displayIndex);                                    }
                                });
                            }

                            const sortedCitations = Array.from(citationMap.entries

                            sortedCitations.forEach(([chunkIndex, citationInfo]) => {
                                const listItem = document.createElement())
                                                        .sort(([, a], [, b]) => a.displayIndex - b.displayIndex);('li');
                                const link = document.createElement('a');
                                link.href = citationInfo.uri

                            sortedCitations.forEach(([chunkIndex, citationInfo]) => {
                                const listItem = document.createElement;
                                link.textContent = `[${citationInfo.displayIndex}] ${citationInfo.title}`;
                               ('li');
                                const link = document.createElement('a');
                                link.href = citationInfo.uri link.title = citationInfo.title;
                                link.target = '_blank';
                                link.rel =;
                                link.textContent = `[${citationInfo.displayIndex}] ${citationInfo.title}`;
                                'noopener noreferrer';
                                listItem.appendChild(link);
                                citationList.appendChild(listItem);
                            }); link.title = citationInfo.title;
                                link.target = '_blank';
                                link.rel =

                            if (sortedCitations.length === 0) {
                                 messageData.groundingMetadata. 'noopener noreferrer';
                                listItem.appendChild(link);
                                citationList.appendChild(listItem);
                            });

                            if (sortedCitations.length === 0) {
                                 messageData.groundingMetadata.groundingChunks.forEach((chunk, idx) => {
                                     if (chunk?.web?.uri) {
                               groundingChunks.forEach((chunk, idx) => {
                                     if (chunk?.web?.uri) {
                                         const listItem = document.createElement('li');
                                         const link = document.createElement('a');
                                         link.href = chunk.web.uri;
                                         link.textContent = chunk.web.title ||          const listItem = document.createElement('li');
                                         const link = document.createElement('a');
                                `ソース ${idx + 1}`;
                                         link.title = chunk.web.title || 'タイトル不明';
          link.href = chunk.web.uri;
                                         link.textContent = chunk.web.title || `ソース ${idx + 1}`;
                                         link.title = chunk.web.title || 'タイトル不明';
                                         link.target = '_blank';
                                         link.rel = 'noopener noreferrer';
                                         listItem                                         link.target = '_blank';
                                         link.rel = 'noopener noreferrer';
                                         listItem.appendChild(link);
                                         citationList.appendChild(listItem);
                                     }
                                 });
                            }

                            if (citationList.hasChildNodes()) {
                                details.appendChild(citationList);
.appendChild(link);
                                         citationList.appendChild(listItem);
                                     }
                                 });
                                detailsHasContent = true;
                            }
                        }

                        if (messageData.groundingMetadata.                            }

                            if (citationList.hasChildNodes()) {
                                details.appendChild(citationList);
webSearchQueries && messageData.groundingMetadata.webSearchQueries.length > 0) {
                            if                                detailsHasContent = true;
                            }
                        }

                        if (messageData.groundingMetadata. (detailsHasContent) {
                                const separator = document.createElement('hr');
                                separator.style.marginTop = 'webSearchQueries && messageData.groundingMetadata.webSearchQueries.length > 0) {
                            if10px';
                                separator.style.marginBottom = '8px';
                                separator.style.border = (detailsHasContent) {
                                const separator = document.createElement('hr');
                                separator.style.marginTop = '10px';
                                separator.style.marginBottom = '8px';
                                separator.style.border = 'none';
                                separator.style.borderTop = '1px dashed var(--border-tertiary)'; 'none';
                                separator.style.borderTop = '1px dashed var(--border-tertiary)';
                                details.appendChild(separator);
                            }
                            const queryHeader = document.createElement('div');
                            queryHeader
                                details.appendChild(separator);
                            }
                            const queryHeader = document.createElement('div');
.textContent = '検索に使用されたクエリ:';
                            queryHeader.style.fontWeight = '500';
                            queryHeader.textContent = '検索に使用されたクエリ:';
                            queryHeader.style.fontWeight = '5                            queryHeader.style.marginTop = detailsHasContent ? '0' : '8px';
                            queryHeader00';
                            queryHeader.style.marginTop = detailsHasContent ? '0' : '8px';.style.marginBottom = '4px';
                            queryHeader.style.fontSize = '11px';

                            queryHeader.style.marginBottom = '4px';
                            queryHeader.style.fontSize = '1                            queryHeader.style.color = 'var(--text-secondary)';
                            details.appendChild(queryHeader);

                            const1px';
                            queryHeader.style.color = 'var(--text-secondary)';
                            details.appendChild queryList = document.createElement('ul');
                            queryList.classList.add('search-query-list');
                            query(queryHeader);

                            const queryList = document.createElement('ul');
                            queryList.classList.addList.style.listStyle = 'none';
                            queryList.style.paddingLeft = '0';
                            queryList.style.margin = '0';
                            queryList.style.fontSize = '11px('search-query-list');
                            queryList.style.listStyle = 'none';
                            queryList.style.paddingLeft = '0';
                            queryList.style.margin = '0';
                            queryList.';
                            queryList.style.color = 'var(--text-secondary)';
                            messageData.groundingMetadata.style.fontSize = '11px';
                            queryList.style.color = 'var(--text-secondarywebSearchQueries.forEach(query => {
                                const queryItem = document.createElement('li');
                                query)';
                            messageData.groundingMetadata.webSearchQueries.forEach(query => {
                                const queryItem = documentItem.textContent = `• ${query}`;
                                queryItem.style.marginBottom = '3px';
                               .createElement('li');
                                queryItem.textContent = `• ${query}`;
                                queryItem.style. queryList.appendChild(queryItem);
                            });
                            details.appendChild(queryList);
                            detailsHasmarginBottom = '3px';
                                queryList.appendChild(queryItem);
                            });
                            details.appendChildContent = true;
                        }

                        if (detailsHasContent) {
                            contentDiv.appendChild(details(queryList);
                            detailsHasContent = true;
                        }

                        if (detailsHasContent) {);
                        }
                    } catch (e) {
                        console.error("Error rendering grounding metadata:", e
                            contentDiv.appendChild(details);
                        }
                    } catch (e) {
                        console.);
                    }
                }


                const editArea = document.createElement('div');
                editArea.classList.adderror("Error rendering grounding metadata:", e);
                    }
                }


                const editArea = document.createElement('message-edit-area', 'hidden');
                messageDiv.appendChild(editArea);

                if (('div');
                editArea.classList.add('message-edit-area', 'hidden');
                messagerole === 'model' && cascadeInfo && cascadeInfo.total > 1) {
                    const cascadeControlsDiv = documentDiv.appendChild(editArea);

                if (role === 'model' && cascadeInfo && cascadeInfo.total > 1.createElement('div');
                    cascadeControlsDiv.classList.add('message-cascade-controls');

                    const prevButton) {
                    const cascadeControlsDiv = document.createElement('div');
                    cascadeControlsDiv.classList.add('message = document.createElement('button');
                    prevButton.textContent = '＜';
                    prevButton.title =-cascade-controls');

                    const prevButton = document.createElement('button');
                    prevButton.textContent = '＜ '前の応答';
                    prevButton.classList.add('cascade-prev-btn');
                    prevButton.';
                    prevButton.title = '前の応答';
                    prevButton.classList.add('cascade-prev-btn');disabled = cascadeInfo.currentIndex <= 1;
                    prevButton.onclick = () => appLogic.navigateCascade(index, 'prev');
                    cascadeControlsDiv.appendChild(prevButton);

                    const indicatorSpan = document.createElement('span');
                    prevButton.disabled = cascadeInfo.currentIndex <= 1;
                    prevButton.onclick = () => appLogic.navigateCascade(index, 'prev');
                    cascadeControlsDiv.appendChild(prevButton);

                    
                    indicatorSpan.classList.add('cascade-indicator');
                    indicatorSpan.textContent = `${cascadeInfo.currentIndex}/${cascadeInfo.total}`;
                    cascadeControlsDiv.appendChild(indicatorSpan);

                    const nextButton =const indicatorSpan = document.createElement('span');
                    indicatorSpan.classList.add('cascade-indicator');
                    indicatorSpan.textContent = `${cascadeInfo.currentIndex}/${cascadeInfo.total}`;
                    cascadeControlsDiv.appendChild(indicator document.createElement('button');
                    nextButton.textContent = '＞';
                    nextButton.title = 'Span);

                    const nextButton = document.createElement('button');
                    nextButton.textContent = '＞';次の応答';
                    nextButton.classList.add('cascade-next-btn');
                    nextButton.disabled
                    nextButton.title = '次の応答';
                    nextButton.classList.add('cascade-next- = cascadeInfo.currentIndex >= cascadeInfo.total;
                    nextButton.onclick = () => appLogic.navigateCascade(index, 'next');
                    cascadeControlsDiv.appendChild(nextButton);

                    const deleteCascadeButton = document.btn');
                    nextButton.disabled = cascadeInfo.currentIndex >= cascadeInfo.total;
                    nextButton.onclick = () => appLogic.navigateCascade(index, 'next');
                    cascadeControlsDiv.appendChild(nextButton);

createElement('button');
                    deleteCascadeButton.textContent = '✕';
                    deleteCascadeButton.title = 'この応答を削除';
                    deleteCascadeButton.classList.add('cascade-delete-btn');
                    delete                    const deleteCascadeButton = document.createElement('button');
                    deleteCascadeButton.textContent = '✕';
                    deleteCascadeButton.title = 'この応答を削除';
                    deleteCascadeButton.classList.add('cascadeCascadeButton.onclick = () => appLogic.confirmDeleteCascadeResponse(index);
                    cascadeControlsDiv.appendChild-delete-btn');
                    deleteCascadeButton.onclick = () => appLogic.confirmDeleteCascadeResponse(index(deleteCascadeButton);

                    messageDiv.appendChild(cascadeControlsDiv);
                }

                if (role !== 'error);
                    cascadeControlsDiv.appendChild(deleteCascadeButton);

                    messageDiv.appendChild(cascadeControlsDiv);') {
                    const actionsDiv = document.createElement('div');
                    actionsDiv.classList.add('message
                }

                if (role !== 'error') {
                    const actionsDiv = document.createElement('div');
                    -actions');

                    if (state.settings.showCollapseButtons) {
                        const toggleButtonBottom = documentactionsDiv.classList.add('message-actions');

                    if (state.settings.showCollapseButtons) {.createElement('button');
                        toggleButtonBottom.classList.add('message-toggle-button', 'bottom');
                        toggleButtonBottom.dataset.index = index;
                        toggleButtonBottom.dataset.action = 'toggle
                        const toggleButtonBottom = document.createElement('button');
                        toggleButtonBottom.classList.add('message-collapse';
                        toggleButtonBottom.textContent = isCurrentlyCollapsed ? state.settings.toggleButtonBottomTextExpand-toggle-button', 'bottom');
                        toggleButtonBottom.dataset.index = index;
                        toggleButtonBottom.dataset : state.settings.toggleButtonBottomTextCollapse;
                        const bottomTitle = isCurrentlyCollapsed ? 'メッセージを展開.action = 'toggle-collapse';
                        toggleButtonBottom.textContent = isCurrentlyCollapsed ? state.settings.toggleButtonBottomTextExpand : state.settings.toggleButtonBottomTextCollapse;
                        const bottomTitle = isCurrentlyCollapsed ? '' : 'メッセージを折りたたむ';
                        toggleButtonBottom.title = bottomTitle;
                        toggleButtonメッセージを展開' : 'メッセージを折りたたむ';
                        toggleButtonBottom.title = bottomTitle;
                        toggleButtonBottom.setAttribute('aria-label', bottomTitle);
                        if (actionsDiv.firstChild) {
                            actionsDiv.insertBefore(toggleButtonBottom, actionsDiv.firstChild);
                        } else {
                            actionsDiv.appendChildBottom.setAttribute('aria-label', bottomTitle);
                        if (actionsDiv.firstChild) {
                            actionsDiv.insertBefore(toggleButtonBottom, actionsDiv.firstChild);
                        } else {
                            actionsDiv.appendChild(toggleButtonBottom);
                        }
                    }

                    const editButton = document.createElement('button');
                    editButton.textContent = '編集'; editButton.title = 'メッセージを編集'; editButton.classList.(toggleButtonBottom);
                        }
                    }

                    const editButton = document.createElement('button');
                    editButtonadd('js-edit-btn');
                    editButton.onclick = () => appLogic.startEditMessage(.textContent = '編集'; editButton.title = 'メッセージを編集'; editButton.classList.add('jsindex, messageDiv);
                    actionsDiv.appendChild(editButton);

                    const deleteButton = document.createElement-edit-btn');
                    editButton.onclick = () => appLogic.startEditMessage(index, message('button');
                    deleteButton.textContent = '削除'; deleteButton.title = 'この会話ターンを削除'; deleteDiv);
                    actionsDiv.appendChild(editButton);

                    const deleteButton = document.createElement('button');Button.classList.add('js-delete-btn');
                    deleteButton.onclick = () => appLogic.
                    deleteButton.textContent = '削除'; deleteButton.title = 'この会話ターンを削除'; deleteButton.classListdeleteMessage(index);
                    actionsDiv.appendChild(deleteButton);

                    const copyButton = document.createElement.add('js-delete-btn');
                    deleteButton.onclick = () => appLogic.deleteMessage(('button');
                    copyButton.textContent = 'コピー';
                    copyButton.title = 'テキストをコピーindex);
                    actionsDiv.appendChild(deleteButton);

                    const copyButton = document.createElement('button');';
                    copyButton.classList.add('js-copy-btn');
                    copyButton.onclick = (
                    copyButton.textContent = 'コピー';
                    copyButton.title = 'テキストをコピー';
                    copyButton.event) => {
                        event.stopPropagation();
                        appLogic.copyMessageText(index, copyButton);classList.add('js-copy-btn');
                    copyButton.onclick = (event) => {
                        
                    };
                    actionsDiv.appendChild(copyButton);

                    if (role === 'user' || role === 'event.stopPropagation();
                        appLogic.copyMessageText(index, copyButton);
                    };
                    actionsmodel') {
                        const retryButton = document.createElement('button');
                        retryButton.textContent = 'リDiv.appendChild(copyButton);

                    if (role === 'user' || role === 'model') {
トライ';
                        retryButton.title = 'このメッセージから再生成';
                        retryButton.classList.add('js-                        const retryButton = document.createElement('button');
                        retryButton.textContent = 'リトライ';
                        retry-btn');
                        retryButton.onclick = () => {
                            const userIndexForRetry = (role === 'modelretryButton.title = 'このメッセージから再生成';
                        retryButton.classList.add('js-retry-btn');' && index > 0) ? appLogic.findPreviousUserIndex(index) : index;
                            if
                        retryButton.onclick = () => {
                            const userIndexForRetry = (role === 'model' && index >(userIndexForRetry !== -1) appLogic.retryFromMessage(userIndexForRetry);
                        };
                         0) ? appLogic.findPreviousUserIndex(index) : index;
                            if(userIndexForRetry !==actionsDiv.appendChild(retryButton);
                    }

                    if (role === 'model' && messageData?. -1) appLogic.retryFromMessage(userIndexForRetry);
                        };
                        actionsDiv.appendChildusageMetadata &&
                        typeof messageData.usageMetadata.candidatesTokenCount === 'number' &&
                        typeof message(retryButton);
                    }

                    if (role === 'model' && messageData?.usageMetadata &&
                        typeof messageData.usageMetadata.candidatesTokenCount === 'number' &&
                        typeof messageData.usageMetadataData.usageMetadata.totalTokenCount === 'number')
                    {
                        const usage = messageData.usageMetadata;.totalTokenCount === 'number')
                    {
                        const usage = messageData.usageMetadata;
                        const tokenSpan
                        const tokenSpan = document.createElement('span');
                        tokenSpan.classList.add('token-count-display');

                        let finalTotalTokenCount = usage.totalTokenCount;
                        if (typeof messageData.usage = document.createElement('span');
                        tokenSpan.classList.add('token-count-display');

                        let finalMetadata.thoughtsTokenCount === 'number') {
                            finalTotalTokenCount -= messageData.usageMetadata.thoughtsTotalTokenCount = usage.totalTokenCount;
                        if (typeof messageData.usageMetadata.thoughtsTokenCountTokenCount;
                        }

                        const formattedCandidates = usage.candidatesTokenCount.toLocaleString('en-US'); === 'number') {
                            finalTotalTokenCount -= messageData.usageMetadata.thoughtsTokenCount;
                        
                        const formattedTotal = finalTotalTokenCount.toLocaleString('en-US');

                        tokenSpan.textContent = `${formattedCandidates}

                        const formattedCandidates = usage.candidatesTokenCount.toLocaleString('en-US');
                        const formattedTotal} / ${formattedTotal}`;
                        tokenSpan.title = `Candidate Tokens / Total Tokens`;
                        actionsDiv.appendChild = finalTotalTokenCount.toLocaleString('en-US');

                        tokenSpan.textContent = `${formattedCandidates} / ${formatted(tokenSpan);
                    }
                    messageDiv.appendChild(actionsDiv);
                }

                if (Total}`;
                        tokenSpan.title = `Candidate Tokens / Total Tokens`;
                        actionsDiv.appendChild(tokenSpanisStreamingPlaceholder) {
                    messageDiv.id = `streaming-message-${index}`;
                }
                );
                    }
                    messageDiv.appendChild(actionsDiv);
                }

                if (isStreamingPlaceholderelements.messageContainer.appendChild(messageDiv);
            },
            addCopyButtonsToCodeBlocks(contentDiv) {
                    messageDiv.id = `streaming-message-${index}`;
                }
                elements.messageContainer.appendChild(messageDiv);
            },
            addCopyButtonsToCodeBlocks(contentDiv) {
                ) {
                const codeBlocks = contentDiv.querySelectorAll('pre');
                codeBlocks.forEach(preElement => {
                    const codeElement = preElement.querySelector('code');
                    const textToCopy = codeElement ?const codeBlocks = contentDiv.querySelectorAll('pre');
                codeBlocks.forEach(preElement => {
                    const code codeElement.innerText : preElement.innerText;

                    if (textToCopy && textToCopy.trim() !== '') {Element = preElement.querySelector('code');
                    const textToCopy = codeElement ? codeElement.innerText :
                        const copyButton = document.createElement('button');
                        copyButton.textContent = 'コピー';
                         preElement.innerText;

                    if (textToCopy && textToCopy.trim() !== '') {
                        constcopyButton.classList.add('code-copy-button');
                        copyButton.title = 'コードをコピー copyButton = document.createElement('button');
                        copyButton.textContent = 'コピー';
                        copyButton.';
                        copyButton.onclick = (event) => {
                            event.stopPropagation();
                            navigator.clipboardclassList.add('code-copy-button');
                        copyButton.title = 'コードをコピー';
                        .writeText(textToCopy).then(() => {
                                const originalText = copyButton.textContent;
                               copyButton.onclick = (event) => {
                            event.stopPropagation();
                            navigator.clipboard.writeText(text copyButton.textContent = 'コピー完了!';
                                copyButton.disabled = true;
                                setTimeout(() => {ToCopy).then(() => {
                                const originalText = copyButton.textContent;
                                copyButton.textContent = '
                                    copyButton.textContent = originalText;
                                    copyButton.disabled = false;
                                },コピー完了!';
                                copyButton.disabled = true;
                                setTimeout(() => {
                                    copyButton.textContent = original 1500);
                            }).catch(err => {
                                console.error('Code block copy errorText;
                                    copyButton.disabled = false;
                                }, 1500);
                            }).:', err);
                                const originalText = copyButton.textContent;
                                copyButton.textContent = '失敗';
                                copyButton.disabled = true;
                                setTimeout(() => {
                                    copyButton.textContent = originalText;
catch(err => {
                                console.error('Code block copy error:', err);
                                const originalText = copyButton.textContent;
                                copyButton.textContent = '失敗';
                                copyButton.disabled = true;
                                setTimeout(() => {                                    copyButton.disabled = false;
                                }, 2000);
                            });
                        };
                        preElement.appendChild(copyButton);
                    }
                });
            },
            updateStreamingMessage
                                    copyButton.textContent = originalText;
                                    copyButton.disabled = false;
                                }, 2000);
                            });
                        };
                        preElement.appendChild(copyButton);
                    }
                (index, newChar) {
                const messageDiv = document.getElementById(`streaming-message-${index}`);
                if});
            },
            updateStreamingMessage(index, newChar) {
                const messageDiv = document.getElementById(`streaming (messageDiv && typeof marked !== 'undefined') {
                    const contentDiv = messageDiv.querySelector('.message-content');
                    if (contentDiv) {
                        try {
                            contentDiv.innerHTML = marked.parse-message-${index}`);
                if (messageDiv && typeof marked !== 'undefined') {
                    const contentDiv = messageDiv.querySelector('.message-content');
                    if (contentDiv) {
                        try {
                            (state.partialStreamContent || '');
                            this.addCopyButtonsToCodeBlocks(contentDiv);
                        } catchcontentDiv.innerHTML = marked.parse(state.partialStreamContent || '');
                            this.addCopyButtonsToCodeBlocks (e) {
                            console.error("Streaming markdown parse error:", e);
                            contentDiv.textContent =(contentDiv);
                        } catch (e) {
                            console.error("Streaming markdown parse error:", e state.partialStreamContent;
                        }
                    }
                }
                if (state.settings.autoScrollOnNewMessage) {
                    this.scrollToBottom();
                }
            },
            finalizeStreamingMessage);
                            contentDiv.textContent = state.partialStreamContent;
                        }
                    }
                }
                if (state.settings.autoScrollOnNewMessage) {
                    this.scrollToBottom();
                }(index) {
                const messageDiv = document.getElementById(`streaming-message-${index}`);
                if (messageDiv) {
                    const contentDiv = messageDiv.querySelector('.message-content');
                    const finalRawContent = state
            },
            finalizeStreamingMessage(index) {
                const messageDiv = document.getElementById(`streaming-message-${index.currentMessages[index]?.content || '';
                    if (contentDiv && typeof marked !== 'undefined') {
}`);
                if (messageDiv) {
                    const contentDiv = messageDiv.querySelector('.message-content');
                    const finalRawContent = state.currentMessages[index]?.content || '';
                    if (contentDiv && typeof                         try {
                             contentDiv.innerHTML = marked.parse(finalRawContent);
                             this.processInteractiveTitles(content marked !== 'undefined') {
                         try {
                             contentDiv.innerHTML = marked.parse(finalRawContentDiv);
                             this.addCopyButtonsToCodeBlocks(contentDiv);
                         } catch (e) {);
                             this.processInteractiveTitles(contentDiv);
                             this.addCopyButtonsToCodeBlocks(contentDiv);

                             console.error("Final markdown parse error:", e);
                             contentDiv.textContent = finalRawContent;
                                                  } catch (e) {
                             console.error("Final markdown parse error:", e);
                             contentDiv.textContent}
                    } else if (contentDiv) {
                        contentDiv.textContent = finalRawContent;
                    }
                    messageDiv.removeAttribute('id');

                    const msgData = state.currentMessages[index];
 = finalRawContent;
                         }
                    } else if (contentDiv) {
                        contentDiv.textContent = finalRaw                    if (msgData && msgData.role === 'model' && msgData.isCascaded) {
Content;
                    }
                    messageDiv.removeAttribute('id');

                    const msgData = state.currentMessages[index];
                    if (msgData && msgData.role === 'model' && msgData.isCasc                        const siblings = appLogic.getCascadedSiblings(index);
                        if (siblings.length > 1) {aded) {
                        const siblings = appLogic.getCascadedSiblings(index);
                        if (siblings.length >
                            this.renderChatMessages();
                        }
                    }
                }
                if (state.settings 1) {
                            this.renderChatMessages();
                        }
                    }
                }
                if.autoScrollOnNewMessage) {
                    this.scrollToBottom();
                }
            },
            display (state.settings.autoScrollOnNewMessage) {
                    this.scrollToBottom();
                }
            Error(message, isApiError = false) {
                const errorIndex = state.currentMessages.length;
                this.appendMessage('error', `エラー: ${message}`, errorIndex);
                elements.loadingIndicator.classList.add('},
            displayError(message, isApiError = false) {
                const errorIndex = state.currentMessages.length;
                this.appendMessage('error', `エラー: ${message}`, errorIndex);
                elementshidden');
                this.setSendingState(false);
                this.scrollToBottom();
            },
            .loadingIndicator.classList.add('hidden');
                this.setSendingState(false);
                this.scrollToBottom() {
                requestAnimationFrame(() => {
                    const mainContent = elements.chatScreen.querySelector('.main-content');
                    if (mainContent) {
                        mainContent.scrollTop = mainContent.scrollHeight;
                    scrollToBottom();
            },
            scrollToBottom() {
                requestAnimationFrame(() => {
                    const mainContent = elements}
                });
            },
            updateChatTitle(definitiveTitle = null) {
                let titleText =.chatScreen.querySelector('.main-content');
                    if (mainContent) {
                        mainContent.scrollTop '新規チャット';
                let baseTitle = '';
                let isNewChat = !state.currentChatId;

 = mainContent.scrollHeight;
                    }
                });
            },
            updateChatTitle(definitiveTitle = null                if (state.currentChatId) {
                    isNewChat = false;
                    if (definitiveTitle !== null) {
                let titleText = '新規チャット';
                let baseTitle = '';
                let isNewChat = !state.currentChatId;

                if (state.currentChatId) {
                    isNewChat =) {
                        baseTitle = definitiveTitle;
                    } else {
                        const firstUserMessage = state. false;
                    if (definitiveTitle !== null) {
                        baseTitle = definitiveTitle;
                    }currentMessages.find(m => m.role === 'user');
                        if (firstUserMessage) {
                            baseTitle = firstUserMessage.content;
                        } else if (state.currentMessages.length > 0) { else {
                        const firstUserMessage = state.currentMessages.find(m => m.role === 'user');
                        if (firstUserMessage) {
                            baseTitle = firstUserMessage.content;
                        }
                            baseTitle = "チャット履歴";
                        }
                    }

                    if(baseTitle) { else if (state.currentMessages.length > 0) {
                            baseTitle = "チャット履歴";
                        const displayBase = baseTitle.startsWith(IMPORT_PREFIX) ? baseTitle.substring(IMPORT_PREFIX
                        }
                    }

                    if(baseTitle) {
                        const displayBase = baseTitle.startsWith.length) : baseTitle;
                        const truncated = displayBase.substring(0, CHAT_TITLE_(IMPORT_PREFIX) ? baseTitle.substring(IMPORT_PREFIX.length) : baseTitle;
                        const truncated =LENGTH);
                        titleText = truncated + (displayBase.length > CHAT_TITLE_LENGTH ? '...' : '');
                        if (baseTitle.startsWith(IMPORT_PREFIX)) {
                            titleText = IMPORT_PREFIX + titleText;
                         displayBase.substring(0, CHAT_TITLE_LENGTH);
                        titleText = truncated + (displayBase.length > CHAT_TITLE_LENGTH ? '...' : '');
                        if (baseTitle.startsWith(IMPORT_PREFIX))}
                    } else if(state.currentMessages.length > 0) {
                        titleText = 'チャット履歴 {
                            titleText = IMPORT_PREFIX + titleText;
                        }
                    } else if(state.currentMessages';
                    }
                    if (titleText === '新規チャット' && state.currentMessages.length > 0) {
                        titleText = 'チャット履歴';
                    }
                }

                const display.length > 0) {
                        titleText = 'チャット履歴';
                    }
                    if (titleText === '新規チャット' && state.currentMessages.length > 0) {
                        titleTextTitle = isNewChat ? titleText : `: ${titleText}`;
                elements.chatTitle.textContent = display = 'チャット履歴';
                    }
                }

                const displayTitle = isNewChat ? titleText : `:Title;
                document.title = `GeminiPWA - ${titleText}`;
            },
            formatDate(timestamp) {
                if (!timestamp) return '';
                try {
                    return new Intl.DateTimeFormat('ja ${titleText}`;
                elements.chatTitle.textContent = displayTitle;
                document.title = `GeminiPWA - ${titleText}`;
            },
            formatDate(timestamp) {
                if (!timestamp) return '';
                -JP', { year: '2-digit', month: '2-digit', day: '2-digittry {
                    return new Intl.DateTimeFormat('ja-JP', { year: '2-digit', month', hour: '2-digit', minute: '2-digit', hour12: false }).format(new: '2-digit', day: '2-digit', hour: '2-digit', minute: '2 Date(timestamp));
                } catch (e) {
                    console.warn("Intl.DateTimeFormat error, falling back:", e);
                    const d = new Date(timestamp);
                    return `${String(d.getFullYear-digit', hour12: false }).format(new Date(timestamp));
                } catch (e) {
                    console.warn("Intl.DateTimeFormat error, falling back:", e);
                    const d = new Date(timestamp);
()).slice(-2)}/${String(d.getMonth() + 1).padStart(2, '0')}/${String(d                    return `${String(d.getFullYear()).slice(-2)}/${String(d.getMonth() + 1).padStart(2.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String, '0')}/${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(d.getMinutes()).padStart(2, '0')}`;
                }
            },
            async renderHistory(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
                }
            },List() {
                try {
                    const chats = await dbUtils.getAllChats(state.settings.historySortOrder);
                    elements.historyList.querySelectorAll('.history-item:not(.js-history-item-template)').
            async renderHistoryList() {
                try {
                    const chats = await dbUtils.getAllChats(state.settings.historySortOrder);
                    elements.historyList.querySelectorAll('.history-item:not(.js-historyforEach(item => item.remove());
                    this.updateHistoryHeaderButtonVisibility();

                    if (chats && chats.length-item-template)').forEach(item => item.remove());
                    this.updateHistoryHeaderButtonVisibility();

 > 0) {
                        elements.noHistoryMessage.classList.add('hidden');
                        const sortOrderText = state                    if (chats && chats.length > 0) {
                        elements.noHistoryMessage.classList.add.settings.historySortOrder === 'createdAt' ? '作成順' : '更新順';
                        elements.historyTitle('hidden');
                        const sortOrderText = state.settings.historySortOrder === 'createdAt' ? '作成順.textContent = `履歴一覧 (${sortOrderText})`;

                        chats.forEach(chat => {
                            const li = elements.historyItemTemplate.cloneNode(true);
                            li.classList.remove('js-history-item' : '更新順';
                        elements.historyTitle.textContent = `履歴一覧 (${sortOrderText})`;

                        chats.forEach(chat => {
                            const li = elements.historyItemTemplate.cloneNode(true);
                            -template');
                            li.dataset.chatId = chat.id;

                            const titleText = chat.titleli.classList.remove('js-history-item-template');
                            li.dataset.chatId = chat. || `履歴 ${chat.id}`;
                            const titleEl = li.querySelector('.history-item-title');
                            id;

                            const titleText = chat.title || `履歴 ${chat.id}`;
                            const titleEl =titleEl.textContent = titleText;
                            titleEl.title = titleText;

                            li.querySelector('. li.querySelector('.history-item-title');
                            titleEl.textContent = titleText;
                            titleElcreated-date').textContent = `作成: ${this.formatDate(chat.createdAt)}`;
                            li.querySelector('.updated-.title = titleText;

                            li.querySelector('.created-date').textContent = `作成: ${this.formatDate(date').textContent = `更新: ${this.formatDate(chat.updatedAt)}`;

                            li.onclick = (event)chat.createdAt)}`;
                            li.querySelector('.updated-date').textContent = `更新: ${this.formatDate => {
                                if (!event.target.closest('.history-item-actions button')) {
                                    appLogic(chat.updatedAt)}`;

                            li.onclick = (event) => {
                                if (!event.target.closest.loadChat(chat.id);
                                    this.showScreen('chat');
                                }
                            };('.history-item-actions button')) {
                                    appLogic.loadChat(chat.id);
                                    this
                            li.querySelector('.js-edit-title-btn').onclick = (e) => { e.stopPropagation.showScreen('chat');
                                }
                            };
                            li.querySelector('.js-edit-title-btn').onclick(); appLogic.editHistoryTitle(chat.id, titleEl); };
                            li.querySelector('.js-export = (e) => { e.stopPropagation(); appLogic.editHistoryTitle(chat.id, titleEl); };
-btn').onclick = (e) => { e.stopPropagation(); appLogic.exportChat(chat.id, titleText);                            li.querySelector('.js-export-btn').onclick = (e) => { e.stopPropagation(); appLogic };
                            li.querySelector('.js-duplicate-btn').onclick = (e) => { e.stopPropagation();.exportChat(chat.id, titleText); };
                            li.querySelector('.js-duplicate-btn'). appLogic.duplicateChat(chat.id); };
                            li.querySelector('.js-delete-btn').onclick = (e) => { e.stopPropagation(); appLogic.confirmDeleteChat(chat.id, titleText); };

                            elementsonclick = (e) => { e.stopPropagation(); appLogic.duplicateChat(chat.id); };
                            li.querySelector('.js-delete-btn').onclick = (e) => { e.stopPropagation(); appLogic.confirmDelete.historyList.appendChild(li);
                        });
                    } else {
                        elements.noHistoryMessage.classList.remove('hidden');
                        elements.historyTitle.textContent = '履歴一覧';
                    }
                } catch (Chat(chat.id, titleText); };

                            elements.historyList.appendChild(li);
                        });
                    } else {
                        elements.noHistoryMessage.classList.remove('hidden');
                        elements.historyerror) {
                    console.error("Error rendering history list:", error);
                    elements.noHistoryMessage.textContent =Title.textContent = '履歴一覧';
                    }
                } catch (error) {
                    console.error "履歴の読み込み中にエラーが発生しました。";
                    elements.noHistoryMessage.classList.remove('hidden');
("Error rendering history list:", error);
                    elements.noHistoryMessage.textContent = "履歴の読み込み中にエラー                    elements.historyTitle.textContent = '履歴一覧';
                }
            },
            revokeExistingObjectUrl() {
                if (state.backgroundImageUrl) {
                    try { URL.revokeObjectURL(state.backgroundImageが発生しました。";
                    elements.noHistoryMessage.classList.remove('hidden');
                    elements.historyTitle.textContent = '履歴一覧';
                }
            },
            revokeExistingObjectUrl() {
                if (state.backgroundImageUrlUrl); } catch (e) { console.warn("Error revoking object URL:", e); }
                    state.backgroundImage) {
                    try { URL.revokeObjectURL(state.backgroundImageUrl); } catch (e) { console.Url = null;
                }
            },
            revokeExistingIconUrls() {
                if (state.userIconwarn("Error revoking object URL:", e); }
                    state.backgroundImageUrl = null;
                }
Url) {
                    try { URL.revokeObjectURL(state.userIconUrl); } catch (e) {            },
            revokeExistingIconUrls() {
                if (state.userIconUrl) {
                    try { URL console.warn("Error revoking user icon URL:", e); }
                    state.userIconUrl = null;
                .revokeObjectURL(state.userIconUrl); } catch (e) { console.warn("Error revoking user icon URL}
                if (state.aiIconUrl) {
                    try { URL.revokeObjectURL(state.ai:", e); }
                    state.userIconUrl = null;
                }
                if (state.aiIconUrl); } catch (e) { console.warn("Error revoking AI icon URL:", e); }
                    state.IconUrl) {
                    try { URL.revokeObjectURL(state.aiIconUrl); } catch (e)aiIconUrl = null;
                }
            },
            updateBackgroundSettingsUI() {
                if (! { console.warn("Error revoking AI icon URL:", e); }
                    state.aiIconUrl = null;
                elements.backgroundThumbnail || !elements.deleteBackgroundBtn) return;
                if (state.backgroundImageUrl) {
                    elements.backgroundThumbnail.src = state.backgroundImageUrl;
                    elements.backgroundThumbnail.classList.remove}
            },
            updateBackgroundSettingsUI() {
                if (!elements.backgroundThumbnail || !elements.deleteBackgroundBtn) return;
                if (state.backgroundImageUrl) {
                    elements.backgroundThumbnail.src('hidden');
                    elements.deleteBackgroundBtn.classList.remove('hidden');
                } else {
                    elements.backgroundThumbnail.src = '';
                    elements.backgroundThumbnail.classList.add('hidden');
                    elements.deleteBackground = state.backgroundImageUrl;
                    elements.backgroundThumbnail.classList.remove('hidden');
                    elements.deleteBackgroundBtn.classList.remove('hidden');
                } else {
                    elements.backgroundThumbnail.src = '';Btn.classList.add('hidden');
                }
            },
            updateIconSettingsUI() {
                if (state
                    elements.backgroundThumbnail.classList.add('hidden');
                    elements.deleteBackgroundBtn.classList.add('hidden');.userIconUrl) {
                    elements.userIconThumbnail.src = state.userIconUrl;
                    
                }
            },
            updateIconSettingsUI() {
                if (state.userIconUrl)elements.userIconThumbnail.classList.remove('hidden');
                    elements.deleteUserIconBtn.classList.remove {
                    elements.userIconThumbnail.src = state.userIconUrl;
                    elements.userIconThumbnail('hidden');
                } else {
                    elements.userIconThumbnail.src = '';
                    elements.user.classList.remove('hidden');
                    elements.deleteUserIconBtn.classList.remove('hidden');
                } else {
                    elements.userIconThumbnail.src = '';
                    elements.userIconThumbnail.classList.IconThumbnail.classList.add('hidden');
                    elements.deleteUserIconBtn.classList.add('hidden');
                }

                if (state.aiIconUrl) {
                    elements.aiIconThumbnail.src = state.aiadd('hidden');
                    elements.deleteUserIconBtn.classList.add('hidden');
                }

                if (state.aiIconUrl) {
                    elements.aiIconThumbnail.src = state.aiIconUrlIconUrl;
                    elements.aiIconThumbnail.classList.remove('hidden');
                    elements.deleteAiIconBtn.classList.remove('hidden');
                } else {
                    elements.aiIconThumbnail.src = '';
                    elements;
                    elements.aiIconThumbnail.classList.remove('hidden');
                    elements.deleteAiIconBtn..aiIconThumbnail.classList.add('hidden');
                    elements.deleteAiIconBtn.classList.add('classList.remove('hidden');
                } else {
                    elements.aiIconThumbnail.src = '';
                    elements.aiIconThumbnail.classList.add('hidden');
                    elements.deleteAiIconBtn.classList.addhidden');
                }
            },
            applySidePanelSettingsToUI() {
                if (elements.('hidden');
                }
            },
            applySidePanelSettingsToUI() {
                if (elementstoggleMemoBtn) {
                    elements.toggleMemoBtn.classList.toggle('hidden', !state.settings..toggleMemoBtn) {
                    elements.toggleMemoBtn.classList.toggle('hidden', !state.settingsshowMemoButton);
                }
                document.documentElement.style.setProperty('--memo-height', state.settings.showMemoButton);
                }
                document.documentElement.style.setProperty('--memo-height', state.settings.memo.memoHeight || DEFAULT_MEMO_HEIGHT);

                if (elements.toggleClipboardStackBtn) {
                    elements.toggleClipboardStackBtn.classList.toggle('hidden', !state.settings.showClipboardStackButton);Height || DEFAULT_MEMO_HEIGHT);

                if (elements.toggleClipboardStackBtn) {
                    elements.toggle
                }
                document.documentElement.style.setProperty('--clipboard-stack-height', state.settings.clipboardClipboardStackBtn.classList.toggle('hidden', !state.settings.showClipboardStackButton);
                }
StackHeight || DEFAULT_CLIPBOARD_STACK_HEIGHT);
                document.documentElement.style.setProperty('--message-icon-size                document.documentElement.style.setProperty('--clipboard-stack-height', state.settings.clipboardStackHeight || DEFAULT_CLIPBOARD_STACK_HEIGHT);
                document.documentElement.style.setProperty('--message-icon-size', `${state.', `${state.settings.messageIconSize || DEFAULT_MESSAGE_ICON_SIZE}px`);
                document.documentElement.style.setProperty('--message-icon-offset-y', `${state.settings.messageIconOffsetY || DEFAULT_MESSAGE_settings.messageIconSize || DEFAULT_MESSAGE_ICON_SIZE}px`);
                document.documentElement.style.ICON_OFFSET_Y}px`);
                document.documentElement.style.setProperty('--icon-name-font-setProperty('--message-icon-offset-y', `${state.settings.messageIconOffsetY || DEFAULT_MESSAGE_ICONsize', `${state.settings.iconNameFontSize || DEFAULT_ICON_NAME_FONT_SIZE}px`);
_OFFSET_Y}px`);
                document.documentElement.style.setProperty('--icon-name-font-size                document.documentElement.style.setProperty('--icon-name-offset-y', `${state.settings.iconName', `${state.settings.iconNameFontSize || DEFAULT_ICON_NAME_FONT_SIZE}px`);
                document.documentElement.style.setProperty('--icon-name-offset-y', `${state.settings.iconNameOffsetYOffsetY || DEFAULT_ICON_NAME_OFFSET_Y}px`);

                let userBubbleFinalBg;
                const userBubble || DEFAULT_ICON_NAME_OFFSET_Y}px`);

                let userBubbleFinalBg;
                const userBubbleOpacity = state.settings.userNameBubbleOpacity ?? DEFAULT_USER_NAME_BUBBLE_OPACITY;

                if (state.settings.showUserNameBubble) {
                    let userRgb;
                    if (state.settings.Opacity = state.settings.userNameBubbleOpacity ?? DEFAULT_USER_NAME_BUBBLE_OPACITY;

                if (state.settings.showUserNameBubble) {
                    let userRgb;
                    if (state.settings.userNameBubbleUseThemeColor) {
                        const themeUserMsgRgbString = getComputedStyle(document.body).getPropertyValue('--current-theme-user-message-rgb').trim();
                        const parts = themeUserMsgRgbuserNameBubbleUseThemeColor) {
                        const themeUserMsgRgbString = getComputedStyle(document.body).getPropertyValue('--current-theme-user-message-rgb').trim();
                        const parts = themeUserMsgRgbString.split(',').map(s => parseInt(s.trim(), 10));
                        userRgb = (parts.length === 3 && !parts.some(isNaN)) ? {r: parts[0],String.split(',').map(s => parseInt(s.trim(), 10));
                        userRgb = (parts.length === 3 && !parts.some(isNaN)) ? {r: parts[0], g: parts[1], b: parts[2]} : this.hexToRgb(DEFAULT_USER_NAME_ g: parts[1], b: parts[2]} : this.hexToRgb(DEFAULT_USER_NAMEBUBBLE_COLOR) || {r:255,g:255,b:25_BUBBLE_COLOR) || {r:255,g:255,b:25};
                    } else {
                        const customUserBubbleColor = state.settings.userNameBubbleColor;
55};
                    } else {
                        const customUserBubbleColor = state.settings.userNameBubbleColor;                        if (customUserBubbleColor && /^#([0-9A-Fa-f]{3}){1,2}$/.test(customUserBubbleColor)) {
                            userRgb = this.hexToRgb(
                        if (customUserBubbleColor && /^#([0-9A-Fa-f]{3}){1,2customUserBubbleColor);
                        } else {
                            const defaultRgbString = getComputedStyle(document.}$/.test(customUserBubbleColor)) {
                            userRgb = this.hexToRgb(custombody).getPropertyValue('--default-user-name-bubble-custom-rgb').trim();
                            const parts =UserBubbleColor);
                        } else {
                            const defaultRgbString = getComputedStyle(document.body defaultRgbString.split(',').map(s => parseInt(s.trim(), 10));
                            userRgb).getPropertyValue('--default-user-name-bubble-custom-rgb').trim();
                            const parts = default = (parts.length === 3 && !parts.some(isNaN)) ? {r: parts[0],RgbString.split(',').map(s => parseInt(s.trim(), 10));
                            userRgb = (parts.length === 3 && !parts.some(isNaN)) ? {r: parts[ g: parts[1], b: parts[2]} : {r:255,g:250], g: parts[1], b: parts[2]} : {r:255,g:5,b:255};
                        }
                    }
                    userBubbleFinalBg = `rgba(${userR255,b:255};
                        }
                    }
                    userBubbleFinalBg = `gb.r}, ${userRgb.g}, ${userRgb.b}, ${userBubbleOpacity})`;
rgba(${userRgb.r}, ${userRgb.g}, ${userRgb.b}, ${userBubbleOpacity})`;                } else {
                     userBubbleFinalBg = 'transparent';
                }
                document.documentElement.style
                } else {
                     userBubbleFinalBg = 'transparent';
                }
                document.documentElement.style.setProperty('--user-name-bubble-bg', userBubbleFinalBg);

                let aiBubbleFinalBg;
                const.setProperty('--user-name-bubble-bg', userBubbleFinalBg);

                let aiBubbleFinalBg;
                const aiBubbleOpacity = state.settings.aiNameBubbleOpacity ?? DEFAULT_AI_NAME_BUBBLE_OPACITY;

                if (state.settings.showAiNameBubble) {
                    let aiRgb;
                    if aiBubbleOpacity = state.settings.aiNameBubbleOpacity ?? DEFAULT_AI_NAME_BUBBLE_OPACITY; (state.settings.aiNameBubbleUseThemeColor) {
                        const themeAiMsgRgbString = get

                if (state.settings.showAiNameBubble) {
                    let aiRgb;
                    ifComputedStyle(document.body).getPropertyValue('--current-theme-model-message-rgb').trim();
                         (state.settings.aiNameBubbleUseThemeColor) {
                        const themeAiMsgRgbString = getconst parts = themeAiMsgRgbString.split(',').map(s => parseInt(s.trim(), ComputedStyle(document.body).getPropertyValue('--current-theme-model-message-rgb').trim();
                        const parts =10));
                        aiRgb = (parts.length === 3 && !parts.some(isNaN)) themeAiMsgRgbString.split(',').map(s => parseInt(s.trim(), 10));
                        aiRgb = (parts.length === 3 && !parts.some(isNaN)) ? {r: parts[ ? {r: parts[0], g: parts[1], b: parts[2]} : this.hexToRgb(DEFAULT_AI_NAME_BUBBLE_COLOR) || {r:255,g:2550], g: parts[1], b: parts[2]} : this.hexToRgb(DEFAULT_AI_NAME,b:255};
                    } else {
                        const customAiBubbleColor = state.settings._BUBBLE_COLOR) || {r:255,g:255,b:2aiNameBubbleColor;
                        if (customAiBubbleColor && /^#([0-9A-Fa-f]{355};
                    } else {
                        const customAiBubbleColor = state.settings.aiNameBubbleColor}){1,2}$/.test(customAiBubbleColor)) {
                            aiRgb = this.hexTo;
                        if (customAiBubbleColor && /^#([0-9A-Fa-f]{3}){1,2Rgb(customAiBubbleColor);
                        } else {
                            const defaultRgbString = getComputedStyle}$/.test(customAiBubbleColor)) {
                            aiRgb = this.hexToRgb(customAiBubbleColor);
                        } else {
                            const defaultRgbString = getComputedStyle(document.body(document.body).getPropertyValue('--default-ai-name-bubble-custom-rgb').trim();
                            const parts = defaultRgbString.split(',').map(s => parseInt(s.trim(), 10).getPropertyValue('--default-ai-name-bubble-custom-rgb').trim();
                            const parts = default));
                            aiRgb = (parts.length === 3 && !parts.some(isNaN)) ? {RgbString.split(',').map(s => parseInt(s.trim(), 10));
                            air: parts[0], g: parts[1], b: parts[2]} : {r:25Rgb = (parts.length === 3 && !parts.some(isNaN)) ? {r: parts[5,g:255,b:255};
                        }
                    }
                    aiBubble0], g: parts[1], b: parts[2]} : {r:255,g:255,b:255};
                        }
                    }
                    aiBubbleFinalBg = `FinalBg = `rgba(${aiRgb.r}, ${aiRgb.g}, ${aiRgb.rgba(${aiRgb.r}, ${aiRgb.g}, ${aiRgb.b}, ${aib}, ${aiBubbleOpacity})`;
                } else {
                     aiBubbleFinalBg = 'transparent';
                }
                document.documentElement.style.setProperty('--ai-name-bubble-bg', aiBubbleFinalBg);


                if(BubbleOpacity})`;
                } else {
                     aiBubbleFinalBg = 'transparent';
                }
                document.documentElement.style.setProperty('--ai-name-bubble-bg', aiBubbleFinalBg);


                if(elements.elements.userNameBubbleToggle && elements.userNameBubbleUseThemeColorToggle && document.getElementById('user-name-bubble-custom-color-settings')) {
                    const customColorDiv = document.getElementById('user-name-bubble-custom-userNameBubbleToggle && elements.userNameBubbleUseThemeColorToggle && document.getElementById('user-name-bubble-custom-color-settings');
                    const colorInput = customColorDiv.querySelector('#user-name-bubble-color');
                    constcolor-settings')) {
                    const customColorDiv = document.getElementById('user-name-bubble-custom- colorLabel = customColorDiv.querySelector('label[for="user-name-bubble-color"]');
                    color-settings');
                    const colorInput = customColorDiv.querySelector('#user-name-bubble-color');
                    const colorLabel = customColorDiv.querySelector('label[for="user-name-bubble-color"]');
                    const shouldShowCustomColor = state.settings.showUserNameBubble && !state.settings.userNameBubbleUseThemeColor;
                    const shouldShowCustomColor = state.settings.showUserNameBubble && !state.settings.userNameBubbleUseThemeColor;
                    if (colorInput) colorInput.style.display = shouldShowCustomColor ? 'block' : 'none';
                    if (colorLabel) colorLabel.style.display = shouldShowCustomColor ? 'block' : 'if (colorInput) colorInput.style.display = shouldShowCustomColor ? 'block' : 'none';none';

                    const opacityInput = elements.userNameBubbleOpacityInput;
                    const opacityLabel = document.querySelector
                    if (colorLabel) colorLabel.style.display = shouldShowCustomColor ? 'block' : '('label[for="user-name-bubble-opacity"]');
                    if (opacityInput) opacityInput.none';

                    const opacityInput = elements.userNameBubbleOpacityInput;
                    const opacityLabel = document.querySelector('label[for="user-name-bubble-opacity"]');
                    if (opacityInput) opacityInput.style.display = state.settings.showUserNameBubble ? 'block' : 'none';
                    if (opacityLabel) opacityLabel.style.display = state.settings.showUserNameBubble ? 'block' : 'none';style.display = state.settings.showUserNameBubble ? 'block' : 'none';
                    if (opacity
                }
                if(elements.aiNameBubbleToggle && elements.aiNameBubbleUseThemeColorToggle &&Label) opacityLabel.style.display = state.settings.showUserNameBubble ? 'block' : 'none'; document.getElementById('ai-name-bubble-custom-color-settings')) {
                    const customColorDiv =
                }
                if(elements.aiNameBubbleToggle && elements.aiNameBubbleUseThemeColorToggle && document.getElementById('ai-name-bubble-custom-color-settings');
                    const colorInput = customColorDiv.querySelector document.getElementById('ai-name-bubble-custom-color-settings')) {
                    const customColorDiv =('#ai-name-bubble-color');
                    const colorLabel = customColorDiv.querySelector('label[for document.getElementById('ai-name-bubble-custom-color-settings');
                    const colorInput = customColorDiv.querySelector="ai-name-bubble-color"]');
                    const shouldShowCustomColor = state.settings.showAi('#ai-name-bubble-color');
                    const colorLabel = customColorDiv.querySelector('label[for="ai-name-bubble-color"]');
                    const shouldShowCustomColor = state.settings.showAiNameBubble && !state.settings.aiNameBubbleUseThemeColor;
                    if (colorInput) colorInput.style.display = shouldShowCustomColor ? 'block' : 'none';
                    if (colorLabel) colorLabel.style.NameBubble && !state.settings.aiNameBubbleUseThemeColor;
                    if (colorInput) colorInput.style.display = shouldShowCustomColor ? 'block' : 'none';
                    if (colorLabel) colorLabel.display = shouldShowCustomColor ? 'block' : 'none';

                    const opacityInput = elements.aiNameBubbleOpacitystyle.display = shouldShowCustomColor ? 'block' : 'none';

                    const opacityInput = elements.Input;
                    const opacityLabel = document.querySelector('label[for="ai-name-bubble-opacity"]aiNameBubbleOpacityInput;
                    const opacityLabel = document.querySelector('label[for="ai-name-');
                    if (opacityInput) opacityInput.style.display = state.settings.showAiNameBubble ?bubble-opacity"]');
                    if (opacityInput) opacityInput.style.display = state.settings.show 'block' : 'none';
                    if (opacityLabel) opacityLabel.style.display = state.settingsAiNameBubble ? 'block' : 'none';
                    if (opacityLabel) opacityLabel.style.display.showAiNameBubble ? 'block' : 'none';
                }
            },
            applyOpacitySettings() {
 = state.settings.showAiNameBubble ? 'block' : 'none';
                }
            },
            applyOpacity                document.documentElement.style.setProperty('--message-bubble-opacity', state.settings.messageBubbleOpacity);
Settings() {
                document.documentElement.style.setProperty('--message-bubble-opacity', state.settings.message                document.documentElement.style.setProperty('--header-footer-opacity', state.settings.headerFooterOpacity);
                documentBubbleOpacity);
                document.documentElement.style.setProperty('--header-footer-opacity', state.settings.headerFooterOpacity.documentElement.style.setProperty('--chat-overlay-alpha', state.settings.chatOverlayOpacity);
                document.documentElement.style.setProperty('--message-actions-bg-opacity', state.settings.messageActionsBackgroundOpacity););
                document.documentElement.style.setProperty('--chat-overlay-alpha', state.settings.chatOverlayOpacity);
                document.documentElement.style.setProperty('--message-actions-bg-opacity', state.settings.message

                let headerColor, secondaryColor, userMessageColor, modelMessageColor, overlayBaseColor;

                switch (stateActionsBackgroundOpacity);

                let headerColor, secondaryColor, userMessageColor, modelMessageColor, overlayBaseColor;

.settings.theme) {
                    case 'dark':
                        headerColor = DARK_THEME_COLOR;
                                        switch (state.settings.theme) {
                    case 'dark':
                        headerColor = DARK_THEME_secondaryColor = DARK_MODE_SECONDARY_COLOR;
                        userMessageColor = DARK_MODE_USER_MESSAGE_COLOR;
                        modelMessageColor = DARK_MODE_MODEL_MESSAGE_COLOR;
                        overlayBaseColorCOLOR;
                        secondaryColor = DARK_MODE_SECONDARY_COLOR;
                        userMessageColor = DARK_MODE_USER = DARK_MODE_PRIMARY_COLOR;
                        break;
                    case 'pastel-pink':
                        headerColor =_MESSAGE_COLOR;
                        modelMessageColor = DARK_MODE_MODEL_MESSAGE_COLOR;
                        overlayBaseColor = DARK_MODE_PRIMARY_COLOR;
                        break;
                    case 'pastel-pink':
 PASTEL_PINK_HEADER_COLOR;
                        secondaryColor = PASTEL_PINK_SECONDARY_COLOR;
                        headerColor = PASTEL_PINK_HEADER_COLOR;
                        secondaryColor = PASTEL_PINK_SECONDARY_COLOR                        userMessageColor = PASTEL_PINK_USER_MESSAGE_COLOR;
                        modelMessageColor = PASTEL_PINK_MODEL_MESSAGE_COLOR;
                        overlayBaseColor = PASTEL_PINK_PRIMARY_COLOR;;
                        userMessageColor = PASTEL_PINK_USER_MESSAGE_COLOR;
                        modelMessageColor =
                        break;
                    case 'pastel-blue':
                        headerColor = PASTEL_BLUE_HEADER_ PASTEL_PINK_MODEL_MESSAGE_COLOR;
                        overlayBaseColor = PASTEL_PINK_PRIMARY_COLOR;
                        secondaryColor = PASTEL_BLUE_SECONDARY_COLOR;
                        userMessageColor = PASTELCOLOR;
                        break;
                    case 'pastel-blue':
                        headerColor = PASTEL_BLUE__BLUE_USER_MESSAGE_COLOR;
                        modelMessageColor = PASTEL_BLUE_MODEL_MESSAGE_HEADER_COLOR;
                        secondaryColor = PASTEL_BLUE_SECONDARY_COLOR;
                        userMessageColor = PASTEL_BLUE_USER_MESSAGE_COLOR;
                        modelMessageColor = PASTEL_BLUE_MODEL_COLOR;
                        overlayBaseColor = PASTEL_BLUE_PRIMARY_COLOR;
                        break;
                    caseMESSAGE_COLOR;
                        overlayBaseColor = PASTEL_BLUE_PRIMARY_COLOR;
                        break;
 'pastel-yellow':
                        headerColor = PASTEL_YELLOW_HEADER_COLOR;
                        secondaryColor = PASTEL_YELLOW_SECONDARY_COLOR;
                        userMessageColor = PASTEL_YELLOW_USER_MESSAGE_                    case 'pastel-yellow':
                        headerColor = PASTEL_YELLOW_HEADER_COLOR;
                        secondaryCOLOR;
                        modelMessageColor = PASTEL_YELLOW_MODEL_MESSAGE_COLOR;
                        overlayBaseColorColor = PASTEL_YELLOW_SECONDARY_COLOR;
                        userMessageColor = PASTEL_YELLOW_USER_MESSAGE_COLOR;
                        modelMessageColor = PASTEL_YELLOW_MODEL_MESSAGE_COLOR;
                        overlay = PASTEL_YELLOW_PRIMARY_COLOR;
                        break;
                    case 'pastel-purple':
                        headerColor = PASTEL_PURPLE_HEADER_COLOR;
                        secondaryColor = PASTEL_PURPLE_BaseColor = PASTEL_YELLOW_PRIMARY_COLOR;
                        break;
                    case 'pastel-purple':
                        headerColor = PASTEL_PURPLE_HEADER_COLOR;
                        secondaryColor = PASTEL_PURPLE_SECONDARYSECONDARY_COLOR;
                        userMessageColor = PASTEL_PURPLE_USER_MESSAGE_COLOR;
                        modelMessageColor = PASTEL_PURPLE_MODEL_MESSAGE_COLOR;
                        overlayBaseColor = PASTEL_COLOR;
                        userMessageColor = PASTEL_PURPLE_USER_MESSAGE_COLOR;
                        model_PURPLE_PRIMARY_COLOR;
                        break;
                    case 'pastel-rainbow':
                        headerColorMessageColor = PASTEL_PURPLE_MODEL_MESSAGE_COLOR;
                        overlayBaseColor = PASTEL_ = PASTEL_RAINBOW_HEADER_COLOR;
                        secondaryColor = PASTEL_RAINBOW_SECONDARY_PURPLE_PRIMARY_COLOR;
                        break;
                    case 'pastel-rainbow':
                        headerColor =COLOR;
                        userMessageColor = PASTEL_RAINBOW_USER_MESSAGE_COLOR;
                        modelMessage PASTEL_RAINBOW_HEADER_COLOR;
                        secondaryColor = PASTEL_RAINBOW_SECONDARY_COLORColor = PASTEL_RAINBOW_MODEL_MESSAGE_COLOR;
                        overlayBaseColor = PASTEL_RAIN;
                        userMessageColor = PASTEL_RAINBOW_USER_MESSAGE_COLOR;
                        modelMessageColorBOW_PRIMARY_COLOR;
                        break;
                    case 'light':
                    default:
                        headerColor = PASTEL_RAINBOW_MODEL_MESSAGE_COLOR;
                        overlayBaseColor = PASTEL_RAINBOW = LIGHT_THEME_COLOR;
                        secondaryColor = LIGHT_MODE_SECONDARY_COLOR;
                        user_PRIMARY_COLOR;
                        break;
                    case 'light':
                    default:
                        headerColor =MessageColor = LIGHT_MODE_USER_MESSAGE_COLOR;
                        modelMessageColor = LIGHT_MODE_MODEL LIGHT_THEME_COLOR;
                        secondaryColor = LIGHT_MODE_SECONDARY_COLOR;
                        userMessageColor = LIGHT_MODE_USER_MESSAGE_COLOR;
                        modelMessageColor = LIGHT_MODE_MODEL__MESSAGE_COLOR;
                        overlayBaseColor = LIGHT_MODE_PRIMARY_COLOR;
                        break;
                }

                if (state.settings.theme !== 'pastel-rainbow') {
                    const headerRgb = thisMESSAGE_COLOR;
                        overlayBaseColor = LIGHT_MODE_PRIMARY_COLOR;
                        break;
                .hexToRgb(headerColor) || this.parseRgbCss(headerColor);
                    if (headerRgb}

                if (state.settings.theme !== 'pastel-rainbow') {
                    const headerRgb = this.hexToRgb(headerColor) || this.parseRgbCss(headerColor);
                    if) {
                        document.documentElement.style.setProperty('--bg-header-rgb', `${headerRgb.r (headerRgb) {
                        document.documentElement.style.setProperty('--bg-header-rgb', `${header}, ${headerRgb.g}, ${headerRgb.b}`);
                    }
                }

                constRgb.r}, ${headerRgb.g}, ${headerRgb.b}`);
                    }
                 secondaryBgRgb = this.hexToRgb(secondaryColor) || this.parseRgbCss(secondary}

                const secondaryBgRgb = this.hexToRgb(secondaryColor) || this.parseRColor);
                 if (secondaryBgRgb) {
                    document.documentElement.style.setProperty('--bg-gbCss(secondaryColor);
                 if (secondaryBgRgb) {
                    document.documentElement.style.secondary-rgb', `${secondaryBgRgb.r}, ${secondaryBgRgb.g}, ${secondaryBgRsetProperty('--bg-secondary-rgb', `${secondaryBgRgb.r}, ${secondaryBgRgb.g},gb.b}`);
                }
                const userMessageBgRgb = this.hexToRgb(userMessageColor) || this.parseRgbCss(userMessageColor);
                if (userMessageBgRgb) {
 ${secondaryBgRgb.b}`);
                }
                const userMessageBgRgb = this.hexToRgb(userMessageColor) || this.parseRgbCss(userMessageColor);
                if (userMessageBgR                    document.documentElement.style.setProperty('--bg-user-message-rgb', `${userMessageBgRgb.r}, ${userMessageBgRgb.g}, ${userMessageBgRgb.b}`);
                }
gb) {
                    document.documentElement.style.setProperty('--bg-user-message-rgb', `${userMessageBgRgb.r}, ${userMessageBgRgb.g}, ${userMessageBgRgb.b}`);                const modelMessageBgRgb = this.hexToRgb(modelMessageColor) || this.parseR
                }
                const modelMessageBgRgb = this.hexToRgb(modelMessageColor) ||gbCss(modelMessageColor);
                if (modelMessageBgRgb) {
                    document.documentElement. this.parseRgbCss(modelMessageColor);
                if (modelMessageBgRgb) {
                    style.setProperty('--bg-model-message-rgb', `${modelMessageBgRgb.r}, ${modelMessagedocument.documentElement.style.setProperty('--bg-model-message-rgb', `${modelMessageBgRgb.rBgRgb.g}, ${modelMessageBgRgb.b}`);
                }
                const overlayBaseRgbVal = this.hexToRgb(overlayBaseColor) || this.parseRgbCss(overlayBase}, ${modelMessageBgRgb.g}, ${modelMessageBgRgb.b}`);
                }
                const overlayBaseRgbVal = this.hexToRgb(overlayBaseColor) || this.parseRgbColor);
                if (overlayBaseRgbVal) {
                    document.documentElement.style.setProperty('--overlayCss(overlayBaseColor);
                if (overlayBaseRgbVal) {
                    document.documentElement.style-base-rgb', `${overlayBaseRgbVal.r}, ${overlayBaseRgbVal.g}, ${.setProperty('--overlay-base-rgb', `${overlayBaseRgbVal.r}, ${overlayBaseRgbValoverlayBaseRgbVal.b}`);
                }
            },
            hexToRgb(hex) {.g}, ${overlayBaseRgbVal.b}`);
                }
            },
            hexToRgb
                if (typeof hex !== 'string') return null;
                const result = /^#?([a-f\d(hex) {
                if (typeof hex !== 'string') return null;
                const result = /^#]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(?([a-f\d]{2})([a-f\d]{2})([a-f\dhex);
                return result ? {
                    r: parseInt(result[1], 16),
                    ]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[g: parseInt(result[2], 16),
                    b: parseInt(result[3], 11], 16),
                    g: parseInt(result[2], 16),
                    b:6)
                } : null;
            },
            parseRgbCss(rgbString) {
                 parseInt(result[3], 16)
                } : null;
            },
            parseRgbif (typeof rgbString !== 'string') return null;
                const match = rgbString.match(/^rgb\((\d+Css(rgbString) {
                if (typeof rgbString !== 'string') return null;
                const match),\s*(\d+),\s*(\d+)\)$/);
                if (match) {
 = rgbString.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);                    return { r: parseInt(match[1]), g: parseInt(match[2]), b: parseInt(match[3]) };
                }
                return null;
            },
            applyZoomPreventionSetting() {

                if (match) {
                    return { r: parseInt(match[1]), g: parseInt(match[2]), b: parseInt(match[3]) };
                }
                return null;
            },
                let viewportMeta = document.querySelector('meta[name="viewport"]');
                if (!viewportMeta) {
                    viewportMeta = document.createElement('meta');
                    viewportMeta.name = 'viewport';
                    document            applyZoomPreventionSetting() {
                let viewportMeta = document.querySelector('meta[name="viewport"]');
                if.head.appendChild(viewportMeta);
                }

                let content = "width=device-width, initial (!viewportMeta) {
                    viewportMeta = document.createElement('meta');
                    viewportMeta.name = '-scale=1.0";
                if (state.settings.preventZoom) {
                    content += ",viewport';
                    document.head.appendChild(viewportMeta);
                }

                let content = "width=device-width maximum-scale=1.0, user-scalable=no";
                }
                viewportMeta.content =, initial-scale=1.0";
                if (state.settings.preventZoom) {
                    content += ", maximum-scale=1.0, user-scalable=no";
                }
                viewportMeta. content;
            },
            applyTheme() {
                const theme = state.settings.theme;
                document.body.classList.remove('dark-mode', 'light-mode-forced', 'pastel-pink-content = content;
            },
            applyTheme() {
                const theme = state.settings.theme;
                document.body.classList.remove('dark-mode', 'light-mode-forced', 'pastel-mode', 'pastel-blue-mode', 'pastel-yellow-mode', 'pastel-purple-mode', 'pink-mode', 'pastel-blue-mode', 'pastel-yellow-mode', 'pastel-purple-modepastel-rainbow-mode');
                let themeColorMetaValue;
                let currentThemeUserMessageBgRgb = this.hexToRgb(LIGHT_MODE_USER_MESSAGE_COLOR) || {r:220', 'pastel-rainbow-mode');
                let themeColorMetaValue;
                let currentThemeUserMessageBgRgb = this.hexToRgb(LIGHT_MODE_USER_MESSAGE_COLOR) || {r:220,g:,g:248,b:198};
                let currentThemeModelMessageBgRgb = this.hexToRgb(LIGHT_MODE_MODEL_MESSAGE_COLOR) || {r:229248,b:198};
                let currentThemeModelMessageBgRgb = this.hex,g:229,b:234};

                switch (theme) {
                    case 'ToRgb(LIGHT_MODE_MODEL_MESSAGE_COLOR) || {r:229,g:dark':
                        document.body.classList.add('dark-mode');
                        themeColorMetaValue = DARK229,b:234};

                switch (theme) {
                    case 'dark':
                        document.body.classList.add('dark-mode');
                        themeColorMetaValue = DARK_THEME_THEME_COLOR;
                        currentThemeUserMessageBgRgb = this.hexToRgb(DARK_MODE_USER_MESSAGE_COLOR) || {r:5,g:97,b:98_COLOR;
                        currentThemeUserMessageBgRgb = this.hexToRgb(DARK_MODE_};
                        currentThemeModelMessageBgRgb = this.hexToRgb(DARK_MODE_MODEL_USER_MESSAGE_COLOR) || {r:5,g:97,b:98};
                        currentThemeModelMESSAGE_COLOR) || {r:58,g:58,b:60};
                        breakMessageBgRgb = this.hexToRgb(DARK_MODE_MODEL_MESSAGE_COLOR) || {;
                    case 'pastel-pink':
                        document.body.classList.add('pastel-pink-moder:58,g:58,b:60};
                        break;
                    case 'pastel');
                        themeColorMetaValue = PASTEL_PINK_THEME_COLOR;
                        currentThemeUserMessage-pink':
                        document.body.classList.add('pastel-pink-mode');
                        themeColorMetaBgRgb = this.hexToRgb(PASTEL_PINK_USER_MESSAGE_COLOR) ||Value = PASTEL_PINK_THEME_COLOR;
                        currentThemeUserMessageBgRgb = this. {r:255,g:221,b:238};
                        currentThemeModelhexToRgb(PASTEL_PINK_USER_MESSAGE_COLOR) || {r:255MessageBgRgb = this.hexToRgb(PASTEL_PINK_MODEL_MESSAGE_COLOR),g:221,b:238};
                        currentThemeModelMessageBgRgb = this.hexToRgb(PASTEL_PINK_MODEL_MESSAGE_COLOR) || {r:24 || {r:243,g:232,b:255};
                        break;3,g:232,b:255};
                        break;
                    case 'pastel-
                    case 'pastel-blue':
                        document.body.classList.add('pastel-blue-mode');
                        themeColorMetaValue = PASTEL_BLUE_THEME_COLOR;
                        currentThemeUserMessageBgRgb =blue':
                        document.body.classList.add('pastel-blue-mode');
                        themeColorMetaValue = PASTEL_BLUE_THEME_COLOR;
                        currentThemeUserMessageBgRgb = this.hex this.hexToRgb(PASTEL_BLUE_USER_MESSAGE_COLOR) || {r:207,g:241,b:239};
                        currentThemeModelMessageBgRgbToRgb(PASTEL_BLUE_USER_MESSAGE_COLOR) || {r:207,g:241,b:239};
                        currentThemeModelMessageBgRgb = this. = this.hexToRgb(PASTEL_BLUE_MODEL_MESSAGE_COLOR) || {r:hexToRgb(PASTEL_BLUE_MODEL_MESSAGE_COLOR) || {r:224224,g:232,b:255};
                        break;
                    case 'pastel-yellow':
                        document.body.classList.add('pastel-yellow-mode');
                        themeColor,g:232,b:255};
                        break;
                    case 'pastel-yellowMetaValue = PASTEL_YELLOW_THEME_COLOR;
                        currentThemeUserMessageBgRgb = this':
                        document.body.classList.add('pastel-yellow-mode');
                        themeColorMetaValue =.hexToRgb(PASTEL_YELLOW_USER_MESSAGE_COLOR) || {r:25 PASTEL_YELLOW_THEME_COLOR;
                        currentThemeUserMessageBgRgb = this.hexToRgb(PASTEL_YELLOW_USER_MESSAGE_COLOR) || {r:255,g5,g:245,b:186};
                        currentThemeModelMessageBgRgb = this.hexToRgb(PASTEL_YELLOW_MODEL_MESSAGE_COLOR) || {r:2:245,b:186};
                        currentThemeModelMessageBgRgb = this.hex55,g:228,b:181};
                        break;
                    case 'pastelToRgb(PASTEL_YELLOW_MODEL_MESSAGE_COLOR) || {r:255,-purple':
                        document.body.classList.add('pastel-purple-mode');
                        themeColorMetag:228,b:181};
                        break;
                    case 'pastel-purple':
                        document.body.classList.add('pastel-purple-mode');
                        themeColorMetaValue = PASTEL_PURValue = PASTEL_PURPLE_THEME_COLOR;
                        currentThemeUserMessageBgRgb = this.hexToRgb(PASTEL_PURPLE_USER_MESSAGE_COLOR) || {r:2PLE_THEME_COLOR;
                        currentThemeUserMessageBgRgb = this.hexToRgb(09,g:196,b:233};
                        currentThemeModelMessageBgRgbPASTEL_PURPLE_USER_MESSAGE_COLOR) || {r:209,g:1 = this.hexToRgb(PASTEL_PURPLE_MODEL_MESSAGE_COLOR) || {r96,b:233};
                        currentThemeModelMessageBgRgb = this.hexToRgb(PASTEL_PURPLE_MODEL_MESSAGE_COLOR) || {r:197,g:197,g:202,b:233};
                        break;
                    case:202,b:233};
                        break;
                    case 'pastel-rainbow':
 'pastel-rainbow':
                        document.body.classList.add('pastel-rainbow-mode');
                        themeColorMetaValue = PASTEL_RAINBOW_THEME_COLOR;
                        currentThemeUserMessageBgRgb                        document.body.classList.add('pastel-rainbow-mode');
                        themeColorMetaValue = PASTEL = this.hexToRgb(PASTEL_RAINBOW_USER_MESSAGE_COLOR) || {r_RAINBOW_THEME_COLOR;
                        currentThemeUserMessageBgRgb = this.hexToR:224,g:255,b:240};
                        currentThemeModelMessageBggb(PASTEL_RAINBOW_USER_MESSAGE_COLOR) || {r:224,gRgb = this.hexToRgb(PASTEL_RAINBOW_MODEL_MESSAGE_COLOR) ||:255,b:240};
                        currentThemeModelMessageBgRgb = this.hex {r:224,g:240,b:255};
                        break;
ToRgb(PASTEL_RAINBOW_MODEL_MESSAGE_COLOR) || {r:224                    case 'light':
                    default:
                        document.body.classList.add('light-mode-forced,g:240,b:255};
                        break;
                    case 'light':
                    default:
                        document.body.classList.add('light-mode-forced');
                        themeColorMeta');
                        themeColorMetaValue = LIGHT_THEME_COLOR;
                        break;
                }
                if (elements.themeColorMeta) {
                    elements.themeColorMeta.content = themeColorMetaValue;Value = LIGHT_THEME_COLOR;
                        break;
                }
                if (elements.themeColorMeta) {
                }

                document.documentElement.style.setProperty('--current-theme-user-message-rgb', `${current
                    elements.themeColorMeta.content = themeColorMetaValue;
                }

                document.documentElement.style.setProperty('--current-theme-user-message-rgb', `${currentThemeUserMessageBgRgb.rThemeUserMessageBgRgb.r}, ${currentThemeUserMessageBgRgb.g}, ${currentThemeUserMessageBgRgb.b}`);
                document.documentElement.style.setProperty('--current-theme-model-message}, ${currentThemeUserMessageBgRgb.g}, ${currentThemeUserMessageBgRgb.b}`);
-rgb', `${currentThemeModelMessageBgRgb.r}, ${currentThemeModelMessageBgRgb.g                document.documentElement.style.setProperty('--current-theme-model-message-rgb', `${currentThemeModelMessage}, ${currentThemeModelMessageBgRgb.b}`);

                this.applyOpacitySettings();
                this.applyZoomPreventionBgRgb.r}, ${currentThemeModelMessageBgRgb.g}, ${currentThemeModelMessageBgRSetting();
            },
            applySettingsToUI() {
                elements.apiKeyInput.value = state.gb.b}`);

                this.applyOpacitySettings();
                this.applyZoomPreventionSetting();
            },
            applysettings.apiKey || '';
                elements.modelNameSelect.value = state.settings.modelName || DEFAULT_SettingsToUI() {
                elements.apiKeyInput.value = state.settings.apiKey || '';
                elementsMODEL;
                elements.streamingOutputCheckbox.checked = state.settings.streamingOutput;
                elements.streaming.modelNameSelect.value = state.settings.modelName || DEFAULT_MODEL;
                elements.streamingOutputSpeedInput.value = state.settings.streamingSpeed ?? DEFAULT_STREAMING_SPEED;
                elements.systemCheckbox.checked = state.settings.streamingOutput;
                elements.streamingSpeedInput.value = state.settingsPromptDefaultTextarea.value = state.settings.systemPrompt || '';
                elements.temperatureInput.value = state..streamingSpeed ?? DEFAULT_STREAMING_SPEED;
                elements.systemPromptDefaultTextarea.value = statesettings.temperature === null ? '' : state.settings.temperature;
                elements.maxTokensInput.value =.settings.systemPrompt || '';
                elements.temperatureInput.value = state.settings.temperature === null ? '' : state.settings.temperature;
                elements.maxTokensInput.value = state.settings.maxTokens state.settings.maxTokens === null ? '' : state.settings.maxTokens;
                elements.topKInput.value = state.settings.topK === null ? '' : state.settings.topK;
                 === null ? '' : state.settings.maxTokens;
                elements.topKInput.value = state.settings.topK === null ? '' : state.settings.topK;
                elements.topPInput.elements.topPInput.value = state.settings.topP === null ? '' : state.settings.topP;
                elements.presencePenaltyInput.value = state.settings.presencePenalty === null ? '' : statevalue = state.settings.topP === null ? '' : state.settings.topP;
                elements.presencePenaltyInput.value = state.settings.presencePenalty === null ? '' : state.settings.presencePenalty;
.settings.presencePenalty;
                elements.frequencyPenaltyInput.value = state.settings.frequencyPenalty === null ? '' : state.settings.frequencyPenalty;
                elements.thinkingBudgetInput.value = state.settings.thinkingBudget ===                elements.frequencyPenaltyInput.value = state.settings.frequencyPenalty === null ? '' : state.settings.frequencyPenalty;
                elements.thinkingBudgetInput.value = state.settings.thinkingBudget === null ? '' : null ? '' : state.settings.thinkingBudget;
                elements.dummyUserInput.value = state.settings.dummyUser || '';
                elements.dummyModelInput.value = state.settings.dummyModel || '';
                elements state.settings.thinkingBudget;
                elements.dummyUserInput.value = state.settings.dummyUser || '';
.concatDummyModelCheckbox.checked = state.settings.concatDummyModel;
                elements.additionalModelsTextarea                elements.dummyModelInput.value = state.settings.dummyModel || '';
                elements.concatDummyModelCheckbox.checked = state.settings.concatDummyModel;
                elements.additionalModelsTextarea.value = state.settings.value = state.settings.additionalModels || '';
                elements.pseudoStreamingCheckbox.checked = state.settings.pseudoStreaming;
                elements.enterToSendCheckbox.checked = state.settings.enterToSend;
                elements.auto.additionalModels || '';
                elements.pseudoStreamingCheckbox.checked = state.settings.pseudoStreaming;
                ScrollOnNewMessageCheckbox.checked = state.settings.autoScrollOnNewMessage;
                elements.historySortelements.enterToSendCheckbox.checked = state.settings.enterToSend;
                elements.autoScrollOnNewMessageCheckbox.checked = state.settings.autoScrollOnNewMessage;
                elements.historySortOrderSelect.value = state.OrderSelect.value = state.settings.historySortOrder || 'updatedAt';
                if (elements.themeSelect) elementssettings.historySortOrder || 'updatedAt';
                if (elements.themeSelect) elements.themeSelect..themeSelect.value = state.settings.theme || 'light';
                elements.fontFamilyInput.value = state.settings.fontFamily || '';
                elements.messageBodyFontSizeInput.value = state.settings.value = state.settings.theme || 'light';
                elements.fontFamilyInput.value = state.settings.fontFamily || '';
                elements.messageBodyFontSizeInput.value = state.settings.messageBodyFontSize ??messageBodyFontSize ?? '';
                elements.codeBlockFontSizeInput.value = state.settings.codeBlockFontSize ?? '';
                elements.hideSystemPromptToggle.checked = state.settings.hideSystemPromptInChat;
                 '';
                elements.codeBlockFontSizeInput.value = state.settings.codeBlockFontSize ?? '';
                elementselements.enableGroundingToggle.checked = state.settings.enableGrounding;
                elements.swipeNavigationToggle.hideSystemPromptToggle.checked = state.settings.hideSystemPromptInChat;
                elements.enableGround.checked = state.settings.enableSwipeNavigation;
                elements.preventZoomToggle.checked = state.settings.preventingToggle.checked = state.settings.enableGrounding;
                elements.swipeNavigationToggle.checked = stateZoom;
                elements.showNewChatButtonToggle.checked = state.settings.showNewChatButton;
.settings.enableSwipeNavigation;
                elements.preventZoomToggle.checked = state.settings.preventZoom;
                                elements.showDeleteSessionButtonToggle.checked = state.settings.showDeleteSessionButton;
                elements.elements.showNewChatButtonToggle.checked = state.settings.showNewChatButton;
                elements.showshowCopySessionButtonToggle.checked = state.settings.showCopySessionButton;
                elements.showScrollToDeleteSessionButtonToggle.checked = state.settings.showDeleteSessionButton;
                elements.showCopySessionButtonToggle.checked = state.settings.showCopySessionButton;
                elements.showScrollToTopButtonToggle.TopButtonToggle.checked = state.settings.showScrollToTopButton;
                elements.showScrollToBottomButtonToggle.checked = state.settings.showScrollToBottomButton;
                elements.showToggleAllContentButtonchecked = state.settings.showScrollToTopButton;
                elements.showScrollToBottomButtonToggle.checkedToggle.checked = state.settings.showToggleAllContentButton;
                elements.showBulkHistoryActionsToggle. = state.settings.showScrollToBottomButton;
                elements.showToggleAllContentButtonToggle.checked =checked = state.settings.showBulkHistoryActions;
                elements.showPasteButtonInFooterToggle.checked = state.settings.showToggleAllContentButton;
                elements.showBulkHistoryActionsToggle.checked = state.settings. state.settings.showPasteButtonInFooter;
                elements.showPasteButtonInEditToggle.checked = stateshowBulkHistoryActions;
                elements.showPasteButtonInFooterToggle.checked = state.settings.showPasteButtonInFooter.settings.showPasteButtonInEdit;
                elements.messageBubbleOpacityInput.value = state.settings.;
                elements.showPasteButtonInEditToggle.checked = state.settings.showPasteButtonInEdit;messageBubbleOpacity ?? DEFAULT_MESSAGE_BUBBLE_OPACITY;
                elements.chatOverlayOpacityInput.value = state.settings.chatOverlayOpacity ?? DEFAULT_CHAT_OVERLAY_OPACITY;
                elements.
                elements.messageBubbleOpacityInput.value = state.settings.messageBubbleOpacity ?? DEFAULT_MESSAGE_BUBBLE_headerFooterOpacityInput.value = state.settings.headerFooterOpacity ?? DEFAULT_HEADER_FOOTER_OPACITYOPACITY;
                elements.chatOverlayOpacityInput.value = state.settings.chatOverlayOpacity ?? DEFAULT_CHAT_OVERLAY_OPACITY;
                elements.headerFooterOpacityInput.value = state.settings.header;
                elements.messageActionsBackgroundOpacityInput.value = state.settings.messageActionsBackgroundOpacity ?? DEFAULT_MESSAGEFooterOpacity ?? DEFAULT_HEADER_FOOTER_OPACITY;
                elements.messageActionsBackgroundOpacityInput.value = state._ACTIONS_BACKGROUND_OPACITY;

                elements.showMemoButtonToggle.checked = state.settings.showMemoButton;settings.messageActionsBackgroundOpacity ?? DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY;

                elements.showMemo
                elements.memoHeightInput.value = state.settings.memoHeight || '';
                elements.showClipboardStackButtonToggle.checked = state.settings.showClipboardStackButton;
                elements.showUserIconToggle.ButtonToggle.checked = state.settings.showMemoButton;
                elements.memoHeightInput.value = state.settings.memoHeight || '';
                elements.showClipboardStackButtonToggle.checked = state.settings.showchecked = state.settings.showUserIcon;
                elements.showUserNameToggle.checked = state.settings.ClipboardStackButton;
                elements.showUserIconToggle.checked = state.settings.showUserIcon;
                elements.showUserName;
                elements.userNameInput.value = state.settings.userName || '';
                elements.showshowUserNameToggle.checked = state.settings.showUserName;
                elements.userNameInput.value = state.AiIconToggle.checked = state.settings.showAiIcon;
                elements.showAiNameToggle.checked = statesettings.userName || '';
                elements.showAiIconToggle.checked = state.settings.showAiIcon;.settings.showAiName;
                elements.aiNameInput.value = state.settings.aiName ||
                elements.showAiNameToggle.checked = state.settings.showAiName;
                elements.ai '';
                elements.iconNameFontSizeInput.value = state.settings.iconNameFontSize ?? DEFAULT_ICON_NAME_FONTNameInput.value = state.settings.aiName || '';
                elements.iconNameFontSizeInput.value = state.settings.iconNameFontSize ?? DEFAULT_ICON_NAME_FONT_SIZE;
                elements.iconName_SIZE;
                elements.iconNameOffsetYInput.value = state.settings.iconNameOffsetY !== null ? (state.settings.iconNameOffsetY * -1) : (DEFAULT_ICON_NAME_OFFSET_Y * -1OffsetYInput.value = state.settings.iconNameOffsetY !== null ? (state.settings.iconNameOffsetY * -1);
                elements.messageIconSizeInput.value = state.settings.messageIconSize ?? DEFAULT_MESSAGE_) : (DEFAULT_ICON_NAME_OFFSET_Y * -1);
                elements.messageIconSizeInputICON_SIZE;
                elements.messageIconOffsetYInput.value = state.settings.messageIconOffsetY !== null.value = state.settings.messageIconSize ?? DEFAULT_MESSAGE_ICON_SIZE;
                elements.message ? (state.settings.messageIconOffsetY * -1) : (DEFAULT_MESSAGE_ICON_OFFSET_YIconOffsetYInput.value = state.settings.messageIconOffsetY !== null ? (state.settings.messageIconOffsetY * -1);

                elements.userNameBubbleToggle.checked = state.settings.showUserNameBubble;
                elements. * -1) : (DEFAULT_MESSAGE_ICON_OFFSET_Y * -1);

                elements.userNameuserNameBubbleUseThemeColorToggle.checked = state.settings.userNameBubbleUseThemeColor;
                elements.userNameBubbleToggle.checked = state.settings.showUserNameBubble;
                elements.userNameBubbleUseThemeColorToggle.checked =BubbleColorInput.value = state.settings.userNameBubbleColor || DEFAULT_USER_NAME_BUBBLE_ state.settings.userNameBubbleUseThemeColor;
                elements.userNameBubbleColorInput.value = state.settingsCOLOR;
                elements.userNameBubbleOpacityInput.value = state.settings.userNameBubbleOpacity ?? DEFAULT_USER.userNameBubbleColor || DEFAULT_USER_NAME_BUBBLE_COLOR;
                elements.userNameBubbleOpacity_NAME_BUBBLE_OPACITY;
                elements.aiNameBubbleToggle.checked = state.settingsInput.value = state.settings.userNameBubbleOpacity ?? DEFAULT_USER_NAME_BUBBLE_OPACITY.showAiNameBubble;
                elements.aiNameBubbleUseThemeColorToggle.checked = state.settings.;
                elements.aiNameBubbleToggle.checked = state.settings.showAiNameBubble;
                elementsaiNameBubbleUseThemeColor;
                elements.aiNameBubbleColorInput.value = state.settings.ai.aiNameBubbleUseThemeColorToggle.checked = state.settings.aiNameBubbleUseThemeColor;
                NameBubbleColor || DEFAULT_AI_NAME_BUBBLE_COLOR;
                elements.aiNameBubbleOpacityelements.aiNameBubbleColorInput.value = state.settings.aiNameBubbleColor || DEFAULT_AI_NAME_BUBBInput.value = state.settings.aiNameBubbleOpacity ?? DEFAULT_AI_NAME_BUBBLE_OPLE_COLOR;
                elements.aiNameBubbleOpacityInput.value = state.settings.aiNameBubbleOpacityACITY;

                elements.showCollapseButtonsToggle.checked = state.settings.showCollapseButtons;
                elements ?? DEFAULT_AI_NAME_BUBBLE_OPACITY;

                elements.showCollapseButtonsToggle.checked.persistMessageCollapseStateCheckbox.checked = state.settings.persistMessageCollapseState;

                elements.toggleButton = state.settings.showCollapseButtons;
                elements.persistMessageCollapseStateCheckbox.checked = state.settingsTopWidthInput.value = state.settings.toggleButtonTopWidth ?? DEFAULT_TOGGLE_BUTTON_TOP_WIDTH;.persistMessageCollapseState;

                elements.toggleButtonTopWidthInput.value = state.settings.toggleButton
                elements.toggleButtonTopHeightInput.value = state.settings.toggleButtonTopHeight ?? DEFAULT_TOGTopWidth ?? DEFAULT_TOGGLE_BUTTON_TOP_WIDTH;
                elements.toggleButtonTopHeightInput.value = stateGLE_BUTTON_TOP_HEIGHT;
                elements.toggleButtonTopFontSizeInput.value = state.settings..settings.toggleButtonTopHeight ?? DEFAULT_TOGGLE_BUTTON_TOP_HEIGHT;
                elements.toggleButtonTopFontSizetoggleButtonTopFontSize ?? DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE;
                elements.toggleButtonInput.value = state.settings.toggleButtonTopFontSize ?? DEFAULT_TOGGLE_BUTTON_TOP_FONT_TopOpacityInput.value = state.settings.toggleButtonTopOpacity ?? DEFAULT_TOGGLE_BUTTON_TOP_SIZE;
                elements.toggleButtonTopOpacityInput.value = state.settings.toggleButtonTopOpacity ?? DEFAULTOPACITY;
                elements.toggleButtonTopTextCollapseInput.value = state.settings.toggleButtonTopText_TOGGLE_BUTTON_TOP_OPACITY;
                elements.toggleButtonTopTextCollapseInput.value = state.settingsCollapse || DEFAULT_TOGGLE_BUTTON_TOP_TEXT_COLLAPSE;
                elements.toggleButtonTopTextExpandInput.toggleButtonTopTextCollapse || DEFAULT_TOGGLE_BUTTON_TOP_TEXT_COLLAPSE;
                elements.toggle.value = state.settings.toggleButtonTopTextExpand || DEFAULT_TOGGLE_BUTTON_TOP_TEXT_ButtonTopTextExpandInput.value = state.settings.toggleButtonTopTextExpand || DEFAULT_TOGGLE_BUTTON_TOPEXPAND;
                elements.toggleButtonBottomFontSizeInput.value = state.settings.toggleButtonBottomFontSize ?? DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE;
                elements.toggleButtonBottomTextCollapseInput.value = state_TEXT_EXPAND;
                elements.toggleButtonBottomFontSizeInput.value = state.settings.toggleButtonBottomFontSize ?? DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE;
                elements.toggleButtonBottomTextCollapseInput.settings.toggleButtonBottomTextCollapse || DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_COLLAPSE;.value = state.settings.toggleButtonBottomTextCollapse || DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_
                elements.toggleButtonBottomTextExpandInput.value = state.settings.toggleButtonBottomTextExpand || DEFAULTCOLLAPSE;
                elements.toggleButtonBottomTextExpandInput.value = state.settings.toggleButtonBottom_TOGGLE_BUTTON_BOTTOM_TEXT_EXPAND;

                document.documentElement.style.setProperty('--message-body-font-size', `${state.settings.messageBodyFontSize || DEFAULT_MESSAGE_BODY_FONT_TextExpand || DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_EXPAND;

                document.documentElement.style.setProperty('--message-body-font-size', `${state.settings.messageBodyFontSize || DEFAULT_MESSAGE_SIZE}px`);
                document.documentElement.style.setProperty('--code-block-font-size', `${state.settings.codeBlockFontSize || DEFAULT_CODE_BLOCK_FONT_SIZE}px`);
                document.documentElementBODY_FONT_SIZE}px`);
                document.documentElement.style.setProperty('--code-block-font-size', `${.style.setProperty('--message-toggle-button-top-width', `${state.settings.toggleButtonTopWidthstate.settings.codeBlockFontSize || DEFAULT_CODE_BLOCK_FONT_SIZE}px`);
                document. || DEFAULT_TOGGLE_BUTTON_TOP_WIDTH}px`);
                document.documentElement.style.setProperty('--documentElement.style.setProperty('--message-toggle-button-top-width', `${state.settings.toggleButtonTopmessage-toggle-button-top-height', `${state.settings.toggleButtonTopHeight || DEFAULT_TOGGLEWidth || DEFAULT_TOGGLE_BUTTON_TOP_WIDTH}px`);
                document.documentElement.style.setProperty('--message-toggle-button-top-height', `${state.settings.toggleButtonTopHeight || DEFAULT_TOG_BUTTON_TOP_HEIGHT}px`);
                document.documentElement.style.setProperty('--message-toggle-buttonGLE_BUTTON_TOP_HEIGHT}px`);
                document.documentElement.style.setProperty('--message-toggle--top-font-size', `${state.settings.toggleButtonTopFontSize || DEFAULT_TOGGLE_BUTTON_button-top-font-size', `${state.settings.toggleButtonTopFontSize || DEFAULT_TOGGLE_BUTTONTOP_FONT_SIZE}px`);
                document.documentElement.style.setProperty('--message-toggle-button-top-opacity', state.settings.toggleButtonTopOpacity);
                document.documentElement.style.setProperty('--message_TOP_FONT_SIZE}px`);
                document.documentElement.style.setProperty('--message-toggle-button-top-opacity', state.settings.toggleButtonTopOpacity);
                document.documentElement.style.setProperty('--message--toggle-button-bottom-font-size', `${state.settings.toggleButtonBottomFontSize || DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE}px`);

                this.updateChatScreenElementVisibility();
                thistoggle-button-bottom-font-size', `${state.settings.toggleButtonBottomFontSize || DEFAULT_TOGGLE_BUTTON_.updateHistoryHeaderButtonVisibility();
                this.updateUserModelOptions();
                this.updateBackgroundSettingsUI();BOTTOM_FONT_SIZE}px`);

                this.updateChatScreenElementVisibility();
                this.updateHistoryHeaderButtonVisibility
                this.updateIconSettingsUI();
                this.applyTheme();
                this.applyFontFamily();
                this();
                this.updateUserModelOptions();
                this.updateBackgroundSettingsUI();
                this.updateIcon.toggleSystemPromptVisibility();
                this.applySidePanelSettingsToUI();
            },
            updateChatSettingsUI();
                this.applyTheme();
                this.applyFontFamily();
                this.toggleSystemScreenElementVisibility() {
                if (elements.newChatBtn) {
                    elements.newChatBtn.PromptVisibility();
                this.applySidePanelSettingsToUI();
            },
            updateChatScreenElementVisibilityclassList.toggle('hidden', !state.settings.showNewChatButton);
                }
                if (elements() {
                if (elements.newChatBtn) {
                    elements.newChatBtn.classList.toggle.deleteSessionBtn) {
                    elements.deleteSessionBtn.classList.toggle('hidden', !state.settings('hidden', !state.settings.showNewChatButton);
                }
                if (elements.deleteSession.showDeleteSessionButton);
                }
                if (elements.copySessionBtn) {
                    elements.Btn) {
                    elements.deleteSessionBtn.classList.toggle('hidden', !state.settings.showDeletecopySessionBtn.classList.toggle('hidden', !state.settings.showCopySessionButton);
                }
SessionButton);
                }
                if (elements.copySessionBtn) {
                    elements.copySessionBtn                if (elements.scrollToTopBtn) {
                    elements.scrollToTopBtn.classList.toggle('hidden',.classList.toggle('hidden', !state.settings.showCopySessionButton);
                }
                if ( !state.settings.showScrollToTopButton);
                }
                if (elements.scrollToBottomBtn)elements.scrollToTopBtn) {
                    elements.scrollToTopBtn.classList.toggle('hidden', !state.settings.show {
                    elements.scrollToBottomBtn.classList.toggle('hidden', !state.settings.showScrollToBottomScrollToTopButton);
                }
                if (elements.scrollToBottomBtn) {
                    elements.scrollToButton);
                }
                if (elements.toggleAllContentBtn) {
                    elements.toggleAllContentBottomBtn.classList.toggle('hidden', !state.settings.showScrollToBottomButton);
                }
Btn.classList.toggle('hidden', !state.settings.showToggleAllContentButton);
                }
                                if (elements.toggleAllContentBtn) {
                    elements.toggleAllContentBtn.classList.toggle('hidden', !if (elements.toggleMemoBtn) {
                    elements.toggleMemoBtn.classList.toggle('hidden', !state.settings.showToggleAllContentButton);
                }
                if (elements.toggleMemoBtn) {state.settings.showMemoButton);
                }
                if (elements.toggleClipboardStackBtn) {

                    elements.toggleMemoBtn.classList.toggle('hidden', !state.settings.showMemoButton);
                    elements.toggleClipboardStackBtn.classList.toggle('hidden', !state.settings.showClipboardStackButton);                }
                if (elements.toggleClipboardStackBtn) {
                    elements.toggleClipboardStackBtn.classList
                }
                if (elements.pasteToInputBtn) {
                    elements.pasteToInputBtn.classList.toggle.toggle('hidden', !state.settings.showClipboardStackButton);
                }
                if (elements.('hidden', !state.settings.showPasteButtonInFooter);
                }
            },
            updateHistorypasteToInputBtn) {
                    elements.pasteToInputBtn.classList.toggle('hidden', !state.HeaderButtonVisibility() {
                const showBulkActions = state.settings.showBulkHistoryActions;
                if (elementssettings.showPasteButtonInFooter);
                }
            },
            updateHistoryHeaderButtonVisibility() {
.exportAllSessionsBtn) {
                    elements.exportAllSessionsBtn.classList.toggle('hidden', !showBulkActions                const showBulkActions = state.settings.showBulkHistoryActions;
                if (elements.exportAllSessionsBtn));
                }
                if (elements.importAllSessionsBtn) {
                    elements.importAllSessionsBtn {
                    elements.exportAllSessionsBtn.classList.toggle('hidden', !showBulkActions);
                }.classList.toggle('hidden', !showBulkActions);
                }
            },
            updateUserModelOptions() {

                if (elements.importAllSessionsBtn) {
                    elements.importAllSessionsBtn.classList.toggle                const group = elements.userDefinedModelsGroup;
                group.innerHTML = '';
                const models = (state.('hidden', !showBulkActions);
                }
            },
            updateUserModelOptions() {
                const group =settings.additionalModels || '')
                    .split(',')
                    .map(m => m.trim())
                     elements.userDefinedModelsGroup;
                group.innerHTML = '';
                const models = (state.settings.additionalModels.filter(m => m !== '');

                if (models.length > 0) {
                    group. || '')
                    .split(',')
                    .map(m => m.trim())
                    .filter(m => m !== '');

                if (models.length > 0) {
                    group.disabled = false;disabled = false;
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        group.appendChild(option);
                    
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        group.appendChild(option);
                    });
                    if});
                    if (models.includes(state.settings.modelName)) {
                        elements.modelNameSelect.value = (models.includes(state.settings.modelName)) {
                        elements.modelNameSelect.value = state state.settings.modelName;
                    }
                } else {
                    group.disabled = true;
                }
            },
            applyFontFamily() {
                const customFont = state.settings.fontFamily.settings.modelName;
                    }
                } else {
                    group.disabled = true;
                ?.trim();
                const fontFamilyToApply = customFont ? customFont : DEFAULT_FONT_FAMILY;
                }
            },
            applyFontFamily() {
                const customFont = state.settings.fontFamily?.document.documentElement.style.setProperty('--font-family', fontFamilyToApply);
                document.documentElement.style.trim();
                const fontFamilyToApply = customFont ? customFont : DEFAULT_FONT_FAMILY;
                document.documentElement.setProperty('--message-body-font-size', `${state.settings.messageBodyFontSize || DEFAULT_MESSAGE_BODYstyle.setProperty('--font-family', fontFamilyToApply);
                document.documentElement.style.setProperty('--message-_FONT_SIZE}px`);
                document.documentElement.style.setProperty('--code-block-font-sizebody-font-size', `${state.settings.messageBodyFontSize || DEFAULT_MESSAGE_BODY_FONT_SIZE', `${state.settings.codeBlockFontSize || DEFAULT_CODE_BLOCK_FONT_SIZE}px`);
            }px`);
                document.documentElement.style.setProperty('--code-block-font-size', `${state.settings.},
            updateSystemPromptUI() {
                elements.systemPromptEditor.value = state.currentSystemPrompt;codeBlockFontSize || DEFAULT_CODE_BLOCK_FONT_SIZE}px`);
            },
            updateSystemPromptUI() {
                if (!state.isEditingSystemPrompt) {
                    elements.systemPromptDetails.removeAttribute('open');
                }
                elements.systemPromptEditor.value = state.currentSystemPrompt;
                if (!state.isEditing
                this.adjustTextareaHeight(elements.systemPromptEditor, 200);
                this.toggleSystemPromptSystemPrompt) {
                    elements.systemPromptDetails.removeAttribute('open');
                }
                this.adjustTextareaHeight(elements.systemPromptEditor, 200);
                this.toggleSystemPromptVisibility();Visibility();
            },
            toggleSystemPromptVisibility() {
                const shouldHide = state.settings.hideSystemPromptInChat;
                elements.systemPromptArea.classList.toggle('hidden', shouldHide);
            
            },
            toggleSystemPromptVisibility() {
                const shouldHide = state.settings.hideSystemPromptInChat;
                elements.systemPromptArea.classList.toggle('hidden', shouldHide);
            },
},
            showScreen(screenName, fromPopState = false) {
                if (state.editingMessage            showScreen(screenName, fromPopState = false) {
                if (state.editingMessageIndex !==Index !== null) {
                     const messageElement = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                     if (messageElement) {
                        appLogic.cancelEditMessage(state null) {
                     const messageElement = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                     if (messageElement) {
                        appLogic.cancelEditMessage(state.editingMessageIndex.editingMessageIndex, messageElement);
                     } else {
                        state.editingMessageIndex = null;
                     }
                }
                if (state.isEditingSystemPrompt) {
                    appLogic.cancelEditSystemPrompt();, messageElement);
                     } else {
                        state.editingMessageIndex = null;
                     }
                }
                if (state.isEditingSystemPrompt) {
                    appLogic.cancelEditSystemPrompt();
                }

                }
                if (state.isMemoVisible && screenName !== 'chat') {
                     elements.memoArea.classList.add('hidden');
                     state.isMemoVisible = false;
                }
                if                if (state.isMemoVisible && screenName !== 'chat') {
                     elements.memoArea.classList. (state.isClipboardStackVisible && screenName !== 'chat') {
                     elements.clipboardStackArea.classListadd('hidden');
                     state.isMemoVisible = false;
                }
                if (state.is.add('hidden');
                     state.isClipboardStackVisible = false;
                }

                if (screenName === stateClipboardStackVisible && screenName !== 'chat') {
                     elements.clipboardStackArea.classList.add('hidden.currentScreen) {
                    if (screenName === 'history') this.updateHistoryHeaderButtonVisibility();
');
                     state.isClipboardStackVisible = false;
                }

                if (screenName === state.currentScreen)                    return;
                }

                const allScreens = [elements.chatScreen, elements.historyScreen, elements {
                    if (screenName === 'history') this.updateHistoryHeaderButtonVisibility();
                    return;
.settingsScreen];
                let activeScreen = null;

                if (!fromPopState) {
                    if (screenName                }

                const allScreens = [elements.chatScreen, elements.historyScreen, elements.settingsScreen]; === 'history' || screenName === 'settings') {
                        history.pushState({ screen: screenName },
                let activeScreen = null;

                if (!fromPopState) {
                    if (screenName === 'history' '', `#${screenName}`);
                    } else if (screenName === 'chat') {
                        history.replaceState({ screen || screenName === 'settings') {
                        history.pushState({ screen: screenName }, '', `#${screenName}`);: 'chat' }, '', '#chat');
                    }
                }


                allScreens.forEach(screen => {

                    } else if (screenName === 'chat') {
                        history.replaceState({ screen: 'chat                    screen.classList.remove('active');
                    screen.inert = true;
                });

                if (' }, '', '#chat');
                    }
                }


                allScreens.forEach(screen => {
                    screen.classListscreenName === 'chat') {
                    activeScreen = elements.chatScreen;
                    elements.chatScreen..remove('active');
                    screen.inert = true;
                });

                if (screenName === 'style.transform = 'translateX(0)';
                    elements.historyScreen.style.transform = 'translateX(-1chat') {
                    activeScreen = elements.chatScreen;
                    elements.chatScreen.style.transform =00%)';
                    elements.settingsScreen.style.transform = 'translateX(100%)';
 'translateX(0)';
                    elements.historyScreen.style.transform = 'translateX(-100%)';                    requestAnimationFrame(() => {
                        this.updateSystemPromptUI();
                        this.adjustTextareaHeight();
                    elements.settingsScreen.style.transform = 'translateX(100%)';
                    requestAnimationFrame(()
                        this.updateChatScreenElementVisibility();
                    });
                } else if (screenName === 'history') {
 => {
                        this.updateSystemPromptUI();
                        this.adjustTextareaHeight();
                        this.updateChatScreen                    activeScreen = elements.historyScreen;
                    elements.chatScreen.style.transform = 'translateX(1ElementVisibility();
                    });
                } else if (screenName === 'history') {
                    activeScreen =00%)';
                    elements.historyScreen.style.transform = 'translateX(0)';
                    elements. elements.historyScreen;
                    elements.chatScreen.style.transform = 'translateX(100%)';settingsScreen.style.transform = 'translateX(200%)';
                    this.renderHistoryList();

                    elements.historyScreen.style.transform = 'translateX(0)';
                    elements.settingsScreen.style                } else if (screenName === 'settings') {
                    activeScreen = elements.settingsScreen;
                    .transform = 'translateX(200%)';
                    this.renderHistoryList();
                } else ifelements.chatScreen.style.transform = 'translateX(-100%)';
                    elements.historyScreen. (screenName === 'settings') {
                    activeScreen = elements.settingsScreen;
                    elements.chatScreenstyle.transform = 'translateX(-200%)';
                    elements.settingsScreen.style.transform = '.style.transform = 'translateX(-100%)';
                    elements.historyScreen.style.transform = 'translateX(-translateX(0)';
                    this.applySettingsToUI();
                }

                requestAnimationFrame(() => {
                    allScreens200%)';
                    elements.settingsScreen.style.transform = 'translateX(0)';
                    this.applySettings.forEach(screen => {
                        screen.style.transition = 'transform 0.3s ease-inToUI();
                }

                requestAnimationFrame(() => {
                    allScreens.forEach(screen => {
-out';
                    });
                    if (activeScreen) {
                        activeScreen.inert = false;
                        activeScreen                        screen.style.transition = 'transform 0.3s ease-in-out';
                    });
.classList.add('active');
                    }
                });
                state.currentScreen = screenName;
                    if (activeScreen) {
                        activeScreen.inert = false;
                        activeScreen.classList.add            },
            setSendingState(sending) {
                state.isSending = sending;
                if (('active');
                    }
                });
                state.currentScreen = screenName;
            },
            sending) {
                    elements.sendButton.textContent = '止';
                    elements.sendButton.classList.setSendingState(sending) {
                state.isSending = sending;
                if (sending) {
                    elements.sendButton.textContent = '止';
                    elements.sendButton.classList.add('sending');add('sending');
                    elements.sendButton.title = "停止";
                    elements.sendButton.disabled = false;
                    elements.userInput.disabled = true;
                    elements.attachFileBtn.disabled = true;

                    elements.sendButton.title = "停止";
                    elements.sendButton.disabled = false;
                    elements                    elements.pasteToInputBtn.disabled = true;
                    elements.loadingIndicator.classList.remove('hidden.userInput.disabled = true;
                    elements.attachFileBtn.disabled = true;
                    elements.paste');
                    elements.loadingIndicator.setAttribute('aria-live', 'polite');
                    elements.systemPromptToInputBtn.disabled = true;
                    elements.loadingIndicator.classList.remove('hidden');
                    elementsDetails.style.pointerEvents = 'none';
                    elements.systemPromptDetails.style.opacity = '0.loadingIndicator.setAttribute('aria-live', 'polite');
                    elements.systemPromptDetails.style..7';
                } else {
                    elements.sendButton.textContent = '送';
                    elements.pointerEvents = 'none';
                    elements.systemPromptDetails.style.opacity = '0.7';
sendButton.classList.remove('sending');
                    elements.sendButton.title = "送信";
                    elements.sendButton                } else {
                    elements.sendButton.textContent = '送';
                    elements.sendButton.classList.remove('.disabled = elements.userInput.value.trim() === '' && state.pendingAttachments.length === 0;sending');
                    elements.sendButton.title = "送信";
                    elements.sendButton.disabled = elements
                    elements.userInput.disabled = false;
                    elements.attachFileBtn.disabled = false;
                    elements.paste.userInput.value.trim() === '' && state.pendingAttachments.length === 0;
                    elements.userInput.disabled = false;
                    elements.attachFileBtn.disabled = false;
                    elements.pasteToInputBtn.ToInputBtn.disabled = false;
                    elements.loadingIndicator.classList.add('hidden');
                    elements.loadingIndicator.removeAttribute('aria-live');
                    elements.systemPromptDetails.style.pointerEvents = '';disabled = false;
                    elements.loadingIndicator.classList.add('hidden');
                    elements.loadingIndicator.
                    elements.systemPromptDetails.style.opacity = '';
                }
            },
            adjustTextarearemoveAttribute('aria-live');
                    elements.systemPromptDetails.style.pointerEvents = '';
                    elements.Height(textarea = elements.userInput, maxHeight = TEXTAREA_MAX_HEIGHT) {
                if (!textarea) return;
systemPromptDetails.style.opacity = '';
                }
            },
            adjustTextareaHeight(textarea =                textarea.style.height = 'auto';
                const scrollHeight = textarea.scrollHeight;
                textarea.style.height elements.userInput, maxHeight = TEXTAREA_MAX_HEIGHT) {
                if (!textarea) return;
                textarea.style.height = 'auto';
                const scrollHeight = textarea.scrollHeight;
                textarea.style.height = = Math.min(scrollHeight, maxHeight) + 'px';

                if (textarea === elements.userInput && !state.isSending) {
                    elements.sendButton.disabled = textarea.value.trim() === '' && state.pendingAttachments Math.min(scrollHeight, maxHeight) + 'px';

                if (textarea === elements.userInput && !state.length === 0;
                }
            },
            showCustomDialog(dialogElement, focusElement) {
.isSending) {
                    elements.sendButton.disabled = textarea.value.trim() === '' && state.pendingAttachments                return new Promise((resolve) => {
                    const closeListener = () => {
                        dialogElement.removeEventListener.length === 0;
                }
            },
            showCustomDialog(dialogElement, focusElement) {
('close', closeListener);
                        resolve(dialogElement.returnValue);
                    };
                    dialogElement.addEventListener('close',                return new Promise((resolve) => {
                    const closeListener = () => {
                        dialogElement.removeEventListener('close', closeListener);
                        resolve(dialogElement.returnValue);
                    };
                    dialogElement.addEventListener closeListener);
                    dialogElement.showModal();
                    if (focusElement) {
                        requestAnimationFrame(()('close', closeListener);
                    dialogElement.showModal();
                    if (focusElement) {
                         => { focusElement.focus(); });
                    }
                });
            },
            async showCustomAlert(messagerequestAnimationFrame(() => { focusElement.focus(); });
                    }
                });
            },
            async show) {
                elements.alertMessage.textContent = message;
                 const newOkBtn = elements.alertOkBtn.cloneCustomAlert(message) {
                elements.alertMessage.textContent = message;
                 const newOkBtn = elements.alertNode(true);
                 elements.alertOkBtn.parentNode.replaceChild(newOkBtn, elements.alertOkBtnOkBtn.cloneNode(true);
                 elements.alertOkBtn.parentNode.replaceChild(newOkBtn, elements);
                 elements.alertOkBtn = newOkBtn;

                elements.alertOkBtn.onclick = () => elements.alertDialog.close('ok');
                await this.showCustomDialog(elements.alertDialog, elements..alertOkBtn);
                 elements.alertOkBtn = newOkBtn;

                elements.alertOkBtn.onclick = () => elements.alertDialog.close('ok');
                await this.showCustomDialog(elements.alertOkBtn);
            },
            async showCustomConfirm(message) {
                elements.confirmMessage.textContent = messagealertDialog, elements.alertOkBtn);
            },
            async showCustomConfirm(message) {
                elements;
                 const newOkBtn = elements.confirmOkBtn.cloneNode(true);
                 elements.confirmOkBtn..confirmMessage.textContent = message;
                 const newOkBtn = elements.confirmOkBtn.cloneNode(true);parentNode.replaceChild(newOkBtn, elements.confirmOkBtn);
                 elements.confirmOkBtn = new
                 elements.confirmOkBtn.parentNode.replaceChild(newOkBtn, elements.confirmOkBtn);
OkBtn;
                 const newCancelBtn = elements.confirmCancelBtn.cloneNode(true);
                 elements                 elements.confirmOkBtn = newOkBtn;
                 const newCancelBtn = elements.confirmCancelBtn..confirmCancelBtn.parentNode.replaceChild(newCancelBtn, elements.confirmCancelBtn);
                 elements.cloneNode(true);
                 elements.confirmCancelBtn.parentNode.replaceChild(newCancelBtn, elements.confirmCancelBtn = newCancelBtn;

                elements.confirmOkBtn.onclick = () => elements.confirmDialog.close('confirmCancelBtn);
                 elements.confirmCancelBtn = newCancelBtn;

                elements.confirmOkBtn.onclick = () => elements.confirmDialog.close('ok');
                elements.confirmCancelBtn.onclick = () => elements.ok');
                elements.confirmCancelBtn.onclick = () => elements.confirmDialog.close('cancel');
                const result = await this.showCustomDialog(elements.confirmDialog, elements.confirmOkBtn);
                return result === 'ok';
            },
            async showCustomPrompt(message, defaultValue = '') {
                elements.promptconfirmDialog.close('cancel');
                const result = await this.showCustomDialog(elements.confirmDialog, elements.confirmOkBtn);
                return result === 'ok';
            },
            async showCustomPrompt(messageMessage.textContent = message;
                elements.promptInput.value = defaultValue;
                 const newOkBtn = elements.prompt, defaultValue = '') {
                elements.promptMessage.textContent = message;
                elements.promptInput.valueOkBtn.cloneNode(true);
                 elements.promptOkBtn.parentNode.replaceChild(newOkBtn = defaultValue;
                 const newOkBtn = elements.promptOkBtn.cloneNode(true);
                 elements, elements.promptOkBtn);
                 elements.promptOkBtn = newOkBtn;
                 const newCancel.promptOkBtn.parentNode.replaceChild(newOkBtn, elements.promptOkBtn);
                 elements.Btn = elements.promptCancelBtn.cloneNode(true);
                 elements.promptCancelBtn.parentNode.replacepromptOkBtn = newOkBtn;
                 const newCancelBtn = elements.promptCancelBtn.cloneNode(Child(newCancelBtn, elements.promptCancelBtn);
                 elements.promptCancelBtn = newCancelBtn;true);
                 elements.promptCancelBtn.parentNode.replaceChild(newCancelBtn, elements.promptCancelBtn
                 const newPromptInput = elements.promptInput.cloneNode(true);
                 elements.promptInput.parentNode.replaceChild(newPromptInput, elements.promptInput);
                 elements.promptInput = newPromptInput);
                 elements.promptCancelBtn = newCancelBtn;
                 const newPromptInput = elements.promptInput.cloneNode(true);
                 elements.promptInput.parentNode.replaceChild(newPromptInput, elements.promptInput;


                const enterHandler = (event) => {
                    if (event.key === 'Enter') {
);
                 elements.promptInput = newPromptInput;


                const enterHandler = (event) => {
                        event.preventDefault();
                        elements.promptOkBtn.click();
                    }
                };
                elements                    if (event.key === 'Enter') {
                        event.preventDefault();
                        elements.promptOkBtn.promptInput.addEventListener('keypress', enterHandler);

                elements.promptOkBtn.onclick = () => elements.click();
                    }
                };
                elements.promptInput.addEventListener('keypress', enterHandler);

.promptDialog.close(elements.promptInput.value);
                elements.promptCancelBtn.onclick = ()                elements.promptOkBtn.onclick = () => elements.promptDialog.close(elements.promptInput.value => elements.promptDialog.close('');

                const closeHandler = () => {
                    elements.promptInput.removeEventListener(');
                elements.promptCancelBtn.onclick = () => elements.promptDialog.close('');

                const closeHandler = ()keypress', enterHandler);
                    elements.promptDialog.removeEventListener('close', closeHandler);
                };
 => {
                    elements.promptInput.removeEventListener('keypress', enterHandler);
                    elements.promptDialog.                 elements.promptDialog.addEventListener('close', closeHandler);

                const result = await this.showCustomDialog(elementsremoveEventListener('close', closeHandler);
                };
                 elements.promptDialog.addEventListener('close', closeHandler.promptDialog, elements.promptInput);
                return result;
            },
            updateAttachmentBadgeVisibility());

                const result = await this.showCustomDialog(elements.promptDialog, elements.promptInput);
                return {
                const hasAttachments = state.pendingAttachments.length > 0;
                elements.attachFileBtn result;
            },
            updateAttachmentBadgeVisibility() {
                const hasAttachments = state.pendingAttachments..classList.toggle('has-attachments', hasAttachments);
                 if (!state.isSending) {
                     length > 0;
                elements.attachFileBtn.classList.toggle('has-attachments', hasAttachments);
elements.sendButton.disabled = elements.userInput.value.trim() === '' && state.pendingAttachments.length                 if (!state.isSending) {
                     elements.sendButton.disabled = elements.userInput.value.trim() === === 0;
                 }
            },
            showFileUploadDialog() {
                if (state.pendingAttachments. '' && state.pendingAttachments.length === 0;
                 }
            },
            showFileUploadDialog()length > 0) {
                    state.selectedFilesForUpload = state.pendingAttachments.map(att => ({ file {
                if (state.pendingAttachments.length > 0) {
                    state.selectedFilesForUpload: att.file }));
                } else {
                    state.selectedFilesForUpload = [];
                }
 = state.pendingAttachments.map(att => ({ file: att.file }));
                } else {
                    state.selected                this.updateSelectedFilesUI();
                elements.fileUploadDialog.showModal();
                this.updateAttachmentBadgeVisibilityFilesForUpload = [];
                }
                this.updateSelectedFilesUI();
                elements.fileUploadDialog.showModal();
            },
            updateSelectedFilesUI() {
                elements.selectedFilesList.innerHTML = '';
                let();
                this.updateAttachmentBadgeVisibility();
            },
            updateSelectedFilesUI() {
                elements totalSize = 0;
                state.selectedFilesForUpload.forEach((item, index) => {
.selectedFilesList.innerHTML = '';
                let totalSize = 0;
                state.selectedFilesFor                    const li = document.createElement('li');
                    li.classList.add('selected-file-item');Upload.forEach((item, index) => {
                    const li = document.createElement('li');
                    li.classList
                    li.dataset.fileIndex = index;

                    const infoDiv = document.createElement('div');
                    info.add('selected-file-item');
                    li.dataset.fileIndex = index;

                    const infoDiv = documentDiv.classList.add('selected-file-info');
                    const nameSpan = document.createElement('span');
                    name.createElement('div');
                    infoDiv.classList.add('selected-file-info');
                    const nameSpan = documentSpan.classList.add('selected-file-name');
                    nameSpan.textContent = item.file.name.createElement('span');
                    nameSpan.classList.add('selected-file-name');
                    nameSpan;
                    nameSpan.title = item.file.name;
                    const sizeSpan = document.createElement('.textContent = item.file.name;
                    nameSpan.title = item.file.name;
                    const sizeSpan = document.createElement('span');
                    sizeSpan.classList.add('selected-file-sizespan');
                    sizeSpan.classList.add('selected-file-size');
                    sizeSpan.textContent = formatFileSize(item.file.size);
                    infoDiv.appendChild(nameSpan);
                    infoDiv.');
                    sizeSpan.textContent = formatFileSize(item.file.size);
                    infoDiv.appendChild(appendChild(sizeSpan);

                    const removeBtn = document.createElement('button');
                    removeBtn.classList.nameSpan);
                    infoDiv.appendChild(sizeSpan);

                    const removeBtn = document.createElement('buttonadd('remove-file-btn');
                    removeBtn.title = '削除';
                    removeBtn.textContent');
                    removeBtn.classList.add('remove-file-btn');
                    removeBtn.title = '削除';
 = '×';
                    removeBtn.onclick = () => appLogic.removeSelectedFile(index);

                    li                    removeBtn.textContent = '×';
                    removeBtn.onclick = () => appLogic.removeSelectedFile.appendChild(infoDiv);
                    li.appendChild(removeBtn);
                    elements.selectedFilesList.appendChild(index);

                    li.appendChild(infoDiv);
                    li.appendChild(removeBtn);
                    elements(li);
                    totalSize += item.file.size;
                });

                if (totalSize > MAX_.selectedFilesList.appendChild(li);
                    totalSize += item.file.size;
                });

                if (TOTAL_ATTACHMENT_SIZE) {
                    elements.confirmAttachBtn.disabled = true;
                } elsetotalSize > MAX_TOTAL_ATTACHMENT_SIZE) {
                    elements.confirmAttachBtn.disabled = true;
                 {
                    elements.confirmAttachBtn.disabled = false;
                }
                if (state.selectedFiles} else {
                    elements.confirmAttachBtn.disabled = false;
                }
                if (state.ForUpload.length === 0) {
                     elements.confirmAttachBtn.disabled = true;
                }selectedFilesForUpload.length === 0) {
                     elements.confirmAttachBtn.disabled = true;

            },
            updateToggleAllContentButton() {
                if (elements.toggleAllContentBtn) {                }
            },
            updateToggleAllContentButton() {
                if (elements.toggleAllContentBtn
                    if (state.areAllMessagesHidden) {
                        elements.toggleAllContentBtn.setAttribute('aria-label) {
                    if (state.areAllMessagesHidden) {
                        elements.toggleAllContentBtn.setAttribute', "全メッセージを表示");
                        elements.toggleAllContentBtn.title = "全メッセージを表示";
                    }('aria-label', "全メッセージを表示");
                        elements.toggleAllContentBtn.title = "全メッセージを表示 else {
                        elements.toggleAllContentBtn.setAttribute('aria-label', "全メッセージを非表示");";
                    } else {
                        elements.toggleAllContentBtn.setAttribute('aria-label', "全メッセージ
                        elements.toggleAllContentBtn.title = "全メッセージを非表示";
                    }
                }を非表示");
                        elements.toggleAllContentBtn.title = "全メッセージを非表示";
                    
            },
            processInteractiveTitles(contentElement) {
                const links = contentElement.querySelectorAll('a[href}
                }
            },
            processInteractiveTitles(contentElement) {
                const links = contentElement="#"]');
                links.forEach(link => {
                    if (link.dataset.interactiveTitleProcessed ===.querySelectorAll('a[href="#"]');
                links.forEach(link => {
                    if (link.dataset. 'true') {
                        return;
                    }
                    const titleText = link.getAttribute('title');
interactiveTitleProcessed === 'true') {
                        return;
                    }
                    const titleText = link.getAttribute                    if (titleText && titleText.trim() !== '') {
                        link.dataset.interactiveTitleProcessed = 'true';('title');
                    if (titleText && titleText.trim() !== '') {
                        link.dataset.interactiveTitleProcessed
                        link.addEventListener('click', function(event) {
                            event.preventDefault();
                            let toggleContentSpan = this = 'true';
                        link.addEventListener('click', function(event) {
                            event.preventDefault();
.nextElementSibling;
                            if (!toggleContentSpan || !toggleContentSpan.classList.contains('interactive-title                            let toggleContentSpan = this.nextElementSibling;
                            if (!toggleContentSpan || !toggleContentSpan.classList.contains-content')) {
                                toggleContentSpan = document.createElement('span');
                                toggleContentSpan.classList.('interactive-title-content')) {
                                toggleContentSpan = document.createElement('span');
                                toggleContentadd('interactive-title-content');
                                toggleContentSpan.classList.add('interactive-title-content-Span.classList.add('interactive-title-content');
                                toggleContentSpan.classList.add('interactive-title-contentstyle');
                                toggleContentSpan.textContent = ` (# "${titleText}")`;
                                toggleContentSpan.classList-style');
                                toggleContentSpan.textContent = ` (# "${titleText}")`;
                                toggleContentSpan.classList.add('hidden');
                                this.insertAdjacentElement('afterend', toggleContentSpan);
                                this.setAttribute.add('hidden');
                                this.insertAdjacentElement('afterend', toggleContentSpan);
                                this.setAttribute('aria-expanded', 'false');
                            }
                            const isCurrentlyHidden = toggleContentSpan.classList.('aria-expanded', 'false');
                            }
                            const isCurrentlyHidden = toggleContentSpan.classList.contains('hidden');
                            toggleContentSpan.classList.toggle('hidden', !isCurrentlyHidden);
                            this.setAttribute('contains('hidden');
                            toggleContentSpan.classList.toggle('hidden', !isCurrentlyHidden);
                            this.setAttribute('aria-expanded', String(isCurrentlyHidden));
                        });
                        link.style.cursor = 'pointer';aria-expanded', String(isCurrentlyHidden));
                        });
                        link.style.cursor = 'pointer';
                    }
                    }
                });
            }
        };

        const appLogic = {
            async initializeApp
                });
            }
        };

        const appLogic = {
            async initializeApp() {
                if (() {
                if (typeof marked !== 'undefined') {
                    marked.setOptions({
                        breaks: true, gtypeof marked !== 'undefined') {
                    marked.setOptions({
                        breaks: true, gfm: truefm: true, sanitize: true, smartypants: false
                    });
                }
                elements.app, sanitize: true, smartypants: false
                    });
                }
                elements.appVersionSpan.VersionSpan.textContent = APP_VERSION;

                window.addEventListener('beforeinstallprompt', (event) => {
                    event.preventDefault();
                });

                uiUtils.showScreen('chat');
                registerServiceWorker();

textContent = APP_VERSION;

                window.addEventListener('beforeinstallprompt', (event) => {
                    event.preventDefault();
                });

                uiUtils.showScreen('chat');
                registerServiceWorker();

                try {
                try {
                    await dbUtils.openDB();
                    await dbUtils.loadSettings();
                    uiUtils.applyTheme();
                    uiUtils.applyFontFamily();
                    uiUtils.applySidePanelSettingsToUI();

                    await dbUtils.openDB();
                    await dbUtils.loadSettings();
                    uiUtils.applyTheme();
                    uiUtils.applyFontFamily();
                    uiUtils.applySidePanelSettingsToUI();

                    if (state                    if (state.settings.backgroundImageBlob instanceof Blob) {
                        uiUtils.revokeExistingObjectUrl();
                        try.settings.backgroundImageBlob instanceof Blob) {
                        uiUtils.revokeExistingObjectUrl();
                        try {
                              {
                             state.backgroundImageUrl = URL.createObjectURL(state.settings.backgroundImageBlob);
                             document.documentElement.state.backgroundImageUrl = URL.createObjectURL(state.settings.backgroundImageBlob);
                             document.documentElement.style.setProperty('--style.setProperty('--chat-background-image', `url(${state.backgroundImageUrl})`);
                        } catch (e) {chat-background-image', `url(${state.backgroundImageUrl})`);
                        } catch (e) {
                             
                             console.error("Error creating object URL for background:", e);
                             document.documentElement.style.setProperty('--console.error("Error creating object URL for background:", e);
                             document.documentElement.style.setProperty('--chat-background-chat-background-image', 'none');
                        }
                    } else {
                        document.documentElement.styleimage', 'none');
                        }
                    } else {
                        document.documentElement.style.setProperty('--chat.setProperty('--chat-background-image', 'none');
                    }
                    if (state.settings.user-background-image', 'none');
                    }
                    if (state.settings.userIconBlob instanceof BlobIconBlob instanceof Blob) {
                        try { state.userIconUrl = URL.createObjectURL(state.settings.user) {
                        try { state.userIconUrl = URL.createObjectURL(state.settings.userIconBlob); } catchIconBlob); } catch (e) { console.error("Error creating user icon URL:", e); }
                    }
                     (e) { console.error("Error creating user icon URL:", e); }
                    }
                    if (if (state.settings.aiIconBlob instanceof Blob) {
                        try { state.aiIconUrl = URL.createstate.settings.aiIconBlob instanceof Blob) {
                        try { state.aiIconUrl = URL.createObjectURL(state.settings.aiIconBlob); } catch (e) { console.error("Error creating AI iconObjectURL(state.settings.aiIconBlob); } catch (e) { console.error("Error creating AI icon URL:", e); }
                    }

                    uiUtils.applySettingsToUI();

                    const chats = await dbUtils URL:", e); }
                    }

                    uiUtils.applySettingsToUI();

                    const chats = await dbUtils.getAllChats(state.settings.historySortOrder);
                    if (chats && chats.length > 0.getAllChats(state.settings.historySortOrder);
                    if (chats && chats.length > 0) {
                        await this.loadChat(chats[0].id);
                    } else {
                        this.start) {
                        await this.loadChat(chats[0].id);
                    } else {
                        this.startNewChat();
                    }
                    history.replaceState({ screen: 'chat' }, '', '#chat');
NewChat();
                    }
                    history.replaceState({ screen: 'chat' }, '', '#chat');
                    state.currentScreen = 'chat';

                } catch (error) {
                    console.error("App                    state.currentScreen = 'chat';

                } catch (error) {
                    console.error("App initialization error:", error);
                    await uiUtils.showCustomAlert(`アプリの初期化に失敗しました: ${ initialization error:", error);
                    await uiUtils.showCustomAlert(`アプリの初期化に失敗しました: ${error}`);
                    elements.appContainer.innerHTML = `<p style="padding: 20px; text-error}`);
                    elements.appContainer.innerHTML = `<p style="padding: 20px; text-align: center; color: red;">アプリの起動に失敗しました。</p>`;
                } finally {
                    updateMessageMaxWidthalign: center; color: red;">アプリの起動に失敗しました。</p>`;
                } finally {
                    updateMessageMaxWidthVar();
                    this.setupEventListeners();
                    this.updateZoomState();
                    uiUtils.adjustTextVar();
                    this.setupEventListeners();
                    this.updateZoomState();
                    uiUtils.adjustTextareaHeight();
                    uiUtils.setSendingState(false);
                    if (state.settings.autoScrollareaHeight();
                    uiUtils.setSendingState(false);
                    if (state.settings.autoScrollOnNewMessage) {
                        uiUtils.scrollToBottom();
                    }
                }
            },
            OnNewMessage) {
                        uiUtils.scrollToBottom();
                    }
                }
            },
            setupEventListeners() {
                elements.gotoHistoryBtn.addEventListener('click', () => uiUtils.showScreen('setupEventListeners() {
                elements.gotoHistoryBtn.addEventListener('click', () => uiUtils.showScreen('history'));
                elements.gotoSettingsBtn.addEventListener('click', () => uiUtils.showScreen('settings'));history'));
                elements.gotoSettingsBtn.addEventListener('click', () => uiUtils.showScreen('settings'));
                elements.backToChatFromHistoryBtn.addEventListener('click', () => history.back());
                elements
                elements.backToChatFromHistoryBtn.addEventListener('click', () => history.back());
                elements.backToChatFromSettingsBtn.addEventListener('click', () => history.back());
                elements.toggleMemo.backToChatFromSettingsBtn.addEventListener('click', () => history.back());
                elements.toggleMemoBtn.addEventListener('click', () => this.toggleMemo());
                elements.copyMemoBtn.addEventListener('clickBtn.addEventListener('click', () => this.toggleMemo());
                elements.copyMemoBtn.addEventListener('click', () => this.copyMemoText());
                elements.pasteMemoBtn.addEventListener('click', () => this', () => this.copyMemoText());
                elements.pasteMemoBtn.addEventListener('click', () => this.pasteIntoMemo());
                elements.deleteMemoBtn.addEventListener('click', () => this.confirmClearMemo.pasteIntoMemo());
                elements.deleteMemoBtn.addEventListener('click', () => this.confirmClearMemo());

                elements.toggleClipboardStackBtn.addEventListener('click', () => this.toggleClipboardStack());
                ());

                elements.toggleClipboardStackBtn.addEventListener('click', () => this.toggleClipboardStack());
                elements.deleteClipboardStackBtn.addEventListener('click', () => this.confirmClearClipboardStack());
                elements.copyClipboardStackBtn.addEventListener('click', () => this.copyClipboardStackText());
                elements.pasteClipboardStackBtn.addEventListener('click', () => this.pasteIntoClipboardStack());

                elements.scrollToTopBtn.addEventListener('click', () => this.scrollToTop());
                elements.scrollToBottomBtn.addEventListener('click', ()elements.deleteClipboardStackBtn.addEventListener('click', () => this.confirmClearClipboardStack());
                elements. => this.scrollToBottom());
                elements.pasteToInputBtn.addEventListener('click', () => this.pasteToUserInput());

                elements.newChatBtn.addEventListener('click', async () => {
                    const confirmed =copyClipboardStackBtn.addEventListener('click', () => this.copyClipboardStackText());
                elements.pasteClipboard await uiUtils.showCustomConfirm("現在のチャットを保存して新規チャットを開始しますか？");
                    if (confirmed) this.confirmStartNewChat();
                });
                elements.deleteSessionBtn.addEventListener('click', () => this.confirmDeleteCurrentSession());
                elements.copySessionBtn.addEventListener('click', () => this.copyStackBtn.addEventListener('click', () => this.pasteIntoClipboardStack());

                elements.scrollToTopBtn.CurrentSessionText());
                elements.toggleAllContentBtn.addEventListener('click', () => this.toggleAllMessagesVisibility());
                elements.sendButton.addEventListener('click', () => {
                    if (state.isSending) this.abortRequest();
                    else this.handleSend();
                });
                elements.userInput.addEventListener('inputaddEventListener('click', () => this.scrollToTop());
                elements.scrollToBottomBtn.addEventListener('click', ()', () => uiUtils.adjustTextareaHeight());
                elements.userInput.addEventListener('keypress', (e) => {
                    if (state.settings.enterToSend && e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        if (!(elements.userInput.value.trim() === '' && state.pendingAttachments. => this.scrollToBottom());
                elements.pasteToInputBtn.addEventListener('click', () => this.pastelength === 0) && !state.isSending) {
                             this.handleSend();
                        }
                    }
                });
                 elements.userInput.addEventListener('input', () => uiUtils.updateAttachmentBadgeVisibility());

                elements.systemPromptDetails.addEventListener('toggle', (event) => {
                    if (event.target.open) {
                        this.startEditSystemPrompt();
                    } else if (state.isEditingSystemPrompt) {
                        ToUserInput());

                elements.newChatBtn.addEventListener('click', async () => {
                    const confirmed =this.cancelEditSystemPrompt();
                    }
                });
                elements.saveSystemPromptBtn.addEventListener('click', () => this.saveCurrentSystemPrompt());
                elements.cancelSystemPromptBtn.addEventListener('click', () => this.cancelEditSystemPrompt());
                elements.systemPromptEditor.addEventListener('input', () => { await uiUtils.showCustomConfirm("現在のチャットを保存して新規チャットを開始しますか？");
                    if (confirmed) this.confirmStartNewChat();
                });
                elements.deleteSessionBtn.addEventListener('click', () =>
                    uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
                }); this.confirmDeleteCurrentSession());
                elements.copySessionBtn.addEventListener('click', () => this.copy

                elements.importHistoryBtn.addEventListener('click', () => elements.importHistoryInput.click());
                CurrentSessionText());
                elements.toggleAllContentBtn.addEventListener('click', () => this.toggleAllMessageselements.importHistoryInput.addEventListener('change', (event) => {
                    const file = event.target.Visibility());
                elements.sendButton.addEventListener('click', () => {
                    if (state.isSending) this.abortRequest();
                    else this.handleSend();
                });
                elements.userInput.addEventListener('inputfiles[0];
                    if (file) this.handleHistoryImport(file);
                    event.target.', () => uiUtils.adjustTextareaHeight());
                elements.userInput.addEventListener('keypress', (e) => {
                    if (state.settings.enterToSend && e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        if (!(elements.userInput.value.trim() === '' && state.pendingAttachments.value = null;
                });
                elements.exportAllSessionsBtn.addEventListener('click', () => this.exportAlllength === 0) && !state.isSending) {
                             this.handleSend();
                        }
                    Sessions());
                elements.importAllSessionsBtn.addEventListener('click', () => elements.importAllSessionsInput.}
                });
                 elements.userInput.addEventListener('input', () => uiUtils.updateAttachmentBadgeVisibility());

                click());
                elements.importAllSessionsInput.addEventListener('change', (event) => {
                    const fileelements.systemPromptDetails.addEventListener('toggle', (event) => {
                    if (event.target.open) {
                        this.startEditSystemPrompt();
                    } else if (state.isEditingSystemPrompt) {
                        this = event.target.files[0];
                    if (file) this.handleAllSessionsImport(file);.cancelEditSystemPrompt();
                    }
                });
                elements.saveSystemPromptBtn.addEventListener('click', () => this.saveCurrentSystemPrompt());
                elements.cancelSystemPromptBtn.addEventListener('click', ()
                    event.target.value = null;
                });

                elements.saveSettingsBtns.forEach(button => this.cancelEditSystemPrompt());
                elements.systemPromptEditor.addEventListener('input', () => {
                    uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
                });

 => {
                    button.addEventListener('click', () => this.saveSettings());
                });
                elements.                elements.importHistoryBtn.addEventListener('click', () => elements.importHistoryInput.click());
                elementsupdateAppBtn.addEventListener('click', () => this.updateApp());
                elements.clearDataBtn.addEventListener.importHistoryInput.addEventListener('change', (event) => {
                    const file = event.target.files('click', () => this.confirmClearAllData());
                elements.clearHistoryBtn.addEventListener('click',[0];
                    if (file) this.handleHistoryImport(file);
                    event.target.value = null;
                });
                elements.exportAllSessionsBtn.addEventListener('click', () => this.exportAllSessions () => this.confirmClearAllHistory());

                if (elements.themeSelect) {
                    elements.theme());
                elements.importAllSessionsBtn.addEventListener('click', () => elements.importAllSessionsInput.click());
                elements.importAllSessionsInput.addEventListener('change', (event) => {
                    const file =Select.addEventListener('change', () => {
                        state.settings.theme = elements.themeSelect.value; event.target.files[0];
                    if (file) this.handleAllSessionsImport(file);

                        uiUtils.applyTheme();
                    });
                }

                elements.uploadBackgroundBtn.addEventListener('                    event.target.value = null;
                });

                elements.saveSettingsBtns.forEach(button => {
                    button.addEventListener('click', () => this.saveSettings());
                });
                elements.updateclick', () => elements.backgroundImageInput.click());
                elements.backgroundImageInput.addEventListener('change', (event) => {AppBtn.addEventListener('click', () => this.updateApp());
                elements.clearDataBtn.addEventListener('click', () => this.confirmClearAllData());
                elements.clearHistoryBtn.addEventListener('click', ()
                    const file = event.target.files[0];
                    if (file) this.handleBackgroundImageUpload(file); => this.confirmClearAllHistory());

                if (elements.themeSelect) {
                    elements.themeSelect.addEventListener('change', () => {
                        state.settings.theme = elements.themeSelect.value;

                    event.target.value = null;
                });
                elements.deleteBackgroundBtn.addEventListener('click                        uiUtils.applyTheme();
                    });
                }

                elements.uploadBackgroundBtn.addEventListener('click', () => elements.backgroundImageInput.click());
                elements.backgroundImageInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) this.handleBackgroundImageUpload(file);
', () => this.confirmDeleteBackgroundImage());

                elements.showUserIconToggle.addEventListener('change', () =>                    event.target.value = null;
                });
                elements.deleteBackgroundBtn.addEventListener('click', {
                    state.settings.showUserIcon = elements.showUserIconToggle.checked;
                    uiUtils () => this.confirmDeleteBackgroundImage());

                elements.showUserIconToggle.addEventListener('change', () => {
                    state.settings.showUserIcon = elements.showUserIconToggle.checked;
                    uiUtils.renderChatMessages.renderChatMessages(true);
                });
                elements.uploadUserIconBtn.addEventListener('click', () => elements.userIconInput.click());
                elements.userIconInput.addEventListener('change', (event)(true);
                });
                elements.uploadUserIconBtn.addEventListener('click', () => elements.user => {
                    const file = event.target.files[0];
                    if (file) this.handleIconIconInput.click());
                elements.userIconInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) this.handleIconUpload('user', file);Upload('user', file);
                    event.target.value = null;
                });
                elements.deleteUserIcon
                    event.target.value = null;
                });
                elements.deleteUserIconBtn.addEventListener('Btn.addEventListener('click', () => this.confirmDeleteIcon('user'));
                elements.showUserNameToggle.addEventListener('click', () => this.confirmDeleteIcon('user'));
                elements.showUserNameToggle.addEventListener('change',change', () => {
                    state.settings.showUserName = elements.showUserNameToggle.checked;
                    uiUtils.renderChatMessages(true);
                });

                elements.showAiIconToggle.addEventListener('change () => {
                    state.settings.showUserName = elements.showUserNameToggle.checked;
                    uiUtils.', () => {
                    state.settings.showAiIcon = elements.showAiIconToggle.checked;
renderChatMessages(true);
                });

                elements.showAiIconToggle.addEventListener('change', () =>                    uiUtils.renderChatMessages(true);
                });
                elements.uploadAiIconBtn.addEventListener(' {
                    state.settings.showAiIcon = elements.showAiIconToggle.checked;
                    uiUtilsclick', () => elements.aiIconInput.click());
                elements.aiIconInput.addEventListener('change',.renderChatMessages(true);
                });
                elements.uploadAiIconBtn.addEventListener('click', () => elements.aiIconInput.click());
                elements.aiIconInput.addEventListener('change', (event) (event) => {
                    const file = event.target.files[0];
                    if (file) => {
                    const file = event.target.files[0];
                    if (file) this.handle this.handleIconUpload('ai', file);
                    event.target.value = null;
                });
                elementsIconUpload('ai', file);
                    event.target.value = null;
                });
                elements..deleteAiIconBtn.addEventListener('click', () => this.confirmDeleteIcon('ai'));
                elements.deleteAiIconBtn.addEventListener('click', () => this.confirmDeleteIcon('ai'));
                elements.showshowAiNameToggle.addEventListener('change', () => {
                    state.settings.showAiName = elements.showAiNameAiNameToggle.addEventListener('change', () => {
                    state.settings.showAiName = elements.showToggle.checked;
                    uiUtils.renderChatMessages(true);
                });
                elements.iconNameFontSizeInput.AiNameToggle.checked;
                    uiUtils.renderChatMessages(true);
                });
                elements.addEventListener('input', () => {
                    const newSize = parseInt(elements.iconNameFontSizeInput.value,iconNameFontSizeInput.addEventListener('input', () => {
                    const newSize = parseInt(elements.iconName 10);
                    if (newSize >= 6 && newSize <= 16) {
                        FontSizeInput.value, 10);
                    if (newSize >= 6 && newSize <= 1document.documentElement.style.setProperty('--icon-name-font-size', `${newSize}px`);
                    6) {
                        document.documentElement.style.setProperty('--icon-name-font-size', `${newSize} else if (elements.iconNameFontSizeInput.value === '') {
                        document.documentElement.style.setProperty}px`);
                    } else if (elements.iconNameFontSizeInput.value === '') {
                        document.('--icon-name-font-size', `${DEFAULT_ICON_NAME_FONT_SIZE}px`);
                    documentElement.style.setProperty('--icon-name-font-size', `${DEFAULT_ICON_NAME_FONT_SIZE}
                });
                elements.iconNameOffsetYInput.addEventListener('input', () => {
                    const ui}px`);
                    }
                });
                elements.iconNameOffsetYInput.addEventListener('input', () => {OffsetY = parseInt(elements.iconNameOffsetYInput.value, 10);
                    const internalOffsetY = is
                    const uiOffsetY = parseInt(elements.iconNameOffsetYInput.value, 10);
                    const internalOffsetY =NaN(uiOffsetY) ? DEFAULT_ICON_NAME_OFFSET_Y : (uiOffsetY * -1);
                    if ( isNaN(uiOffsetY) ? DEFAULT_ICON_NAME_OFFSET_Y : (uiOffsetY * -1);
                    ifinternalOffsetY >= -20 && internalOffsetY <= 20) {
                        document.documentElement.style.setProperty (internalOffsetY >= -20 && internalOffsetY <= 20) {
                        document.documentElement.style.('--icon-name-offset-y', `${internalOffsetY}px`);
                    } else if (elements.iconsetProperty('--icon-name-offset-y', `${internalOffsetY}px`);
                    } else if (elements.NameOffsetYInput.value === '') {
                        document.documentElement.style.setProperty('--icon-name-offset-iconNameOffsetYInput.value === '') {
                        document.documentElement.style.setProperty('--icon-name-offsety', `${DEFAULT_ICON_NAME_OFFSET_Y}px`);
                    }
                });

                elements-y', `${DEFAULT_ICON_NAME_OFFSET_Y}px`);
                    }
                });

                .messageIconSizeInput.addEventListener('input', () => {
                    const newSize = parseInt(elements.messageIconSizeInput.value, 10);
                    if (newSize >= 16 && newSize <=elements.messageIconSizeInput.addEventListener('input', () => {
                    const newSize = parseInt(elements.messageIconSizeInput.value, 10);
                    if (newSize >= 16 && newSize 64) {
                        document.documentElement.style.setProperty('--message-icon-size', `${newSize <= 64) {
                        document.documentElement.style.setProperty('--message-icon-size', `${new}px`);
                    } else if (elements.messageIconSizeInput.value === '') {
                        document.Size}px`);
                    } else if (elements.messageIconSizeInput.value === '') {
                        documentdocumentElement.style.setProperty('--message-icon-size', `${DEFAULT_MESSAGE_ICON_SIZE}px`);
                    }
.documentElement.style.setProperty('--message-icon-size', `${DEFAULT_MESSAGE_ICON_SIZE}px`);
                                    });
                elements.messageIconOffsetYInput.addEventListener('input', () => {
                    const uiOffsetY =}
                });
                elements.messageIconOffsetYInput.addEventListener('input', () => {
                    const ui parseInt(elements.messageIconOffsetYInput.value, 10);
                    const internalOffsetY = isNaN(OffsetY = parseInt(elements.messageIconOffsetYInput.value, 10);
                    const internalOffsetY = isuiOffsetY) ? DEFAULT_MESSAGE_ICON_OFFSET_Y : (uiOffsetY * -1);

                    if (internalNaN(uiOffsetY) ? DEFAULT_MESSAGE_ICON_OFFSET_Y : (uiOffsetY * -1);

OffsetY >= -50 && internalOffsetY <= 50) {
                        document.documentElement.style.setProperty('--                    if (internalOffsetY >= -50 && internalOffsetY <= 50) {
                        document.documentElement.message-icon-offset-y', `${internalOffsetY}px`);
                    } else if (elements.messageIconstyle.setProperty('--message-icon-offset-y', `${internalOffsetY}px`);
                    } else if (OffsetYInput.value === '') {
                        document.documentElement.style.setProperty('--message-icon-offset-y', `${elements.messageIconOffsetYInput.value === '') {
                        document.documentElement.style.setProperty('--message-icon-offsetDEFAULT_MESSAGE_ICON_OFFSET_Y}px`);
                    }
                });
                elements.userNameBubbleToggle.-y', `${DEFAULT_MESSAGE_ICON_OFFSET_Y}px`);
                    }
                });
                elements.addEventListener('change', () => {
                    state.settings.showUserNameBubble = elements.userNameBubbleToggle.checked;
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);userNameBubbleToggle.addEventListener('change', () => {
                    state.settings.showUserNameBubble = elements.userNameBubbleToggle
                });
                elements.userNameBubbleUseThemeColorToggle.addEventListener('change', () => {
                    state.checked;
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(.settings.userNameBubbleUseThemeColor = elements.userNameBubbleUseThemeColorToggle.checked;
                    uiUtilstrue);
                });
                elements.userNameBubbleUseThemeColorToggle.addEventListener('change', () => {
.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);
                });
                                    state.settings.userNameBubbleUseThemeColor = elements.userNameBubbleUseThemeColorToggle.checked;
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);
                });elements.userNameBubbleColorInput.addEventListener('input', () => {
                    state.settings.userNameBubbleColor =
                elements.userNameBubbleColorInput.addEventListener('input', () => {
                    state.settings.userNameBubble elements.userNameBubbleColorInput.value.trim() || DEFAULT_USER_NAME_BUBBLE_COLOR;Color = elements.userNameBubbleColorInput.value.trim() || DEFAULT_USER_NAME_BUBBLE_COLOR;

                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);
                });
                elements.userNameBubbleOpacityInput.addEventListener('input', () => {
                    state.settings.                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);
                });
                elements.userNameBubbleOpacityInput.addEventListener('input', () => {
                    state.settings.userNameuserNameBubbleOpacity = elements.userNameBubbleOpacityInput.value === '' ? DEFAULT_USER_NAME_BUBBLE_OPACITY : parseFloat(elements.userNameBubbleOpacityInput.value);
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);
                });
                elements.aiNameBubbleToggle.BubbleOpacity = elements.userNameBubbleOpacityInput.value === '' ? DEFAULT_USER_NAME_BUBBLE_OPACITY : parseFloat(elements.userNameBubbleOpacityInput.value);
                    uiUtils.applySidePanelSettingsToaddEventListener('change', () => {
                    state.settings.showAiNameBubble = elements.aiNameBubbleToggle.UI();
                    uiUtils.renderChatMessages(true);
                });
                elements.aiNameBubbleTogglechecked;
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true.addEventListener('change', () => {
                    state.settings.showAiNameBubble = elements.aiNameBubbleToggle.checked);
                });
                elements.aiNameBubbleUseThemeColorToggle.addEventListener('change', () => {
;
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);
                });
                elements.aiNameBubbleUseThemeColorToggle.addEventListener('change', () => {
                                        state.settings.aiNameBubbleUseThemeColor = elements.aiNameBubbleUseThemeColorToggle.checked;
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);
state.settings.aiNameBubbleUseThemeColor = elements.aiNameBubbleUseThemeColorToggle.checked;
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);
                                });
                elements.aiNameBubbleColorInput.addEventListener('input', () => {
                    state.settings});
                elements.aiNameBubbleColorInput.addEventListener('input', () => {
                    state.settings..aiNameBubbleColor = elements.aiNameBubbleColorInput.value.trim() || DEFAULT_AI_NAME_BUBBLE_COLOR;
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.aiNameBubbleColor = elements.aiNameBubbleColorInput.value.trim() || DEFAULT_AI_NAME_BUBBLE_COLOR;
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(renderChatMessages(true);
                });
                elements.aiNameBubbleOpacityInput.addEventListener('input', () => {
                    state.settings.aiNameBubbleOpacity = elements.aiNameBubbleOpacityInput.value === ''true);
                });
                elements.aiNameBubbleOpacityInput.addEventListener('input', () => {
                     ? DEFAULT_AI_NAME_BUBBLE_OPACITY : parseFloat(elements.aiNameBubbleOpacityInput.state.settings.aiNameBubbleOpacity = elements.aiNameBubbleOpacityInput.value === '' ? DEFAULT_AIvalue);
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true_NAME_BUBBLE_OPACITY : parseFloat(elements.aiNameBubbleOpacityInput.value);
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.renderChatMessages(true);
                });


                elements);
                });


                elements.hideSystemPromptToggle.addEventListener('change', () => {
                    state.settings.hideSystemPromptInChat = elements.hideSystemPromptToggle.checked;
                    uiUtils.toggleSystemPromptVisibility();.hideSystemPromptToggle.addEventListener('change', () => {
                    state.settings.hideSystemPromptInChat
                });
                elements.showMemoButtonToggle.addEventListener('change', () => {
                    state.settings = elements.hideSystemPromptToggle.checked;
                    uiUtils.toggleSystemPromptVisibility();
                });
.showMemoButton = elements.showMemoButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility                elements.showMemoButtonToggle.addEventListener('change', () => {
                    state.settings.showMemoButton = elements.showMemoButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });();
                });
                elements.showClipboardStackButtonToggle.addEventListener('change', () => {
                    state
                elements.showClipboardStackButtonToggle.addEventListener('change', () => {
                    state.settings.show.settings.showClipboardStackButton = elements.showClipboardStackButtonToggle.checked;
                    uiUtils.updateClipboardStackButton = elements.showClipboardStackButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibilityChatScreenElementVisibility();
                });
                elements.showNewChatButtonToggle.addEventListener('change', () => {
                    state.settings.showNewChatButton = elements.showNewChatButtonToggle.checked;
                    ();
                });
                elements.showNewChatButtonToggle.addEventListener('change', () => {
                    stateuiUtils.updateChatScreenElementVisibility();
                });
                elements.showDeleteSessionButtonToggle.addEventListener('.settings.showNewChatButton = elements.showNewChatButtonToggle.checked;
                    uiUtils.updatechange', () => {
                    state.settings.showDeleteSessionButton = elements.showDeleteSessionButtonToggle.ChatScreenElementVisibility();
                });
                elements.showDeleteSessionButtonToggle.addEventListener('change', () => {
                    state.settings.showDeleteSessionButton = elements.showDeleteSessionButtonToggle.checked;
                    checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.showCopySessionButtonToggle.addEventListener('change', () => {
                    state.settings.showCopySessionButton = elements.showCopyuiUtils.updateChatScreenElementVisibility();
                });
                elements.showCopySessionButtonToggle.addEventListener('SessionButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.change', () => {
                    state.settings.showCopySessionButton = elements.showCopySessionButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.showScrollToTopshowScrollToTopButtonToggle.addEventListener('change', () => {
                    state.settings.showScrollToTopButton = elements.showScrollToTopButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                ButtonToggle.addEventListener('change', () => {
                    state.settings.showScrollToTopButton = elements.showScroll});
                elements.showScrollToBottomButtonToggle.addEventListener('change', () => {
                    state.settingsToTopButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.showScrollToBottomButtonToggle.addEventListener('change', () => {
                    state.settings.showScrollTo.showScrollToBottomButton = elements.showScrollToBottomButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.showToggleAllContentButtonToggle.addEventListener('change', () => {
BottomButton = elements.showScrollToBottomButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.showToggleAllContentButtonToggle.addEventListener('change', () => {
                    state.settings                    state.settings.showToggleAllContentButton = elements.showToggleAllContentButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.showBulkHistoryActionsToggle.addEventListener('change', ().showToggleAllContentButton = elements.showToggleAllContentButtonToggle.checked;
                    uiUtils.update => {
                    state.settings.showBulkHistoryActions = elements.showBulkHistoryActionsToggle.checked;
ChatScreenElementVisibility();
                });
                elements.showBulkHistoryActionsToggle.addEventListener('change', () => {
                    state.settings.showBulkHistoryActions = elements.showBulkHistoryActionsToggle.checked;
                                        uiUtils.updateHistoryHeaderButtonVisibility();
                });
                elements.showPasteButtonInFooterToggle.addEventListener('changeuiUtils.updateHistoryHeaderButtonVisibility();
                });
                elements.showPasteButtonInFooterToggle.addEventListener', () => {
                    state.settings.showPasteButtonInFooter = elements.showPasteButtonInFooterToggle('change', () => {
                    state.settings.showPasteButtonInFooter = elements.showPasteButtonInFooterToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.showPasteButton.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.showPasteButtonInEditToggle.addEventListener('change', () => {
                    state.settings.showPasteButtonInEdit = elements.showPasteInEditToggle.addEventListener('change', () => {
                    state.settings.showPasteButtonInEdit = elementsButtonInEditToggle.checked;
                });
                elements.preventZoomToggle.addEventListener('change', () =>.showPasteButtonInEditToggle.checked;
                });
                elements.preventZoomToggle.addEventListener('change {
                    state.settings.preventZoom = elements.preventZoomToggle.checked;
                    uiUtils.apply', () => {
                    state.settings.preventZoom = elements.preventZoomToggle.checked;
                    uiZoomPreventionSetting();
                });

                elements.memoHeightInput.addEventListener('input', () => {
                    const newHeight = elements.memoHeightInput.value.trim();
                    if (newHeight) {
                        document.Utils.applyZoomPreventionSetting();
                });

                elements.memoHeightInput.addEventListener('input', () => {
                    const newHeight = elements.memoHeightInput.value.trim();
                    if (newHeight) {documentElement.style.setProperty('--memo-height', newHeight);
                    } else {
                        document.documentElement.
                        document.documentElement.style.setProperty('--memo-height', newHeight);
                    } else {
                        style.setProperty('--memo-height', DEFAULT_MEMO_HEIGHT);
                    }
                });
                elementsdocument.documentElement.style.setProperty('--memo-height', DEFAULT_MEMO_HEIGHT);
                    }
                .messageBodyFontSizeInput.addEventListener('input', () => {
                    const newSize = elements.messageBodyFontSize});
                elements.messageBodyFontSizeInput.addEventListener('input', () => {
                    const newSize = elementsInput.value.trim();
                    document.documentElement.style.setProperty('--message-body-font-size',.messageBodyFontSizeInput.value.trim();
                    document.documentElement.style.setProperty('--message-body- newSize ? `${newSize}px` : `${DEFAULT_MESSAGE_BODY_FONT_SIZE}px`);
                });
font-size', newSize ? `${newSize}px` : `${DEFAULT_MESSAGE_BODY_FONT_SIZE}px`);                elements.codeBlockFontSizeInput.addEventListener('input', () => {
                    const newSize = elements.codeBlockFontSizeInput.value.trim();
                    document.documentElement.style.setProperty('--code-block-font-
                });
                elements.codeBlockFontSizeInput.addEventListener('input', () => {
                    const newSize = elements.codeBlockFontSizeInput.value.trim();
                    document.documentElement.style.setProperty('--code-size', newSize ? `${newSize}px` : `${DEFAULT_CODE_BLOCK_FONT_SIZE}pxblock-font-size', newSize ? `${newSize}px` : `${DEFAULT_CODE_BLOCK_FONT_SIZE}`);
                });
                elements.showToggleAllContentButtonToggle.addEventListener('change', () => {
                    px`);
                });
                elements.showToggleAllContentButtonToggle.addEventListener('change', () => {
state.settings.showToggleAllContentButton = elements.showToggleAllContentButtonToggle.checked;
                    uiUtils.                    state.settings.showToggleAllContentButton = elements.showToggleAllContentButtonToggle.checked;
                    uiUtils.updateChatScreenElementVisibility();
                });
                elements.showBulkHistoryActionsToggle.addEventListener('change', ()updateChatScreenElementVisibility();
                });
                elements.showBulkHistoryActionsToggle.addEventListener('change', () => {
                    state.settings.showBulkHistoryActions = elements.showBulkHistoryActionsToggle.checked;
 => {
                    state.settings.showBulkHistoryActions = elements.showBulkHistoryActionsToggle.checked;
                    uiUtils.updateHistoryHeaderButtonVisibility();
                });
                elements.messageBubbleOpacityInput.addEventListener('input', () => {
                    const opacity = parseFloat(elements.messageBubbleOpacityInput.value);
                    if                    uiUtils.updateHistoryHeaderButtonVisibility();
                });
                elements.messageBubbleOpacityInput.addEventListener('input', () => {
                    const opacity = parseFloat(elements.messageBubbleOpacityInput.value);
                    if (!isNaN(opacity) && opacity >= 0 && opacity <= 1) {
                        document.documentElement.style (!isNaN(opacity) && opacity >= 0 && opacity <= 1) {
                        document.documentElement.style.setProperty('--message-bubble-opacity', opacity);
                    } else if (elements.messageBubbleOpacityInput..setProperty('--message-bubble-opacity', opacity);
                    } else if (elements.messageBubbleOpacityInput.value === '') {
                         document.documentElement.style.setProperty('--message-bubble-opacity', DEFAULT_MESSAGE_value === '') {
                         document.documentElement.style.setProperty('--message-bubble-opacity', DEFAULT_MESSAGE_BUBBLE_OPACITY);
                    }
                });
                 elements.chatOverlayOpacityInput.addEventListener('input', () => {
                    const opacity = parseFloat(elements.chatOverlayOpacityInput.value);
                    if (!isNaNBUBBLE_OPACITY);
                    }
                });
                 elements.chatOverlayOpacityInput.addEventListener('input', () => {
                    const opacity = parseFloat(elements.chatOverlayOpacityInput.value);
                    if (!isNaN(opacity) && opacity >= 0 && opacity <= 1) {
                        document.documentElement.style.setProperty(opacity) && opacity >= 0 && opacity <= 1) {
                        document.documentElement.style.setProperty('--chat-('--chat-overlay-alpha', opacity);
                    } else if (elements.chatOverlayOpacityInput.value === '') {
                        document.documentElement.style.setProperty('--chat-overlay-alpha', DEFAULT_CHAT_OVERLAYoverlay-alpha', opacity);
                    } else if (elements.chatOverlayOpacityInput.value === '') {
_OPACITY);
                    }
                });
                elements.headerFooterOpacityInput.addEventListener('input', () => {
                        document.documentElement.style.setProperty('--chat-overlay-alpha', DEFAULT_CHAT_OVERLAY_OPACITY);
                    }
                });
                elements.headerFooterOpacityInput.addEventListener('input', () => {
                    const opacity = parseFloat(elements.headerFooterOpacityInput.value);
                    if (!isNaN(opacity) && opacity >= 0 && opacity <= 1) {
                        document.documentElement.style.setProperty('--header-footer-opacity',                    const opacity = parseFloat(elements.headerFooterOpacityInput.value);
                    if (!isNaN(opacity) && opacity >= 0 && opacity <= 1) {
                        document.documentElement.style.setProperty('--header-footer opacity);
                    } else if (elements.headerFooterOpacityInput.value === '') {
                        document.documentElement.style.-opacity', opacity);
                    } else if (elements.headerFooterOpacityInput.value === '') {
                        setProperty('--header-footer-opacity', DEFAULT_HEADER_FOOTER_OPACITY);
                    }
                });document.documentElement.style.setProperty('--header-footer-opacity', DEFAULT_HEADER_FOOTER_OPACITY);
                elements.messageActionsBackgroundOpacityInput.addEventListener('input', () => {
                    const opacity = parseFloat(
                    }
                });
                elements.messageActionsBackgroundOpacityInput.addEventListener('input', () => {
elements.messageActionsBackgroundOpacityInput.value);
                    if (!isNaN(opacity) && opacity >= 0 &&                    const opacity = parseFloat(elements.messageActionsBackgroundOpacityInput.value);
                    if (!isNaN(opacity) opacity <= 1) {
                        document.documentElement.style.setProperty('--message-actions-bg-opacity', && opacity >= 0 && opacity <= 1) {
                        document.documentElement.style.setProperty('--message-actions-bg opacity);
                    } else if (elements.messageActionsBackgroundOpacityInput.value === '') {
                        document.documentElement.style.setProperty('--message-actions-bg-opacity', DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY-opacity', opacity);
                    } else if (elements.messageActionsBackgroundOpacityInput.value === '') {
);
                    }
                });
                elements.toggleButtonTopOpacityInput.addEventListener('input', () => {                        document.documentElement.style.setProperty('--message-actions-bg-opacity', DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY);
                    }
                });
                elements.toggleButtonTopOpacityInput.addEventListener('input',
                    const opacity = parseFloat(elements.toggleButtonTopOpacityInput.value);
                    if (!isNaN(opacity () => {
                    const opacity = parseFloat(elements.toggleButtonTopOpacityInput.value);
                    if (!) && opacity >= 0 && opacity <= 1) {
                        document.documentElement.style.setProperty('--messageisNaN(opacity) && opacity >= 0 && opacity <= 1) {
                        document.documentElement.style.-toggle-button-top-opacity', opacity);
                    } else if (elements.toggleButtonTopOpacityInput.value === '') {
                        document.documentElement.style.setProperty('--message-toggle-button-top-opacitysetProperty('--message-toggle-button-top-opacity', opacity);
                    } else if (elements.toggleButtonTopOpacityInput', DEFAULT_TOGGLE_BUTTON_TOP_OPACITY);
                    }
                });
                elements.show.value === '') {
                        document.documentElement.style.setProperty('--message-toggle-button-top-opacityCollapseButtonsToggle.addEventListener('change', () => {
                    state.settings.showCollapseButtons = elements.show', DEFAULT_TOGGLE_BUTTON_TOP_OPACITY);
                    }
                });
                elements.showCollapseButtonsToggle.addEventListener('change', () => {
                    state.settings.showCollapseButtons = elements.showCollapseButtonsToggle.checked;
                    uiUtils.renderChatMessages(true);
                });
                elements.CollapseButtonsToggle.checked;
                    uiUtils.renderChatMessages(true);
                });
                elements.persistMessageCollapseStateCheckbox.addEventListener('change', () => {
                    state.settings.persistMessageCollapseState = elements.persistMessageCollapseStateCheckbox.checked;
                });

                elements.messageContainer.addEventListener('click',persistMessageCollapseStateCheckbox.addEventListener('change', () => {
                    state.settings.persistMessageCollapseState = elements.persistMessageCollapseStateCheckbox.checked;
                });

                elements.messageContainer.addEventListener('click', (event) => {
                    const clickedMessage = event.target.closest('.message');
                    if (event.target. (event) => {
                    const clickedMessage = event.target.closest('.message');
                    if (event.target.closest('.message-actions button, .message-cascade-controls button, .message-toggle-button, .interactiveclosest('.message-actions button, .message-cascade-controls button, .message-toggle-button, .interactive-title-content, .code-copy-button')) {
                        return;
                    }
                    if (clickedMessage) {
                        const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
-title-content, .code-copy-button')) {
                        return;
                    }
                    if (clickedMessage) {
                        const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                        if (currentlyShown && currentlyShown !== clickedMessage) {
                            currentlyShown.classList.remove('show-actions');
                        if (currentlyShown && currentlyShown !== clickedMessage) {
                            currentlyShown.classList.remove('show-actions');
                        }
                        if (!clickedMessage.classList.contains('editing')) {
                            clickedMessage.classList.toggle                        }
                        if (!clickedMessage.classList.contains('editing')) {
                            clickedMessage.classList.toggle('show-actions');
                        }
                    } else {
                        const currentlyShown = elements.messageContainer.('show-actions');
                        }
                    } else {
                        const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                        if (currentlyShown) {
                            currentlyShown.classList.removequerySelector('.message.show-actions');
                        if (currentlyShown) {
                            currentlyShown.classList.remove('show-actions');
                        }
                    }
                }, true);
                document.body.addEventListener('('show-actions');
                        }
                    }
                }, true);
                document.body.addEventListener('click', (event) => {
                    if (!elements.messageContainer.contains(event.target) &&
                        !click', (event) => {
                    if (!elements.messageContainer.contains(event.target) &&
elements.memoArea.contains(event.target) &&
                        !elements.clipboardStackArea.contains(event                        !elements.memoArea.contains(event.target) &&
                        !elements.clipboardStackArea.contains.target) &&
                        !event.target.closest('.custom-dialog')) {
                        const currentlyShown = elements.(event.target) &&
                        !event.target.closest('.custom-dialog')) {
                        const currentlymessageContainer.querySelector('.message.show-actions');
                        if (currentlyShown) {
                            currentlyShown.classList.remove('show-actions');
                        }
                    }
                }, true);

                elements.chatShown = elements.messageContainer.querySelector('.message.show-actions');
                        if (currentlyShown) {
                            currentlyShown.classList.remove('show-actions');
                        }
                    }
                }, true);

Screen.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
                elements                elements.chatScreen.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true.chatScreen.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false }); });
                elements.chatScreen.addEventListener('touchmove', this.handleTouchMove.bind(this), {
                elements.chatScreen.addEventListener('touchend', this.handleTouchEnd.bind(this));

                 passive: false });
                elements.chatScreen.addEventListener('touchend', this.handleTouchEnd.bind(if ('visualViewport' in window) {
                    window.visualViewport.addEventListener('resize', this.updateZoomState.this));

                if ('visualViewport' in window) {
                    window.visualViewport.addEventListener('resize', this.bind(this));
                    window.visualViewport.addEventListener('scroll', this.updateZoomState.bind(thisupdateZoomState.bind(this));
                    window.visualViewport.addEventListener('scroll', this.updateZoomState));
                }

                window.addEventListener('popstate', this.handlePopState.bind(this));

                elements.bind(this));
                }

                window.addEventListener('popstate', this.handlePopState.bind(this));.attachFileBtn.addEventListener('click', () => uiUtils.showFileUploadDialog());
                elements.selectFiles

                elements.attachFileBtn.addEventListener('click', () => uiUtils.showFileUploadDialog());
                elements.selectFilesBtn.addEventListener('click', () => elements.fileInput.click());
                elements.fileInput.addEventListener('Btn.addEventListener('click', () => elements.fileInput.click());
                elements.fileInput.addEventListener('change', (event) => {
                    this.handleFileSelection(event.target.files);
                    eventchange', (event) => {
                    this.handleFileSelection(event.target.files);
                    event.target.value = null;
                });
                elements.confirmAttachBtn.addEventListener('click', () =>.target.value = null;
                });
                elements.confirmAttachBtn.addEventListener('click', () => this.confirmAttachment());
                elements.cancelAttachBtn.addEventListener('click', () => this.cancelAttachment());
                 this.confirmAttachment());
                elements.cancelAttachBtn.addEventListener('click', () => this.cancelAttachment());
                elements.fileUploadDialog.addEventListener('close', () => {
                    if (elements.fileUploadDialog.returnValueelements.fileUploadDialog.addEventListener('close', () => {
                    if (elements.fileUploadDialog.returnValue !== 'ok') {
                        this.cancelAttachment();
                    }
                });
                elements.messageContainer !== 'ok') {
                        this.cancelAttachment();
                    }
                });
                elements.messageContainer.addEventListener('click', (event) => {
                    const targetButton = event.target.closest('.message-toggle-button.addEventListener('click', (event) => {
                    const targetButton = event.target.closest('.message-toggle-button');
                    if (targetButton && targetButton.dataset.action === 'toggle-collapse') {
                        const');
                    if (targetButton && targetButton.dataset.action === 'toggle-collapse') {
                        const index = parseInt(targetButton.dataset.index, 10);
                        this.toggleMessageCollapse(index);
 index = parseInt(targetButton.dataset.index, 10);
                        this.toggleMessageCollapse(index                    }
                });
            },
            handlePopState(event) {
                const targetScreen = event.state?.);
                    }
                });
            },
            handlePopState(event) {
                const targetScreenscreen || 'chat';
                uiUtils.showScreen(targetScreen, true);
            },
            update = event.state?.screen || 'chat';
                uiUtils.showScreen(targetScreen, true);
ZoomState() {
                if ('visualViewport' in window) {
                    const newZoomState = window.visualViewport.            },
            updateZoomState() {
                if ('visualViewport' in window) {
                    const newscale > ZOOM_THRESHOLD;
                    if (state.isZoomed !== newZoomState) {
                        stateZoomState = window.visualViewport.scale > ZOOM_THRESHOLD;
                    if (state.isZoomed !==.isZoomed = newZoomState;
                        document.body.classList.toggle('zoomed', state. newZoomState) {
                        state.isZoomed = newZoomState;
                        document.body.classListisZoomed);
                    }
                }
            },
            handleTouchStart(event) {
                .toggle('zoomed', state.isZoomed);
                    }
                }
            },
            handleif (!state.settings.enableSwipeNavigation) return;
                if (event.touches.length > 1 || state.TouchStart(event) {
                if (!state.settings.enableSwipeNavigation) return;
                if (event.touchesisZoomed) {
                    state.touchStartX = 0;
                    state.touchStartY = 0.length > 1 || state.isZoomed) {
                    state.touchStartX = 0;
;
                    state.isSwiping = false;
                    return;
                }
                state.touchStartX                    state.touchStartY = 0;
                    state.isSwiping = false;
                    return;
                }
                state.touchStartX = event.touches[0].clientX;
                state.touchStartY = = event.touches[0].clientX;
                state.touchStartY = event.touches[0].clientY; event.touches[0].clientY;
                state.isSwiping = false;
                state.touchEndX
                state.isSwiping = false;
                state.touchEndX = state.touchStartX;
                state. = state.touchStartX;
                state.touchEndY = state.touchStartY;
            },
            handletouchEndY = state.touchStartY;
            },
            handleTouchMove(event) {
                if (!state.settings.enableSwipeNavigation) return;
                if (!state.touchStartX || event.touches.lengthTouchMove(event) {
                if (!state.settings.enableSwipeNavigation) return;
                if (!state.touch > 1 || state.isZoomed) {
                    return;
                }
                const currentX =StartX || event.touches.length > 1 || state.isZoomed) {
                    return;
                }
                 event.touches[0].clientX;
                const currentY = event.touches[0].clientY;
                const currentX = event.touches[0].clientX;
                const currentY = event.touches[0].const diffX = state.touchStartX - currentX;
                const diffY = state.touchStartY - currentY;clientY;
                const diffX = state.touchStartX - currentX;
                const diffY = state.

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    state.touchStartY - currentY;

                if (Math.abs(diffX) > Math.abs(diffY)) {
isSwiping = true;
                    event.preventDefault();
                } else {
                    state.isSwiping                    state.isSwiping = true;
                    event.preventDefault();
                } else {
                    state. = false;
                }
                state.touchEndX = currentX;
                state.touchEndY = currentisSwiping = false;
                }
                state.touchEndX = currentX;
                state.touchY;
            },
            handleTouchEnd(event) {
                 if (!state.settings.enableSwipeEndY = currentY;
            },
            handleTouchEnd(event) {
                 if (!state.settingsNavigation) {
                     this.resetSwipeState();
                     return;
                 }
                 this.updateZoom.enableSwipeNavigation) {
                     this.resetSwipeState();
                     return;
                 }
                 this.updateZoomState();
                 if (state.isZoomed) {
                     this.resetSwipeState();
                     returnState();
                 if (state.isZoomed) {
                     this.resetSwipeState();
                     return;
                 }
                 if (!state.isSwiping || !state.touchStartX) {
                     this.reset;
                 }
                 if (!state.isSwiping || !state.touchStartX) {
                     this.resetSwipeState();
                     return;
                 }

                const diffX = state.touchStartX - stateSwipeState();
                     return;
                 }

                const diffX = state.touchStartX - state.touchEndX;
                const diffY = state.touchStartY - state.touchEndY;

                if (Math.abs(diff.touchEndX;
                const diffY = state.touchStartY - state.touchEndY;

                if (X) > SWIPE_THRESHOLD && Math.abs(diffX) > Math.abs(diffY)) {Math.abs(diffX) > SWIPE_THRESHOLD && Math.abs(diffX) > Math.abs
                    if (diffX > 0) {
                        uiUtils.showScreen('settings');
                    }(diffY)) {
                    if (diffX > 0) {
                        uiUtils.showScreen(' else {
                        uiUtils.showScreen('history');
                    }
                }
                this.resetSwipeState();
settings');
                    } else {
                        uiUtils.showScreen('history');
                    }
                }
            },
            resetSwipeState() {
                state.touchStartX = 0;
                state.touch                this.resetSwipeState();
            },
            resetSwipeState() {
                state.touchStartX =StartY = 0;
                state.touchEndX = 0;
                state.touchEndY = 0 0;
                state.touchStartY = 0;
                state.touchEndX = 0;
;
                state.isSwiping = false;
            },
            toggleMemo() {
                 if (                state.touchEndY = 0;
                state.isSwiping = false;
            },
            toggleMemo() {
                 if (state.editingMessageIndex !== null) {
                     uiUtils.showCustomstate.editingMessageIndex !== null) {
                     uiUtils.showCustomAlert("メッセージ編集中はメモを開閉できませんAlert("メッセージ編集中はメモを開閉できません。");
                     return;
                 }
                 if (state.is。");
                     return;
                 }
                 if (state.isEditingSystemPrompt) {
                     uiUtils.showCustomAlert("システムプロンプト編集中はメモを開閉できません。");
                     return;
                 }

EditingSystemPrompt) {
                     uiUtils.showCustomAlert("システムプロンプト編集中はメモを開閉できません。                state.isMemoVisible = !state.isMemoVisible;
                elements.memoArea.classList.toggle('hidden',");
                     return;
                 }

                state.isMemoVisible = !state.isMemoVisible;
                elements. !state.isMemoVisible);

                if (state.isMemoVisible) {
                    elements.memoEditormemoArea.classList.toggle('hidden', !state.isMemoVisible);

                if (state.isMemo.focus();
                }
            },
            async copyMemoText() {
                const memoText = elementsVisible) {
                    elements.memoEditor.focus();
                }
            },
            async copyMemoText.memoEditor.value;
                if (!memoText.trim()) {
                     const originalText = elements.() {
                const memoText = elements.memoEditor.value;
                if (!memoText.trim()) {
copyMemoBtn.textContent;
                     elements.copyMemoBtn.textContent = "空です";
                     elements.copyMemo                     const originalText = elements.copyMemoBtn.textContent;
                     elements.copyMemoBtn.textContent = "空です";
                     elements.copyMemoBtn.disabled = true;
                     setTimeout(() => {
                         elements.copyMemoBtn.disabled = true;
                     setTimeout(() => {
                         elements.copyMemoBtn.textContent = originalText;
                         elements.copyMemoBtn.disabled = false;
                     }, 1500);
                    return;Btn.textContent = originalText;
                         elements.copyMemoBtn.disabled = false;
                     }, 1
                }
                try {
                    await navigator.clipboard.writeText(memoText);
                    const original500);
                    return;
                }
                try {
                    await navigator.clipboard.writeTextText = elements.copyMemoBtn.textContent;
                    elements.copyMemoBtn.textContent = "コピー完了";(memoText);
                    const originalText = elements.copyMemoBtn.textContent;
                    elements.copyMemo
                    elements.copyMemoBtn.disabled = true;
                    setTimeout(() => { elements.copyMemoBtn.textContent = originalBtn.textContent = "コピー完了";
                    elements.copyMemoBtn.disabled = true;
                    setTimeout(()Text; elements.copyMemoBtn.disabled = false; }, 1500);
                } catch ( => { elements.copyMemoBtn.textContent = originalText; elements.copyMemoBtn.disabled = false; },err) {
                    console.error("Copy memo error:", err);
                    const originalText = elements.copy 1500);
                } catch (err) {
                    console.error("Copy memo error:", err);
                    const originalText = elements.copyMemoBtn.textContent;
                    elements.copyMemoBtn.MemoBtn.textContent;
                    elements.copyMemoBtn.textContent = "コピー失敗";
                    elements.copyMemoBtn.disabled = true;
                    setTimeout(() => { elements.copyMemoBtn.textContent = originalText;textContent = "コピー失敗";
                    elements.copyMemoBtn.disabled = true;
                    setTimeout(() => { elements.copyMemoBtn.disabled = false; }, 2000);
                }
            },
 elements.copyMemoBtn.textContent = originalText; elements.copyMemoBtn.disabled = false; }, 200            async pasteIntoMemo() {
                try {
                    if (!navigator.clipboard || !navigator.clipboard.0);
                }
            },
            async pasteIntoMemo() {
                try {
                    if (!readText) {
                        const originalText = elements.pasteMemoBtn.textContent;
                        elements.pasteMemonavigator.clipboard || !navigator.clipboard.readText) {
                        const originalText = elements.pasteMemoBtnBtn.textContent = "非対応";
                        elements.pasteMemoBtn.disabled = true;
                        setTimeout(().textContent;
                        elements.pasteMemoBtn.textContent = "非対応";
                        elements.pasteMemoBtn.disabled = => { elements.pasteMemoBtn.textContent = originalText; elements.pasteMemoBtn.disabled = false; }, true;
                        setTimeout(() => { elements.pasteMemoBtn.textContent = originalText; elements.pasteMemoBtn 2000);
                        return;
                    }
                    const textToPaste = await navigator.clipboard.disabled = false; }, 2000);
                        return;
                    }
                    const textToPaste =.readText();
                    if (textToPaste) {
                        const currentText = elements.memoEditor. await navigator.clipboard.readText();
                    if (textToPaste) {
                        const currentText = elementsvalue;
                        const selectionStart = elements.memoEditor.selectionStart;
                        const selectionEnd = elements..memoEditor.value;
                        const selectionStart = elements.memoEditor.selectionStart;
                        const selectionmemoEditor.selectionEnd;
                        elements.memoEditor.value = currentText.substring(0, selectionStartEnd = elements.memoEditor.selectionEnd;
                        elements.memoEditor.value = currentText.substring() + textToPaste + currentText.substring(selectionEnd);
                        elements.memoEditor.selectionStart =0, selectionStart) + textToPaste + currentText.substring(selectionEnd);
                        elements.memoEditor elements.memoEditor.selectionEnd = selectionStart + textToPaste.length;
                        elements.memoEditor..selectionStart = elements.memoEditor.selectionEnd = selectionStart + textToPaste.length;
                        elementsfocus();
                        const originalText = elements.pasteMemoBtn.textContent;
                        elements.pasteMemoBtn..memoEditor.focus();
                        const originalText = elements.pasteMemoBtn.textContent;
                        elements.textContent = "貼付け完了";
                        elements.pasteMemoBtn.disabled = true;
                        setTimeout(() =>pasteMemoBtn.textContent = "貼付け完了";
                        elements.pasteMemoBtn.disabled = true;
 { elements.pasteMemoBtn.textContent = originalText; elements.pasteMemoBtn.disabled = false; },                         setTimeout(() => { elements.pasteMemoBtn.textContent = originalText; elements.pasteMemoBtn.disabled =1500);
                    } else {
                        const originalText = elements.pasteMemoBtn.textContent; false; }, 1500);
                    } else {
                        const originalText = elements.pasteMemo
                        elements.pasteMemoBtn.textContent = "空です";
                        elements.pasteMemoBtn.disabled =Btn.textContent;
                        elements.pasteMemoBtn.textContent = "空です";
                        elements.pasteMemo true;
                        setTimeout(() => { elements.pasteMemoBtn.textContent = originalText; elements.pasteMemoBtnBtn.disabled = true;
                        setTimeout(() => { elements.pasteMemoBtn.textContent = originalText; elements.disabled = false; }, 1500);
                    }
                } catch (err) {
                    console.pasteMemoBtn.disabled = false; }, 1500);
                    }
                } catch (err).error("Paste memo error:", err);
                    if (err.name === 'NotAllowedError' || err {
                    console.error("Paste memo error:", err);
                    if (err.name === 'NotAllowed.message.includes('Read permission denied')) {
                         const originalText = elements.pasteMemoBtn.textContent;Error' || err.message.includes('Read permission denied')) {
                         const originalText = elements.pasteMemo
                         elements.pasteMemoBtn.textContent = "許可エラー";
                         elements.pasteMemoBtn.disabled =Btn.textContent;
                         elements.pasteMemoBtn.textContent = "許可エラー";
                         elements.pasteMemo true;
                         setTimeout(() => { elements.pasteMemoBtn.textContent = originalText; elements.pasteMemoBtnBtn.disabled = true;
                         setTimeout(() => { elements.pasteMemoBtn.textContent = originalText; elements.disabled = false; }, 2000);
                    } else {
                          const originalText = elements.pasteMemo.pasteMemoBtn.disabled = false; }, 2000);
                    } else {
                          const originalText =Btn.textContent;
                          elements.pasteMemoBtn.textContent = "貼付け失敗";
                          elements.paste elements.pasteMemoBtn.textContent;
                          elements.pasteMemoBtn.textContent = "貼付け失敗";
MemoBtn.disabled = true;
                          setTimeout(() => { elements.pasteMemoBtn.textContent = originalText;                          elements.pasteMemoBtn.disabled = true;
                          setTimeout(() => { elements.pasteMemoBtn.textContent elements.pasteMemoBtn.disabled = false; }, 2000);
                    }
                }
 = originalText; elements.pasteMemoBtn.disabled = false; }, 2000);
                    }            },
            async confirmClearMemo() {
                if (!elements.memoEditor.value.trim()) {
                     
                }
            },
            async confirmClearMemo() {
                if (!elements.memoEditor.valueconst originalText = elements.deleteMemoBtn.textContent;
                     elements.deleteMemoBtn.textContent = "空です";
.trim()) {
                     const originalText = elements.deleteMemoBtn.textContent;
                     elements.deleteMemoBtn.textContent = "空です";
                     elements.deleteMemoBtn.disabled = true;
                     setTimeout(()                     elements.deleteMemoBtn.disabled = true;
                     setTimeout(() => {
                         elements.deleteMemoBtn.textContent = originalText;
                         elements.deleteMemoBtn.disabled = false;
                     }, 1500); => {
                         elements.deleteMemoBtn.textContent = originalText;
                         elements.deleteMemoBtn.disabled
                     return;
                }
                const confirmed = await uiUtils.showCustomConfirm("メモの内容を全て = false;
                     }, 1500);
                     return;
                }
                const confirmed =クリアしますか？\nこの操作は元に戻せません。");
                if (confirmed) {
                     await uiUtils.showCustomConfirm("メモの内容を全てクリアしますか？\nこの操作は元に戻せません。elements.memoEditor.value = '';
                }
            },
            toggleClipboardStack() {
                 if (");
                if (confirmed) {
                    elements.memoEditor.value = '';
                }
            },
            toggleClipboardStack() {
                 if (state.editingMessageIndex !== null) {
                     uiUtils.showCustomstate.editingMessageIndex !== null) {
                     uiUtils.showCustomAlert("メッセージ編集中はクリップボードスタAlert("メッセージ編集中はクリップボードスタックを開閉できません。");
                     return;
                 }
                 ックを開閉できません。");
                     return;
                 }
                 if (state.isEditingSystemPrompt) {
                     if (state.isEditingSystemPrompt) {
                     uiUtils.showCustomAlert("システムプロンプト編uiUtils.showCustomAlert("システムプロンプト編集中はクリップボードスタックを開閉できません。");
                     return集中はクリップボードスタックを開閉できません。");
                     return;
                 }

                state.isClipboardStack;
                 }

                state.isClipboardStackVisible = !state.isClipboardStackVisible;
                elements.clipboardStackArea.classList.toggle('hidden', !state.isClipboardStackVisible);

                if (state.Visible = !state.isClipboardStackVisible;
                elements.clipboardStackArea.classList.toggle('hidden', !state.isClipboardStackVisible);

                if (state.isClipboardStackVisible) {
                    elements.clipboardStackEditorisClipboardStackVisible) {
                    elements.clipboardStackEditor.value = state.clipboardStackContent;
                    .value = state.clipboardStackContent;
                    elements.clipboardStackEditor.focus();
                    elements.clipboardelements.clipboardStackEditor.focus();
                    elements.clipboardStackEditor.scrollTop = elements.clipboardStackEditor.StackEditor.scrollTop = elements.clipboardStackEditor.scrollHeight;
                }
            },
            async copyClipboardscrollHeight;
                }
            },
            async copyClipboardStackText() {
                const stackText = elementsStackText() {
                const stackText = elements.clipboardStackEditor.value;
                if (!stackText.clipboardStackEditor.value;
                if (!stackText.trim()) {
                     const originalText = elements.copyClipboard.trim()) {
                     const originalText = elements.copyClipboardStackBtn.textContent;
                     elements.copyStackBtn.textContent;
                     elements.copyClipboardStackBtn.textContent = "空です";
                     elements.copyClipboardClipboardStackBtn.textContent = "空です";
                     elements.copyClipboardStackBtn.disabled = true;
StackBtn.disabled = true;
                     setTimeout(() => {
                         elements.copyClipboardStackBtn.textContent = originalText;                     setTimeout(() => {
                         elements.copyClipboardStackBtn.textContent = originalText;
                         elements.copyClipboardStackBtn
                         elements.copyClipboardStackBtn.disabled = false;
                     }, 1500);
                    return;.disabled = false;
                     }, 1500);
                    return;
                }
                try {

                }
                try {
                    await navigator.clipboard.writeText(stackText);
                    const original                    await navigator.clipboard.writeText(stackText);
                    const originalText = elements.copyClipboardStackBtnText = elements.copyClipboardStackBtn.textContent;
                    elements.copyClipboardStackBtn.textContent = "コピー.textContent;
                    elements.copyClipboardStackBtn.textContent = "コピー完了";
                    elements.copyClipboard完了";
                    elements.copyClipboardStackBtn.disabled = true;
                    setTimeout(() => { elements.copyClipboardStackStackBtn.disabled = true;
                    setTimeout(() => { elements.copyClipboardStackBtn.textContent = originalText; elementsBtn.textContent = originalText; elements.copyClipboardStackBtn.disabled = false; }, 1500.copyClipboardStackBtn.disabled = false; }, 1500);
                } catch (err));
                } catch (err) {
                    console.error("Copy clipboard stack error:", err);
                    const originalText {
                    console.error("Copy clipboard stack error:", err);
                    const originalText = elements.copyClipboardStackBtn = elements.copyClipboardStackBtn.textContent;
                    elements.copyClipboardStackBtn.textContent = "コピー失敗.textContent;
                    elements.copyClipboardStackBtn.textContent = "コピー失敗";
                    elements.copyClipboard";
                    elements.copyClipboardStackBtn.disabled = true;
                    setTimeout(() => { elements.copyClipboardStackBtn.disabled = true;
                    setTimeout(() => { elements.copyClipboardStackBtn.textContent = originalTextStackBtn.textContent = originalText; elements.copyClipboardStackBtn.disabled = false; }, 200; elements.copyClipboardStackBtn.disabled = false; }, 2000);
                }
            0);
                }
            },
            async pasteIntoClipboardStack() {
                try {
                    if},
            async pasteIntoClipboardStack() {
                try {
                    if (!navigator.clipboard || !navigator (!navigator.clipboard || !navigator.clipboard.readText) {
                        const originalText = elements.pasteClipboard.clipboard.readText) {
                        const originalText = elements.pasteClipboardStackBtn.textContent;
                        StackBtn.textContent;
                        elements.pasteClipboardStackBtn.textContent = "非対応";
                        elements.elements.pasteClipboardStackBtn.textContent = "非対応";
                        elements.pasteClipboardStackBtn.disabled = true;
pasteClipboardStackBtn.disabled = true;
                        setTimeout(() => { elements.pasteClipboardStackBtn.textContent =                        setTimeout(() => { elements.pasteClipboardStackBtn.textContent = originalText; elements.pasteClipboardStackBtn. originalText; elements.pasteClipboardStackBtn.disabled = false; }, 2000);
                        return;
                    disabled = false; }, 2000);
                        return;
                    }
                    const textToPaste}
                    const textToPaste = await navigator.clipboard.readText();
                    if (textToPaste) {
                        const currentText = elements.clipboardStackEditor.value;
                        const separator = currentText.length = await navigator.clipboard.readText();
                    if (textToPaste) {
                        const currentText = elements.clipboardStackEditor.value;
                        const separator = currentText.length > 0 && !currentText.endsWith('\n > 0 && !currentText.endsWith('\n\n') ? "\n\n" : "";
                        elements.clipboard\n') ? "\n\n" : "";
                        elements.clipboardStackEditor.value += separator + textStackEditor.value += separator + textToPaste;
                        elements.clipboardStackEditor.scrollTop = elements.clipboardStackEditorToPaste;
                        elements.clipboardStackEditor.scrollTop = elements.clipboardStackEditor.scrollHeight;
                        elements.scrollHeight;
                        elements.clipboardStackEditor.focus();
                        state.clipboardStackContent = elements.clipboard.clipboardStackEditor.focus();
                        state.clipboardStackContent = elements.clipboardStackEditor.value;
StackEditor.value;
                        const originalText = elements.pasteClipboardStackBtn.textContent;
                        elements.                        const originalText = elements.pasteClipboardStackBtn.textContent;
                        elements.pasteClipboardStackBtn.textContentpasteClipboardStackBtn.textContent = "貼付け完了";
                        elements.pasteClipboardStackBtn.disabled = true = "貼付け完了";
                        elements.pasteClipboardStackBtn.disabled = true;
                        setTimeout(() =>;
                        setTimeout(() => { elements.pasteClipboardStackBtn.textContent = originalText; elements.pasteClipboardStack { elements.pasteClipboardStackBtn.textContent = originalText; elements.pasteClipboardStackBtn.disabled = false;Btn.disabled = false; }, 1500);
                    } else {
                        const originalText = }, 1500);
                    } else {
                        const originalText = elements.pasteClipboardStackBtn elements.pasteClipboardStackBtn.textContent;
                        elements.pasteClipboardStackBtn.textContent = "空です";.textContent;
                        elements.pasteClipboardStackBtn.textContent = "空です";
                        elements.pasteClipboard
                        elements.pasteClipboardStackBtn.disabled = true;
                        setTimeout(() => { elements.pasteClipboardStackStackBtn.disabled = true;
                        setTimeout(() => { elements.pasteClipboardStackBtn.textContent = originalTextBtn.textContent = originalText; elements.pasteClipboardStackBtn.disabled = false; }, 1500; elements.pasteClipboardStackBtn.disabled = false; }, 1500);
                    }
                );
                    }
                } catch (err) {
                    console.error("Paste into clipboard stack error:", err} catch (err) {
                    console.error("Paste into clipboard stack error:", err);
                    if (err);
                    if (err.name === 'NotAllowedError' || err.message.includes('Read permission denied.name === 'NotAllowedError' || err.message.includes('Read permission denied')) {
                         const original')) {
                         const originalText = elements.pasteClipboardStackBtn.textContent;
                         elements.pasteClipboardStackBtn.textContentText = elements.pasteClipboardStackBtn.textContent;
                         elements.pasteClipboardStackBtn.textContent = "許可 = "許可エラー";
                         elements.pasteClipboardStackBtn.disabled = true;
                         setTimeout(() => { elements.pasteエラー";
                         elements.pasteClipboardStackBtn.disabled = true;
                         setTimeout(() => { elements.pasteClipboardStackBtn.textContent = originalText; elements.pasteClipboardStackBtn.disabled = false; }, 20ClipboardStackBtn.textContent = originalText; elements.pasteClipboardStackBtn.disabled = false; }, 2000);
                    } else {
                          const originalText = elements.pasteClipboardStackBtn.textContent;
00);
                    } else {
                          const originalText = elements.pasteClipboardStackBtn.textContent;
                          elements.pasteClipboardStackBtn.textContent = "貼付け失敗";
                          elements.pasteClipboardStackBtn.                          elements.pasteClipboardStackBtn.textContent = "貼付け失敗";
                          elements.pasteClipboardStackBtn.disabled = true;
                          setTimeout(() => { elements.pasteClipboardStackBtn.textContent = originalText; elements.disabled = true;
                          setTimeout(() => { elements.pasteClipboardStackBtn.textContent = originalText; elements.pasteClipboardStackBtn.disabled = false; }, 2000);
                    }
                }
            pasteClipboardStackBtn.disabled = false; }, 2000);
                    }
                }
            },
            async confirmClearClipboardStack() {
                if (!elements.clipboardStackEditor.value.trim()) {
                     },
            async confirmClearClipboardStack() {
                if (!elements.clipboardStackEditor.value.trim()) {
                     const originalText = elements.deleteClipboardStackBtn.textContent;
                     elements.deleteClipboardStackBtn.textContent =const originalText = elements.deleteClipboardStackBtn.textContent;
                     elements.deleteClipboardStackBtn.textContent = "空です "空です";
                     elements.deleteClipboardStackBtn.disabled = true;
                     setTimeout(() => {
";
                     elements.deleteClipboardStackBtn.disabled = true;
                     setTimeout(() => {
                         elements.deleteClipboard                         elements.deleteClipboardStackBtn.textContent = originalText;
                         elements.deleteClipboardStackBtn.disabled =StackBtn.textContent = originalText;
                         elements.deleteClipboardStackBtn.disabled = false;
                     }, 15 false;
                     }, 1500);
                     return;
                }
                const confirmed = await00);
                     return;
                }
                const confirmed = await uiUtils.showCustomConfirm("クリ uiUtils.showCustomConfirm("クリップボードスタックの内容を全てクリアしますか？");
                if (confirmed) {ップボードスタックの内容を全てクリアしますか？");
                if (confirmed) {
                    elements.clipboardStackEditor.
                    elements.clipboardStackEditor.value = '';
                    state.clipboardStackContent = '';
                }
value = '';
                    state.clipboardStackContent = '';
                }
            },
            scrollToTop() {            },
            scrollToTop() {
                requestAnimationFrame(() => {
                    const mainContent = elements.chat
                requestAnimationFrame(() => {
                    const mainContent = elements.chatScreen.querySelector('.main-content');
                    ifScreen.querySelector('.main-content');
                    if (mainContent) {
                        mainContent.scrollTop =  (mainContent) {
                        mainContent.scrollTop = 0;
                    }
                });
            },0;
                    }
                });
            },
            scrollToBottom() {
                requestAnimationFrame(() => {
            scrollToBottom() {
                requestAnimationFrame(() => {
                    const mainContent = elements.chatScreen.
                    const mainContent = elements.chatScreen.querySelector('.main-content');
                    if (mainContent)querySelector('.main-content');
                    if (mainContent) {
                        mainContent.scrollTop = mainContent. {
                        mainContent.scrollTop = mainContent.scrollHeight;
                    }
                });
            },
            scrollHeight;
                    }
                });
            },
            async pasteToUserInput() {
                const button =async pasteToUserInput() {
                const button = elements.pasteToInputBtn;
                const originalTextContent = button. elements.pasteToInputBtn;
                const originalTextContent = button.textContent;
                const originalTitle =textContent;
                const originalTitle = button.title;

                try {
                    if (!navigator.clipboard || button.title;

                try {
                    if (!navigator.clipboard || !navigator.clipboard.readText) !navigator.clipboard.readText) {
                        button.textContent = "!";
                        button.title = " {
                        button.textContent = "!";
                        button.title = "クリップボードAPI非対応";
クリップボードAPI非対応";
                        button.disabled = true;
                        setTimeout(() => {
                            button                        button.disabled = true;
                        setTimeout(() => {
                            button.textContent = originalTextContent;
.textContent = originalTextContent;
                            button.title = originalTitle;
                            button.disabled = false;                            button.title = originalTitle;
                            button.disabled = false;
                        }, 2000
                        }, 2000);
                        return;
                    }
                    const textToPaste = await navigator.clipboard);
                        return;
                    }
                    const textToPaste = await navigator.clipboard.readText();
                    if (.readText();
                    if (textToPaste) {
                        const currentText = elements.userInput.valuetextToPaste) {
                        const currentText = elements.userInput.value;
                        const selectionStart = elements;
                        const selectionStart = elements.userInput.selectionStart;
                        const selectionEnd = elements.userInput..userInput.selectionStart;
                        const selectionEnd = elements.userInput.selectionEnd;
                        elements.userInputselectionEnd;
                        elements.userInput.value = currentText.substring(0, selectionStart) + textTo.value = currentText.substring(0, selectionStart) + textToPaste + currentText.substring(selectionPaste + currentText.substring(selectionEnd);
                        elements.userInput.selectionStart = elements.userInput.selectionEnd);
                        elements.userInput.selectionStart = elements.userInput.selectionEnd = selectionStart + textToPasteEnd = selectionStart + textToPaste.length;
                        elements.userInput.focus();
                        uiUtils..length;
                        elements.userInput.focus();
                        uiUtils.adjustTextareaHeight();
                        uiadjustTextareaHeight();
                        uiUtils.updateAttachmentBadgeVisibility();

                        button.textContent = "✓";Utils.updateAttachmentBadgeVisibility();

                        button.textContent = "✓";
                        button.title = "貼り付け完了";
                        setTimeout(() => {
                            button.textContent = originalTextContent;
                            button.title = original
                        button.title = "貼り付け完了";
                        setTimeout(() => {
                            button.textContent = originalTextContent;
                            button.title = originalTitle;
                        }, 1500);
                    } else {Title;
                        }, 1500);
                    } else {
                        button.textContent = "空
                        button.textContent = "空";
                        button.title = "クリップボードは空です";
";
                        button.title = "クリップボードは空です";
                        setTimeout(() => {
                            button                        setTimeout(() => {
                            button.textContent = originalTextContent;
                            button.title = originalTitle;.textContent = originalTextContent;
                            button.title = originalTitle;
                        }, 1500
                        }, 1500);
                    }
                } catch (err) {
                    console.error(");
                    }
                } catch (err) {
                    console.error("Paste to user input error:", err);Paste to user input error:", err);
                    if (err.name === 'NotAllowedError' || err.
                    if (err.name === 'NotAllowedError' || err.message.includes('Read permission denied'))message.includes('Read permission denied')) {
                        button.textContent = "!";
                        button.title = " {
                        button.textContent = "!";
                        button.title = "クリップボードの許可なし";
クリップボードの許可なし";
                    } else {
                        button.textContent = "X";
                        button                    } else {
                        button.textContent = "X";
                        button.title = "貼り付け失敗";
                    }
                    button.disabled = true;
                    setTimeout(() => {
                        button.textContent = original.title = "貼り付け失敗";
                    }
                    button.disabled = true;
                    setTimeout(() => {
                        button.textContent = originalTextContent;
                        button.title = originalTitle;
                        button.TextContent;
                        button.title = originalTitle;
                        button.disabled = false;
                    }, disabled = false;
                    }, 2000);
                }
            },
            async confirmStart2000);
                }
            },
            async confirmStartNewChat() {
                if (NewChat() {
                if (state.isSending) {
                    const confirmed = await uiUtils.showstate.isSending) {
                    const confirmed = await uiUtils.showCustomConfirm("送信中です。中断してCustomConfirm("送信中です。中断して新規チャットを開始しますか？");
                    if (!confirmed) return;新規チャットを開始しますか？");
                    if (!confirmed) return;
                    this.abortRequest();

                    this.abortRequest();
                }
                if (state.editingMessageIndex !== null) {
                }
                if (state.editingMessageIndex !== null) {
                    const confirmed = await uiUtils.                    const confirmed = await uiUtils.showCustomConfirm("編集中です。変更を破棄して新規チャットshowCustomConfirm("編集中です。変更を破棄して新規チャットを開始しますか？");
                    ifを開始しますか？");
                    if (!confirmed) return;
                    const msgEl = elements.messageContainer. (!confirmed) return;
                    const msgEl = elements.messageContainer.querySelector(`.message[data-index="${querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                    this.cancelEditMessage(statestate.editingMessageIndex}"]`);
                    this.cancelEditMessage(state.editingMessageIndex, msgEl);.editingMessageIndex, msgEl);
                }
                if (state.isEditingSystemPrompt) {

                }
                if (state.isEditingSystemPrompt) {
                    const confirmed = await uiUtils.                    const confirmed = await uiUtils.showCustomConfirm("システムプロンプト編集中です。変更を破棄して新規チャットを開始しますか？");
                    if (!confirmed) return;
                    this.cancelEditSystemshowCustomConfirm("システムプロンプト編集中です。変更を破棄して新規チャットを開始しますか？");
                    if (!confirmed) return;
                    this.cancelEditSystemPrompt();
                }
                ifPrompt();
                }
                if (state.pendingAttachments.length > 0) {
                    const confirmed (state.pendingAttachments.length > 0) {
                    const confirmedAttach = await uiUtils.showCustomConfirmAttach = await uiUtils.showCustomConfirm("添付準備中のファイルがあります。破棄して新規チャットを開始しますか？");("添付準備中のファイルがあります。破棄して新規チャットを開始しますか？");
                    if (!confirmedAttach) return
                    if (!confirmedAttach) return;
                    state.pendingAttachments = [];
                    uiUtils.updateAttachment;
                    state.pendingAttachments = [];
                    uiUtils.updateAttachmentBadgeVisibility();
                }

                BadgeVisibility();
                }

                if ((state.currentMessages.length > 0 || state.currentSystemPrompt)if ((state.currentMessages.length > 0 || state.currentSystemPrompt) && state.currentChatId) { && state.currentChatId) {
                    try {
                        await dbUtils.saveChat();
                    }
                    try {
                        await dbUtils.saveChat();
                    } catch (error) {
                        console catch (error) {
                        console.error("Error saving current chat before new chat:", error);
                        const conf.error("Error saving current chat before new chat:", error);
                        const conf = await uiUtils.showCustomConfirm = await uiUtils.showCustomConfirm("現在のチャットの保存に失敗しました。新規チャットを開始しますか？");("現在のチャットの保存に失敗しました。新規チャットを開始しますか？");
                        if (!conf) return;
                        if (!conf) return;
                    }
                }
                this.startNewChat();
                
                    }
                }
                this.startNewChat();
                uiUtils.showScreen('chat');uiUtils.showScreen('chat');
            },
            startNewChat() {
                state.currentChat
            },
            startNewChat() {
                state.currentChatId = null;
                state.Id = null;
                state.currentMessages = [];
                state.currentSystemPrompt = state.settings.currentMessages = [];
                state.currentSystemPrompt = state.settings.systemPrompt;
                state.pendingsystemPrompt;
                state.pendingAttachments = [];
                state.isMemoVisible = false;
                elementsAttachments = [];
                state.isMemoVisible = false;
                elements.memoArea.classList.add('.memoArea.classList.add('hidden');
                elements.memoEditor.value = '';
                state.hidden');
                elements.memoEditor.value = '';
                state.isClipboardStackVisible = false;
isClipboardStackVisible = false;
                elements.clipboardStackArea.classList.add('hidden');
                state                elements.clipboardStackArea.classList.add('hidden');
                state.areAllMessagesHidden = false;.areAllMessagesHidden = false;
                uiUtils.updateToggleAllContentButton();
                state.message
                uiUtils.updateToggleAllContentButton();
                state.messageCollapsedStates.clear();
                uiCollapsedStates.clear();
                uiUtils.updateSystemPromptUI();
                uiUtils.renderChatMessages();Utils.updateSystemPromptUI();
                uiUtils.renderChatMessages();
                uiUtils.updateChatTitle
                uiUtils.updateChatTitle();
                elements.userInput.value = '';
                uiUtils.adjust();
                elements.userInput.value = '';
                uiUtils.adjustTextareaHeight();
                uiUtilsTextareaHeight();
                uiUtils.setSendingState(false);
                uiUtils.updateAttachmentBadgeVisibility();
                .setSendingState(false);
                uiUtils.updateAttachmentBadgeVisibility();
                if (state.settingsif (state.settings.autoScrollOnNewMessage) {
                    uiUtils.scrollToBottom();
                }.autoScrollOnNewMessage) {
                    uiUtils.scrollToBottom();
                }
            },
            
            },
            async loadChat(id) {
                if (state.isSending) {
                    async loadChat(id) {
                if (state.isSending) {
                    const confirmed = await uiconst confirmed = await uiUtils.showCustomConfirm("送信中です。中断して別のチャットを読み込みますかUtils.showCustomConfirm("送信中です。中断して別のチャットを読み込みますか？");
                    if (!confirmed)？");
                    if (!confirmed) return;
                    this.abortRequest();
                }
                if ( return;
                    this.abortRequest();
                }
                if (state.editingMessageIndex !== null)state.editingMessageIndex !== null) {
                    const confirmed = await uiUtils.showCustomConfirm("編集中 {
                    const confirmed = await uiUtils.showCustomConfirm("編集中です。変更を破棄して別のです。変更を破棄して別のチャットを読み込みますか？");
                    if (!confirmed) returnチャットを読み込みますか？");
                    if (!confirmed) return;
                    const msgEl = elements;
                    const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessage.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                    this.cancelIndex}"]`);
                    this.cancelEditMessage(state.editingMessageIndex, msgEl);
                }
EditMessage(state.editingMessageIndex, msgEl);
                }
                if (state.isEditingSystem                if (state.isEditingSystemPrompt) {
                    const confirmed = await uiUtils.showCustomConfirm("Prompt) {
                    const confirmed = await uiUtils.showCustomConfirm("システムプロンプト編集中です。システムプロンプト編集中です。変更を破棄して別のチャットを読み込みますか？");
                    if変更を破棄して別のチャットを読み込みますか？");
                    if (!confirmed) return;
                    this (!confirmed) return;
                    this.cancelEditSystemPrompt();
                }
                if (state.pending.cancelEditSystemPrompt();
                }
                if (state.pendingAttachments.length > 0) {Attachments.length > 0) {
                    const confirmedAttach = await uiUtils.showCustomConfirm("添付準備中の
                    const confirmedAttach = await uiUtils.showCustomConfirm("添付準備中のファイルがあります。破棄して別のチャットをファイルがあります。破棄して別のチャットを読み込みますか？");
                    if (!confirmedAttach) return;
読み込みますか？");
                    if (!confirmedAttach) return;
                    state.pendingAttachments = [];
                    state.pendingAttachments = [];
                    uiUtils.updateAttachmentBadgeVisibility();
                }

                try {
                    const                    uiUtils.updateAttachmentBadgeVisibility();
                }

                try {
                    const chat = await dbUtils.getChat chat = await dbUtils.getChat(id);
                    if (chat) {
                        state.currentChat(id);
                    if (chat) {
                        state.currentChatId = chat.id;
                        Id = chat.id;
                        state.currentMessages = chat.messages?.map(msg => ({
                            state.currentMessages = chat.messages?.map(msg => ({
                            ...msg,
                            attachments: msg...msg,
                            attachments: msg.attachments || []
                        })) || [];

                        let needsSave = false.attachments || []
                        })) || [];

                        let needsSave = false;
                        const groupIds = new;
                        const groupIds = new Set(state.currentMessages.filter(m => m.siblingGroupId). Set(state.currentMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupIdmap(m => m.siblingGroupId));
                        groupIds.forEach(gid => {
                            const siblings =));
                        groupIds.forEach(gid => {
                            const siblings = state.currentMessages.filter(m state.currentMessages.filter(m => m.siblingGroupId === gid);
                            const selected = siblings.filter(m => => m.siblingGroupId === gid);
                            const selected = siblings.filter(m => m.isSelected);
                            if ( m.isSelected);
                            if (selected.length === 0 && siblings.length > 0) {
selected.length === 0 && siblings.length > 0) {
                                siblings[siblings.length -                                 siblings[siblings.length - 1].isSelected = true;
                                needsSave = true;
                            }1].isSelected = true;
                                needsSave = true;
                            } else if (selected.length >  else if (selected.length > 1) {
                                selected.slice(0, -1).forEach(1) {
                                selected.slice(0, -1).forEach(m => m.isSelected = false);m => m.isSelected = false);
                                needsSave = true;
                            }
                        });

                        state
                                needsSave = true;
                            }
                        });

                        state.currentSystemPrompt = chat.systemPrompt !==.currentSystemPrompt = chat.systemPrompt !== undefined ? chat.systemPrompt : state.settings.systemPrompt; undefined ? chat.systemPrompt : state.settings.systemPrompt;
                        state.pendingAttachments = [];
                        
                        state.pendingAttachments = [];
                        state.areAllMessagesHidden = false;
                        uiUtils.state.areAllMessagesHidden = false;
                        uiUtils.updateToggleAllContentButton();
                        uiUtils.updateSystemupdateToggleAllContentButton();
                        uiUtils.updateSystemPromptUI();
                        state.messageCollapsedStates.PromptUI();
                        state.messageCollapsedStates.clear();
                        if (state.settings.persistMessageCollapseclear();
                        if (state.settings.persistMessageCollapseState && chat.collapsedStates) {
                            ObjectState && chat.collapsedStates) {
                            Object.entries(chat.collapsedStates).forEach(([idx, is.entries(chat.collapsedStates).forEach(([idx, isCollapsed]) => {
                                state.messageCollapsedStates.setCollapsed]) => {
                                state.messageCollapsedStates.set(parseInt(idx, 10), isCollapsed(parseInt(idx, 10), isCollapsed);
                            });
                        }
                        uiUtils.renderChatMessages(););
                            });
                        }
                        uiUtils.renderChatMessages();
                        uiUtils.updateChatTitle
                        uiUtils.updateChatTitle(chat.title);
                        elements.userInput.value = '';
                        uiUtils(chat.title);
                        elements.userInput.value = '';
                        uiUtils.adjustTextareaHeight();
                        uiUtils.setSendingState(false);
                        uiUtils.updateAttachmentBadgeVisibility();
                        elements.memo.adjustTextareaHeight();
                        uiUtils.setSendingState(false);
                        uiUtils.updateAttachmentBadgeVisibility();
                        elements.memoEditor.value = '';
                        if (needsSave) {
                            awaitEditor.value = '';
                        if (needsSave) {
                            await dbUtils.saveChat();
                         dbUtils.saveChat();
                        }
                        history.replaceState({ screen: 'chat' }, '', '#}
                        history.replaceState({ screen: 'chat' }, '', '#chat');
                        state.currentScreenchat');
                        state.currentScreen = 'chat';
                        if (state.settings.autoScrollOnNew = 'chat';
                        if (state.settings.autoScrollOnNewMessage && state.currentMessages.lengthMessage && state.currentMessages.length > 0) {
                            uiUtils.scrollToBottom();
                        } > 0) {
                            uiUtils.scrollToBottom();
                        }
                    } else {
                        await
                    } else {
                        await uiUtils.showCustomAlert("チャット履歴が見つかりませんでした。"); uiUtils.showCustomAlert("チャット履歴が見つかりませんでした。");
                        this.startNewChat();
                        this.startNewChat();
                        uiUtils.showScreen('chat');
                    }
                }
                        uiUtils.showScreen('chat');
                    }
                } catch (error) {
                    console catch (error) {
                    console.error("Error loading chat:", error);
                    await uiUtils.show.error("Error loading chat:", error);
                    await uiUtils.showCustomAlert(`チャットの読み込みCustomAlert(`チャットの読み込みエラー: ${error}`);
                    this.startNewChat();
                    uiエラー: ${error}`);
                    this.startNewChat();
                    uiUtils.showScreen('chat');
                }
            },
            async duplicateChat(id) {
                if (state.isSending) {Utils.showScreen('chat');
                }
            },
            async duplicateChat(id) {
                if (state.isSending) { const conf = await uiUtils.showCustomConfirm("送信中です。中断して const conf = await uiUtils.showCustomConfirm("送信中です。中断してチャットを複製しますか？");チャットを複製しますか？"); if (!conf) return; this.abortRequest(); }
                if (state.editing if (!conf) return; this.abortRequest(); }
                if (state.editingMessageIndex !== null) { constMessageIndex !== null) { const conf = await uiUtils.showCustomConfirm("編集中です。変更を破棄してチャ conf = await uiUtils.showCustomConfirm("編集中です。変更を破棄してチャットを複製しますか？");ットを複製しますか？"); if (!conf) return; const msgEl = elements.messageContainer.querySelector(`.message[ if (!conf) return; const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`); this.cancelEditMessage(state.editingMessageIndex, msgEl); }
                ifdata-index="${state.editingMessageIndex}"]`); this.cancelEditMessage(state.editingMessageIndex, msgEl); (state.isEditingSystemPrompt) { const conf = await uiUtils.showCustomConfirm("システムプロンプト }
                if (state.isEditingSystemPrompt) { const conf = await uiUtils.showCustomConfirm("システムプロンプト編集中です。変更を破棄してチャットを複製しますか？"); if (!conf編集中です。変更を破棄してチャットを複製しますか？"); if (!conf) return; this) return; this.cancelEditSystemPrompt(); }
                if ((state.currentMessages.length > 0 || state..cancelEditSystemPrompt(); }
                if ((state.currentMessages.length > 0 || state.currentSystemPrompt)currentSystemPrompt) && state.currentChatId && state.currentChatId !== id) { try { await db && state.currentChatId && state.currentChatId !== id) { try { await dbUtils.saveChatUtils.saveChat(); } catch (error) { console.error("Error saving current chat before duplicate:", error); const(); } catch (error) { console.error("Error saving current chat before duplicate:", error); const conf = await uiUtils.showCustomConfirm("現在のチャット保存に失敗しました。複製を続行しますか？"); if (!conf) conf = await uiUtils.showCustomConfirm("現在のチャット保存に失敗しました。複製を続行しますか？"); if (!conf) return; } }
                if (state.pendingAttachments.length > 0) {
 return; } }
                if (state.pendingAttachments.length > 0) {
                    const confirmedAttach                    const confirmedAttach = await uiUtils.showCustomConfirm("添付準備中のファイルがあります。破棄してチャットを複製 = await uiUtils.showCustomConfirm("添付準備中のファイルがあります。破棄してチャットを複製しますか？");しますか？");
                    if (!confirmedAttach) return;
                    state.pendingAttachments = [];
                }
                    if (!confirmedAttach) return;
                    state.pendingAttachments = [];
                }

                try {
                    const

                try {
                    const chat = await dbUtils.getChat(id);
                    if (chat) {
                         chat = await dbUtils.getChat(id);
                    if (chat) {
                        const originalTitle = chat.title || "無題のチャット";
                        const newTitle = originalTitle.replace(new RegExpconst originalTitle = chat.title || "無題のチャット";
                        const newTitle = originalTitle.(DUPLICATE_SUFFIX.replace(/([().])/g, '\\$1') + '$'), '').trim()replace(new RegExp(DUPLICATE_SUFFIX.replace(/([().])/g, '\\$1') + '$'), '').trim() + DUPLICATE_SUFFIX;

                        const groupIdMap = new Map();
                        const duplicatedMessages = []; + DUPLICATE_SUFFIX;

                        const groupIdMap = new Map();
                        const duplicatedMessages = [];



                        (chat.messages || []).forEach(msg => {
                            const newMsg = JSON.parse(                        (chat.messages || []).forEach(msg => {
                            const newMsg = JSON.parse(JSONJSON.stringify(msg));
                            newMsg.attachments = msg.attachments ? JSON.parse(JSON.stringify(msg.stringify(msg));
                            newMsg.attachments = msg.attachments ? JSON.parse(JSON.stringify(msg.attachments)) : [];
                            newMsg.isCascaded = msg.isCascaded ?? false;
.attachments)) : [];
                            newMsg.isCascaded = msg.isCascaded ?? false;
                                                        newMsg.isSelected = msg.isSelected ?? false;

                            if (msg.siblingGroupId) {
                               newMsg.isSelected = msg.isSelected ?? false;

                            if (msg.siblingGroupId) {
                                if if (!groupIdMap.has(msg.siblingGroupId)) {
                                    groupIdMap.set(msg.siblingGroupId, ` (!groupIdMap.has(msg.siblingGroupId)) {
                                    groupIdMap.set(msg.siblingGroupIddup-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`);, `dup-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`);
                                }
                                newMsg.siblingGroupId = groupIdMap.get(msg.siblingGroupId);
                            }
                                }
                                newMsg.siblingGroupId = groupIdMap.get(msg.siblingGroupId);
                            } else {
                                delete newMsg.siblingGroupId;
                            }
                            duplicatedMessages.push(newMsg); else {
                                delete newMsg.siblingGroupId;
                            }
                            duplicatedMessages.push(newMsg);
                        });

                        const newGroupIds = new Set(duplicatedMessages.filter(m => m.siblingGroupId).map(
                        });

                        const newGroupIds = new Set(duplicatedMessages.filter(m => m.siblingGroupId).m => m.siblingGroupId));
                        newGroupIds.forEach(gid => {
                            const siblings = duplicatedmap(m => m.siblingGroupId));
                        newGroupIds.forEach(gid => {
                            const siblingsMessages.filter(m => m.siblingGroupId === gid);
                            siblings.forEach((m, idx) => = duplicatedMessages.filter(m => m.siblingGroupId === gid);
                            siblings.forEach((m, idx) => {
                                m.isSelected = (idx === siblings.length - 1);
                            });
                        });

 {
                                m.isSelected = (idx === siblings.length - 1);
                            });
                        });

                        const newChatData = {
                            messages: duplicatedMessages,
                            systemPrompt: chat.systemPrompt ||                        const newChatData = {
                            messages: duplicatedMessages,
                            systemPrompt: chat.systemPrompt || '',
                            updatedAt: Date.now(),
                            createdAt: Date.now(),
                            title: newTitle '',
                            updatedAt: Date.now(),
                            createdAt: Date.now(),
                            title: newTitle
                        };

                        if (state.settings.persistMessageCollapseState && chat.collapsedStates) {
                            
                        };

                        if (state.settings.persistMessageCollapseState && chat.collapsedStates) {
                            newChatData.collapsedStates = { ...chat.collapsedStates };
                        }

                        const newChatId =newChatData.collapsedStates = { ...chat.collapsedStates };
                        }

                        const newChatId = await new Promise((resolve, reject) => {
                            const store = dbUtils._getStore(CHATS_ await new Promise((resolve, reject) => {
                            const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                            const request = store.add(newChatData);
                            request.onsSTORE, 'readwrite');
                            const request = store.add(newChatData);
                            request.onsuccess = (event) => resolve(event.target.result);
                            request.onerror = (event)uccess = (event) => resolve(event.target.result);
                            request.onerror = (event) => reject(event.target.error);
                        });

                        if (state.currentScreen === 'history') {
                            uiUtils.renderHistoryList();
                        } else {
                            await uiUtils.showCustomAlert(`チャット「${newTitle}」を複製しました。`);
                        }
                    } else {
                        await uiUtils.showCustomAlert("複製元のチャットが見つかりません。");
                    }
                } catch (error) {
                    console.error("Error duplicating chat:", error);
                    await uiUtils.showCustomAlert(`チャット複製エラー: ${error}`);
                }
            },
            async exportChat(chatId, chatTitle) {
                 const confirmed = await uiUtils.showCustomConfirm(`チャット「${chatTitle || 'この履歴'}」をテキスト出力しますか？`);
                 if (!confirmed) return;

                 try {
                     const chat = await dbUtils.getChat(chatId);
                     if (!chat || ((!chat.messages || chat.messages.length === 0) && !chat.systemPrompt)) {
                         await uiUtils.showCustomAlert("チャットデータが空です。");
                         return;
                     }

                     let exportText = '';
                     if (chat.systemPrompt) {
                         exportText += `<|#|system|#|>\n${chat.systemPrompt}\n<|#|/system|#|>\n\n`;
                     }
                     if (chat.messages) {
                         chat.messages.forEach(msg => {
                             if (msg.role === 'user' || msg.role === 'model') {
                                 let attributes = '';
                                 if (msg.role === 'model') {
                                     if (msg.isCascaded) attributes += ' isCascaded';
                                     if (msg.isSelected) attributes += ' isSelected';
                                 }
                                 if (msg.role === 'user' && msg.attachments && msg.attachments.length > 0) {
                                     const fileNames = msg.attachments.map(a => a.name).join(';');
                                     attributes += ` attachments="${fileNames.replace(/"/g, '&quot;')}"`;
                                 }
                                 exportText += `<|#|${msg.role}|#|${attributes.trim()}>\n${msg.content}\n<|#|/${msg.role}|#|>\n\n`;
                             }
                         });
                     }

                     const blob = new Blob([exportText.trim()], { type: 'text/plain;charset=utf-8' });
                     const url = URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     const safeTitle = (chatTitle || `chat_${chatId}_export`).replace(/[<>:"/\\|?*\s]/g, '_');
                     a.href = url;
                     a.download = `${safeTitle}.txt`;
                     document.body.appendChild(a);
                     a.click();
                     document.body.removeChild(a);
                     URL.revokeObjectURL(url);
                 } catch (error) {
                     console.error("Export chat error:", error);
                     await uiUtils.showCustomAlert(`エクスポートエラー: ${error}`);
                 }
            },
            async confirmDeleteCurrentSession() {
                if (!state.currentChatId && state.currentMessages.length === 0 && !state.currentSystemPrompt) {
                    await uiUtils.showCustomAlert("削除するチャットがありません（新規チャット状態です）。");
                    return;
                }
                if (state.isSending) {
                    await uiUtils.showCustomAlert("送信中です。完了後に再度お試しください。");
                    return;
                }
                if (state.editingMessageIndex !== null) {
                    await uiUtils.showCustomAlert("メッセージ編集中です。完了後に再度お試しください。");
                    return;
                }
                if (state.isEditingSystemPrompt) {
                    await uiUtils.showCustomAlert("システムプロンプト編集中です。完了後に再度お試しください。");
                    return;
                }

                const chatTitle = elements.chatTitle.textContent.startsWith("新規チャット") ? "このチャット" : `チャット「${elements.chatTitle.textContent.replace(/^: /, '')}」`;
                const confirmed = await uiUtils.showCustomConfirm(
                    `${chatTitle}を完全に削除しますか？\nこの操作は元に戻せません。`
                );
                if (confirmed) {
                    await this.deleteCurrentSession();
                }
            },
            async deleteCurrentSession() {
                try {
                    if (state.currentChatId) {
                        await dbUtils.deleteChat(state.currentChatId);
                    }
                    this.startNewChat();
                    await uiUtils.showCustomAlert("チャットを削除しました。");
                } catch (error) {
                    console.error("Error deleting current session:", error);
                    await uiUtils.showCustomAlert(`チャットの削除中にエラーが発生しました: ${error}`);
                }
            },
            async copyCurrentSessionText() {
                if (state.currentMessages.length === 0 && !state.currentSystemPrompt) {
                    await uiUtils.showCustomAlert("コピーする内容がありません。");
                    return;
                }

                let sessionText = "";
                if (state.currentSystemPrompt) {
                    sessionText += `システムプロンプト:\n${state.currentSystemPrompt}\n\n--------------------\n\n`;
                }
                state.currentMessages.forEach(msg => {
                    if (msg.role === 'user') {
                        sessionText += `あなた:\n`;
                    } else if (msg.role === 'model') {
                        sessionText += `モデル:\n`;
                    } else if (msg.role === 'error') {
                        sessionText += `エラー:\n`;
                    }
                    sessionText += `${msg.content}\n\n`;
                    if (msg.attachments && msg.attachments.length > 0) {
                        sessionText += `  [添付ファイル: ${msg.attachments.map(a => a.name).join(', ')}]\n\n`;
                    }
                });

                try {
                    await navigator.clipboard.writeText(sessionText.trim());
                    const buttonElement = elements.copySessionBtn;
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = '✓';
                    buttonElement.disabled = true;
                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                        buttonElement.disabled = false;
                    }, 1500);
                } catch (err) {
                    console.error("Copy session text error:", err);
                    await uiUtils.showCustomAlert("クリップボードへのコピーに失敗しました。\nお使いのブラウザが対応していないか、セキュリティ設定が原因の可能性があります。");
                    const buttonElement = elements.copySessionBtn;
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = 'コピー失敗';
                    buttonElement.disabled = true;
                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                        buttonElement.disabled = false;
                    }, 2000);
                }
            },
            async confirmDeleteChat(id, title) {
                 const confirmed = await uiUtils.showCustomConfirm(`「${title || 'この履歴'}」を削除しますか？`);
                 if (confirmed) {
                    const isDeletingCurrent = state.currentChatId === id;
                    const currentScreenBeforeDelete = state.currentScreen;
                    try {
                        await dbUtils.deleteChat(id);
                        if (isDeletingCurrent) {
                            this.startNewChat();
                        }
                        if (currentScreenBeforeDelete === 'history') {
                            await uiUtils.renderHistoryList();
                            const listIsEmpty = elements.historyList.querySelectorAll('.history-item:not(.js-history-item-template)').length === 0;
                            if (listIsEmpty) {
                                if (!isDeletingCurrent) {
                                    this.startNewChat();
                                }
                            }
                        }
                    } catch (error) {
                        console.error("Confirm delete chat error:", error);
                        await uiUtils.showCustomAlert(`チャット削除エラー: ${error}`);
                        uiUtils.setSendingState(false);
                    }
                }
            },
            async editHistoryTitle(chatId, titleElement) {
                const currentTitle = titleElement.textContent;
                const newTitle = await uiUtils.showCustomPrompt("新しいタイトル:", currentTitle);
                const trimmedTitle = (newTitle !== null) ? newTitle.trim() : '';

                if (newTitle !== '' && trimmedTitle !== '' && trimmedTitle !== currentTitle) {
                    const finalTitle = trimmedTitle.substring(0, 100);
                    try {
                        await dbUtils.updateChatTitleDb(chatId, finalTitle);
                        titleElement.textContent = finalTitle;
                        titleElement.title = finalTitle;
                        const dateElement = titleElement.closest('.history-item')?.querySelector('.updated-date');
                        if(dateElement) dateElement.textContent = `更新: ${uiUtils.formatDate(Date.now())}`;

                        if (state.currentChatId === chatId) {
                            uiUtils.updateChatTitle(finalTitle);
                        }
                    } catch (error) {
                        console.error("Edit history title error:", error);
                        await uiUtils.showCustomAlert(`タイトル更新エラー: ${error}`);
                    }
                }
            },
            async typeCharacterByCharacter(processedChunks, messageIndex, signal, prefix = '') {
                const speed = state.settings.streamingSpeed;
                let accumulatedRawContent = prefix;
                state.partialStreamContent = prefix;
                if (prefix) {
                    uiUtils.updateStreamingMessage(messageIndex, '');
                }

                if (!speed || speed <= 0) {
                    accumulatedRawContent = prefix + processedChunks.map(chunk => chunk === null ? '\n\n' : chunk).join('');
                    state.partialStreamContent = accumulatedRawContent;
                    uiUtils.updateStreamingMessage(messageIndex, '');
                    return accumulatedRawContent;
                }

                for (const chunk of processedChunks) {
                    if (signal.aborted) {
                        return accumulatedRawContent;
                    }
                    if (chunk === null) {
                        const separator = '\n\n';
                        accumulatedRawContent += separator;
                        state.partialStreamContent = accumulatedRawContent;
                        uiUtils.updateStreamingMessage(messageIndex, '');
                    } else if (typeof chunk === 'string') {
                        for (const char of chunk) {
                            if (signal.aborted) {
                                return accumulatedRawContent;
                            }
                            accumulatedRawContent += char;
                            state.partialStreamContent = accumulatedRawContent;
                            uiUtils.updateStreamingMessage(messageIndex, char);
                            await sleep(speed);
                        }
                    }
                }
                return accumulatedRawContent;
            },
            async handleSend(isRetry = false, retryUserMessageIndex = -1) {
                if (state.editingMessageIndex !== null) { await uiUtils.showCustomAlert("他のメッセージを編集中です。"); return; }
                if (state.isEditingSystemPrompt) { await uiUtils.showCustomAlert("システムプロンプトを編集中です。"); return; }

                let text = '';
                let attachmentsToSend = [];

                if (isRetry) {
                    const retryUserMessage = state.currentMessages[retryUserMessageIndex];
                    if (!retryUserMessage || retryUserMessage.role !== 'user') {
                        uiUtils.setSendingState(false);
                        return;
                    }
                    text = retryUserMessage.content || '';
                    attachmentsToSend = retryUserMessage.attachments ? [...retryUserMessage.attachments] : [];
                } else {
                    text = elements.userInput.value.trim();
                    attachmentsToSend = [...state.pendingAttachments];
                }

                if (state.isSending || (!text && attachmentsToSend.length === 0)) {
                    return;
                }
                if (!state.settings.apiKey) { await uiUtils.showCustomAlert("APIキーが設定されていません。設定画面を開きます。"); uiUtils.showScreen('settings'); return; }

                uiUtils.setSendingState(true);
                state.partialStreamContent = '';

                let userMessageIndex = isRetry ? retryUserMessageIndex : -1;
                let existingSiblingGroupId = null;
                let firstResponseIndexForRetry = -1;
                let siblingGroupIdToUse = null;

                if (!isRetry) {
                    const userMessage = {
                        role: 'user', content: text, timestamp: Date.now(),
                        attachments: attachmentsToSend
                    };
                    state.currentMessages.push(userMessage => reject(event.target.error);
                        });

                        if (state.currentScreen === 'history') {
                            uiUtils.renderHistoryList();
                        } else {
                            await uiUtils.showCustomAlert);
                    userMessageIndex = state.currentMessages.length - 1;
                    state.messageCollapsedStates(`チャット「${newTitle}」を複製しました。`);
                        }
                    } else {
                        await ui.set(userMessageIndex, false);
                    uiUtils.appendMessage(userMessage.role, userMessage.contentUtils.showCustomAlert("複製元のチャットが見つかりません。");
                    }
                } catch (error) {, userMessageIndex, false, null, userMessage.attachments);
                    elements.userInput.value = '';

                    console.error("Error duplicating chat:", error);
                    await uiUtils.showCustomAlert(`チャット                    state.pendingAttachments = [];
                    uiUtils.adjustTextareaHeight();
                    if (state.settings複製エラー: ${error}`);
                }
            },
            async exportChat(chatId, chatTitle) {
                 const confirmed = await uiUtils.showCustomConfirm(`チャット「${chatTitle || 'この履歴'}」をテキスト出力しますか？`);
                 if (!confirmed) return;

                 try {
                     const chat = await.autoScrollOnNewMessage) {
                        uiUtils.scrollToBottom();
                    }
                } else { dbUtils.getChat(chatId);
                     if (!chat || ((!chat.messages || chat.messages.length
                    let siblingStartIndex = userMessageIndex + 1;
                    while (siblingStartIndex < state.currentMessages === 0) && !chat.systemPrompt)) {
                         await uiUtils.showCustomAlert("チャット.length && state.currentMessages[siblingStartIndex].role !== 'model') {
                        siblingStartIndex++;
                    データが空です。");
                         return;
                     }

                     let exportText = '';
                     if (chat}
                    if (siblingStartIndex < state.currentMessages.length && state.currentMessages[siblingStartIndex].role.systemPrompt) {
                         exportText += `<|#|system|#|>\n${chat.systemPrompt}\n<|#|/system|#|>\n\n`;
                     }
                     if (chat. === 'model') {
                         firstResponseIndexForRetry = siblingStartIndex;
                         const firstResponse = state.currentMessagesmessages) {
                         chat.messages.forEach(msg => {
                             if (msg.role === 'user[firstResponseIndexForRetry];
                         if (firstResponse.isCascaded && firstResponse.siblingGroupId) {
                             ' || msg.role === 'model') {
                                 let attributes = '';
                                 if (msg.role ===existingSiblingGroupId = firstResponse.siblingGroupId;
                             state.currentMessages.forEach(msg => {
                                'model') {
                                     if (msg.isCascaded) attributes += ' isCascaded';
                                 if (msg.siblingGroupId === existingSiblingGroupId) {
                                     msg.isSelected = false;
                                     if (msg.isSelected) attributes += ' isSelected';
                                 }
                                 if (msg.  }
                             });
                             siblingGroupIdToUse = existingSiblingGroupId;
                         }
                    }
                }role === 'user' && msg.attachments && msg.attachments.length > 0) {
                                     const fileNames = msg.attachments.map(a => a.name).join(';');
                                     attributes += `

                const messagesToProcess = isRetry
                    ? state.currentMessages.slice(0, userMessageIndex attachments="${fileNames.replace(/"/g, '&quot;')}"`;
                                 }
                                 exportText += `<|#|${msg.role}|#|${attributes.trim()}>\n${msg.content}\ + 1)
                    : [...state.currentMessages];

                try {
                    let titleToSave = nulln<|#|/${msg.role}|#|>\n\n`;
                             }
                         });
                     };
                    if(state.currentChatId) {
                        const currentChat = await dbUtils.getChat

                     const blob = new Blob([exportText.trim()], { type: 'text/plain;charset=utf-8' });
                     const url = URL.createObjectURL(blob);
                     const a = document.createElement('a(state.currentChatId);
                        if(currentChat) titleToSave = currentChat.title;
');
                     const safeTitle = (chatTitle || `chat_${chatId}_export`).replace(/[<>:"/                    }
                    if (!titleToSave) {
                        const firstUserMsg = state.currentMessages.find\\|?*\s]/g, '_');
                     a.href = url;
                     a.download =(m => m.role === 'user');
                        if(firstUserMsg) {
                            titleToSave `${safeTitle}.txt`;
                     document.body.appendChild(a);
                     a.click();
                     document.body.removeChild(a);
                     URL.revokeObjectURL(url);
                 } catch (error) {
                      = firstUserMsg.content.substring(0, 50);
                        }
                    }
                    awaitconsole.error("Export chat error:", error);
                     await uiUtils.showCustomAlert(`エクスポートエラー: ${error}`);
                 }
            },
            async confirmDeleteCurrentSession() {
                if (!state dbUtils.saveChat(titleToSave);
                } catch (error) {
                    console.error(".currentChatId && state.currentMessages.length === 0 && !state.currentSystemPrompt) {
                    awaitError saving chat before send:", error);
                    uiUtils.displayError("チャットの保存に失敗しましたが、送信 uiUtils.showCustomAlert("削除するチャットがありません（新規チャット状態です）。");
                    return;
                }
                if (state.isSending) {
                    await uiUtils.showCustomAlert("送信中ですを試みます。", false);
                }

                const apiMessages = messagesToProcess
                    .filter(msg => {
。完了後に再度お試しください。");
                    return;
                }
                if (state.editingMessageIndex !== null) {
                    await uiUtils.showCustomAlert("メッセージ編集中です。完了後に再度お試しください。");                        if (msg.role === 'user') return true;
                        if (msg.role === 'model')
                    return;
                }
                if (state.isEditingSystemPrompt) {
                    await uiUtils return !msg.isCascaded || (msg.isCascaded && msg.isSelected);
                        return false;.showCustomAlert("システムプロンプト編集中です。完了後に再度お試しください。");
                    return;
                }

                const chatTitle = elements.chatTitle.textContent.startsWith("新規チャット") ? "
                    })
                    .map(msg => {
                        const parts = [];
                        if (msg.content && msg.このチャット" : `チャット「${elements.chatTitle.textContent.replace(/^: /, '')}」`;
                const confirmed = await uiUtils.showCustomConfirm(
                    `${chatTitle}を完全に削除しますかcontent.trim() !== '') {
                            parts.push({ text: msg.content });
                        }
                        ？\nこの操作は元に戻せません。`
                );
                if (confirmed) {
                    if (msg.role === 'user' && msg.attachments && msg.attachments.length > 0) {await this.deleteCurrentSession();
                }
            },
            async deleteCurrentSession() {
                try
                            msg.attachments.forEach(att => {
                                parts.push({
                                    inlineData: {
                                         {
                    if (state.currentChatId) {
                        await dbUtils.deleteChat(state.currentChatId);
                    }
                    this.startNewChat();
                    await uiUtils.showCustomAlert("mimeType: att.mimeType,
                                        data: att.base64Data
                                    }
チャットを削除しました。");
                } catch (error) {
                    console.error("Error deleting current session:", error);
                    await uiUtils.showCustomAlert(`チャットの削除中にエラーが発生しました: ${                                });
                            });
                        }
                        return { role: msg.role, parts: parts };
                    });

                error}`);
                }
            },
            async copyCurrentSessionText() {
                if (state.currentMessagesconst dummyUserText = state.settings.dummyUser?.trim();
                const dummyModelText = state.settings.length === 0 && !state.currentSystemPrompt) {
                    await uiUtils.showCustomAlert(".dummyModel?.trim();
                if (dummyUserText) apiMessages.push({ role: 'user', partsコピーする内容がありません。");
                    return;
                }

                let sessionText = "";
                if (state.currentSystemPrompt) {
                    sessionText += `システムプロンプト:\n${state.currentSystemPrompt: [{ text: dummyUserText }] });
                if (dummyModelText) apiMessages.push({ role:}\n\n--------------------\n\n`;
                }
                state.currentMessages.forEach(msg => 'model', parts: [{ text: dummyModelText }] });


                const generationConfig = {};
                if (state {
                    if (msg.role === 'user') {
                        sessionText += `あなた:\n`;
                    } else if (msg.role === 'model') {
                        sessionText += `モデル:\n`;
.settings.temperature !== null) generationConfig.temperature = state.settings.temperature;
                if (state.                    } else if (msg.role === 'error') {
                        sessionText += `エラー:\n`;
                    }
                    sessionText += `${msg.content}\n\n`;
                    if (msg.attachments &&settings.maxTokens !== null) generationConfig.maxOutputTokens = state.settings.maxTokens;
                if msg.attachments.length > 0) {
                        sessionText += `  [添付ファイル: ${msg. (state.settings.topK !== null) generationConfig.topK = state.settings.topK;
attachments.map(a => a.name).join(', ')}]\n\n`;
                    }
                });

                try {
                    await navigator.clipboard.writeText(sessionText.trim());
                    const buttonElement =                if (state.settings.topP !== null) generationConfig.topP = state.settings.topP elements.copySessionBtn;
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent =;
                if (state.settings.presencePenalty !== null) generationConfig.presencePenalty = state.settings. '✓';
                    buttonElement.disabled = true;
                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                        buttonElement.disabled = false;
                    }, 1500);
                presencePenalty;
                if (state.settings.frequencyPenalty !== null) generationConfig.frequencyPenalty = state.} catch (err) {
                    console.error("Copy session text error:", err);
                    await uiUtils.showsettings.frequencyPenalty;

                if (state.settings.thinkingBudget !== null && Number.isInteger(stateCustomAlert("クリップボードへのコピーに失敗しました。\nお使いのブラウザが対応していないか、セキュリティ.settings.thinkingBudget) && state.settings.thinkingBudget >= 0) {
                    generationConfig.thinking設定が原因の可能性があります。");
                    const buttonElement = elements.copySessionBtn;
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = 'コピー失敗';
                    buttonElement.disabled = true;
Config = {
                        "thinkingBudget": state.settings.thinkingBudget,
                    };
                }

                                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                        buttonElement.disabled = false;const systemInstruction = state.currentSystemPrompt?.trim()
                    ? { role: "system", parts: [{ text: state
                    }, 2000);
                }
            },
            async confirmDeleteChat(id, title) {
                 const confirmed = await uiUtils.showCustomConfirm(`「${title || 'この履歴'}」を削除します.currentSystemPrompt.trim() }] }
                    : null;

                let modelResponseRawContent = '';
                letか？`);
                 if (confirmed) {
                    const isDeletingCurrent = state.currentChatId === id;
 modelResponseMetadata = {};
                let groundingMetadata = null;
                let usageMetadata = null;

                try                    const currentScreenBeforeDelete = state.currentScreen;
                    try {
                        await dbUtils.deleteChat(id);
                        if (isDeletingCurrent) {
                            this.startNewChat();
                        }
                        if ( {
                    const response = await apiUtils.callGeminiApi(apiMessages, generationConfig, systemInstruction);currentScreenBeforeDelete === 'history') {
                            await uiUtils.renderHistoryList();
                            const listIsEmpty
                    const dummyModelPrefix = (state.settings.concatDummyModel && state.settings.dummyModel) ? = elements.historyList.querySelectorAll('.history-item:not(.js-history-item-template)').length === state.settings.dummyModel : '';

                    if (state.settings.streamingOutput && !state.settings. 0;
                            if (listIsEmpty) {
                                if (!isDeletingCurrent) {
                                    this.startNewChat();
                                }
                            }
                        }
                    } catch (error) {
                        pseudoStreaming) {
                        const tempPlaceholderIndex = state.currentMessages.length;
                        uiUtils.appendconsole.error("Confirm delete chat error:", error);
                        await uiUtils.showCustomAlert(`チャット削除Message('model', '', tempPlaceholderIndex, true);
                        const streamResult = await apiUtils.handleStreamingResponse(responseエラー: ${error}`);
                        uiUtils.setSendingState(false);
                    }
                }
            },
            async editHistoryTitle(chatId, titleElement) {
                const currentTitle = titleElement.textContent;
                );
                        modelResponseMetadata = { finishReason: streamResult.finishReason, safetyRatings: streamResult.safetyRatings };const newTitle = await uiUtils.showCustomPrompt("新しいタイトル:", currentTitle);
                const trimmedTitle =
                        groundingMetadata = streamResult.groundingMetadata;
                        usageMetadata = streamResult.usageMetadata;

                        model (newTitle !== null) ? newTitle.trim() : '';

                if (newTitle !== '' && trimmedTitle !== '' && trimmedTitle !== currentTitle) {
                    const finalTitle = trimmedTitle.substring(0, 100ResponseRawContent = await this.typeCharacterByCharacter(streamResult.processedChunks, tempPlaceholderIndex, state.abortController.);
                    try {
                        await dbUtils.updateChatTitleDb(chatId, finalTitle);
                        signal, dummyModelPrefix);

                        if (modelResponseMetadata.finishReason === 'ABORTED' || state.abortControllertitleElement.textContent = finalTitle;
                        titleElement.title = finalTitle;
                        const dateElement =?.signal.aborted) {
                            throw new Error("リクエストがキャンセルされました。");
                        }
 titleElement.closest('.history-item')?.querySelector('.updated-date');
                        if(dateElement) dateElement.textContent = `更新: ${uiUtils.formatDate(Date.now())}`;

                        if (state.currentChatId === chatId) {
                            uiUtils.updateChatTitle(finalTitle);
                        }
                    }                        const placeholderElement = document.getElementById(`streaming-message-${tempPlaceholderIndex}`);
                        if (placeholderElement) placeholderElement.remove();
                    } else if (state.settings.streamingOutput && state.settings.pseudoStreaming) { catch (error) {
                        console.error("Edit history title error:", error);
                        await uiUtils.showCustomAlert(`タイトル更新エラー: ${error}`);
                    }
                }
            },
            async type
                        const tempPlaceholderIndex = state.currentMessages.length;
                        uiUtils.appendMessage('model',CharacterByCharacter(processedChunks, messageIndex, signal, prefix = '') {
                const speed = state.settings '', tempPlaceholderIndex, true);
                        const streamResult = await apiUtils.handleStreamingResponse(response);
                        model.streamingSpeed;
                let accumulatedRawContent = prefix;
                state.partialStreamContent = prefix;
                ifResponseMetadata = { finishReason: streamResult.finishReason, safetyRatings: streamResult.safetyRatings };
                         (prefix) {
                    uiUtils.updateStreamingMessage(messageIndex, '');
                }

                if (!speed || speed <= 0) {
                    accumulatedRawContent = prefix + processedChunks.map(chunk => chunk === nullgroundingMetadata = streamResult.groundingMetadata;
                        usageMetadata = streamResult.usageMetadata;
                         ? '\n\n' : chunk).join('');
                    state.partialStreamContent = accumulatedRawContent;
                    uiUtils.updateStreamingMessage(messageIndex, '');
                    return accumulatedRawContent;
                }

                for (const chunk ofmodelResponseRawContent = await this.typeCharacterByCharacter(streamResult.processedChunks, tempPlaceholderIndex, state processedChunks) {
                    if (signal.aborted) {
                        return accumulatedRawContent;
                    }.abortController.signal, dummyModelPrefix);

                        if (modelResponseMetadata.finishReason === 'ABORTED' ||
                    if (chunk === null) {
                        const separator = '\n\n';
                        accumulatedRawContent += separator;
                        state.partialStreamContent = accumulatedRawContent;
                        uiUtils.updateStreamingMessage state.abortController?.signal.aborted) {
                            throw new Error("リクエストがキャンセルされました。");(messageIndex, '');
                    } else if (typeof chunk === 'string') {
                        for (const char
                        }
                        const placeholderElement = document.getElementById(`streaming-message-${tempPlaceholderIndex}`);
                        if (placeholder of chunk) {
                            if (signal.aborted) {
                                return accumulatedRawContent;
                            }
                            accumulatedRawContent += char;
                            state.partialStreamContent = accumulatedRawContent;
                            uiUtils.updateElement) placeholderElement.remove();
                    } else {
                        const data = await response.json();
                        StreamingMessage(messageIndex, char);
                            await sleep(speed);
                        }
                    }
                }
                return accumulatedRawContent;
            },
            async handleSend(isRetry = false, retryUserMessageIndex = -const candidate = data.candidates?.[0];
                        let rawContentFromApi = "";
                        if (candidate) {1) {
                if (state.editingMessageIndex !== null) { await uiUtils.showCustomAlert("
                            modelResponseMetadata = { finishReason: candidate.finishReason, safetyRatings: candidate.safetyRatings };
他のメッセージを編集中です。"); return; }
                if (state.isEditingSystemPrompt) { await                            rawContentFromApi = candidate.content?.parts?.map(p => p.text || "").join('\n uiUtils.showCustomAlert("システムプロンプトを編集中です。"); return; }

                let text = '';
                let attachmentsToSend = [];

                if (isRetry) {
                    const retryUserMessage = state.currentMessages[\n') || "";
                            groundingMetadata = candidate.groundingMetadata || null;
                            usageMetadata =retryUserMessageIndex];
                    if (!retryUserMessage || retryUserMessage.role !== 'user') {
                        uiUtils.setSendingState(false);
                        return;
                    }
                    text = retryUserMessage.content data.usageMetadata || null;

                            if (candidate.finishReason && candidate.finishReason !== "STOP" || '';
                    attachmentsToSend = retryUserMessage.attachments ? [...retryUserMessage.attachments] : [];
                 && candidate.finishReason !== "MAX_TOKENS") {
                                rawContentFromApi += `\n\} else {
                    text = elements.userInput.value.trim();
                    attachmentsToSend = [...state.pendingn(理由: ${candidate.finishReason})`;
                            }
                            if (!rawContentFromApi && candidate.finishReasonAttachments];
                }

                if (state.isSending || (!text && attachmentsToSend.length === 0)) {
                    return;
                }
                if (!state.settings.apiKey) { await uiUtils.showCustomAlert("API === "STOP") {
                                rawContentFromApi = "(応答が空です)";
                            }
                        } else {キーが設定されていません。設定画面を開きます。"); uiUtils.showScreen('settings'); return; }

                uiUtils
                            rawContentFromApi = "応答候補がありません";
                            if(data.promptFeedback) {
                               .setSendingState(true);
                state.partialStreamContent = '';

                let userMessageIndex = isRetry ? retryUserMessageIndex : -1;
                let existingSiblingGroupId = null;
                let firstResponseIndexForRetry rawContentFromApi += ` (理由: ${data.promptFeedback.blockReason || '不明'})`;
                                model = -1;
                let siblingGroupIdToUse = null;

                if (!isRetry) {
                    const userMessage = {
                        role: 'user', content: text, timestamp: Date.now(),
                        attachments:ResponseMetadata.promptFeedback = data.promptFeedback;
                                modelResponseMetadata.finishReason = data.promptFeedback attachmentsToSend
                    };
                    state.currentMessages.push(userMessage);
                    userMessageIndex = state.blockReason || 'ERROR';
                            } else {
                                modelResponseMetadata.finishReason = 'ERROR';.currentMessages.length - 1;
                    state.messageCollapsedStates.set(userMessageIndex, false
                            }
                            usageMetadata = data.usageMetadata || null;
                        }
                        modelResponseRawContent);
                    uiUtils.appendMessage(userMessage.role, userMessage.content, userMessageIndex, false, null, userMessage.attachments);
                    elements.userInput.value = '';
                    state.pendingAttachments = [];
 = dummyModelPrefix + rawContentFromApi;
                    }


                    if (modelResponseRawContent || modelResponseMetadata.                    uiUtils.adjustTextareaHeight();
                    if (state.settings.autoScrollOnNewMessage) {finishReason) {
                         const newModelMessage = {
                             role: 'model', content: modelResponseRawContent,
                        uiUtils.scrollToBottom();
                    }
                } else {
                    let siblingStartIndex = userMessageIndex + 1;
                    while (siblingStartIndex < state.currentMessages.length && state.currentMessages[siblingStartIndex].role !== 'model') {
                        siblingStartIndex++;
                    }
                    if (siblingStartIndex < state.current timestamp: Date.now(),
                             ...modelResponseMetadata, groundingMetadata: groundingMetadata, usageMetadata: usageMetadata
                         Messages.length && state.currentMessages[siblingStartIndex].role === 'model') {
                         firstResponseIndexForRetry = siblingStartIndex;
                         const firstResponse = state.currentMessages[firstResponseIndexForRetry];
                         if (first};

                         const targetUserIndexForCascade = userMessageIndex;
                         if (targetUserIndexForCascade !==Response.isCascaded && firstResponse.siblingGroupId) {
                             existingSiblingGroupId = firstResponse.siblingGroupId;
                              -1) {
                             if (siblingGroupIdToUse === null) {
                                 siblingGroupIdToUse =state.currentMessages.forEach(msg => {
                                 if (msg.siblingGroupId === existingSiblingGroupId) {
                                     msg.isSelected = false;
                                 }
                             });
                             siblingGroupIdToUse = existing `gid-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
SiblingGroupId;
                         }
                    }
                }

                const messagesToProcess = isRetry
                    ?                             }
                             newModelMessage.isCascaded = true;
                             newModelMessage.isSelected = true; state.currentMessages.slice(0, userMessageIndex + 1)
                    : [...state.currentMessages];

                try {
                    let titleToSave = null;
                    if(state.currentChatId) {
                             newModelMessage.siblingGroupId = siblingGroupIdToUse;

                             if (isRetry && firstResponseIndex
                        const currentChat = await dbUtils.getChat(state.currentChatId);
                        if(currentForRetry !== -1 && state.currentMessages[firstResponseIndexForRetry] && !state.currentMessages[Chat) titleToSave = currentChat.title;
                    }
                    if (!titleToSave) {
                        const firstUserMsg = state.currentMessages.find(m => m.role === 'user');
                        firstResponseIndexForRetry].isCascaded) {
                                 state.currentMessages[firstResponseIndexForRetryif(firstUserMsg) {
                            titleToSave = firstUserMsg.content.substring(0, ].isCascaded = true;
                                 state.currentMessages[firstResponseIndexForRetry].siblingGroupId =50);
                        }
                    }
                    await dbUtils.saveChat(titleToSave);
                } catch (error) {
                    console.error("Error saving chat before send:", error);
                    uiUtils siblingGroupIdToUse;
                             }
                         }

                         const newModelIndex = state.currentMessages.length;.displayError("チャットの保存に失敗しましたが、送信を試みます。", false);
                }

                const
                         state.currentMessages.push(newModelMessage);
                         state.messageCollapsedStates.set(newModelIndex apiMessages = messagesToProcess
                    .filter(msg => {
                        if (msg.role === 'user') return true, false);
                         uiUtils.renderChatMessages();
                         await dbUtils.saveChat();
                    }
                ;
                        if (msg.role === 'model') return !msg.isCascaded || (msg.isCascaded && msg.isSelected);
                        return false;
                    })
                    .map(msg => {
                        const parts} catch (error) {
                    console.error("Error during API call or response handling:", error);
                    const isAbort = [];
                        if (msg.content && msg.content.trim() !== '') {
                            parts.push({ text: msg.content });
                        }
                        if (msg.role === 'user' && msg. = error.message === "リクエストがキャンセルされました。";
                    const displayErrorMessage = isAbort ? error.attachments && msg.attachments.length > 0) {
                            msg.attachments.forEach(att => {
                                parts.message : (error.message || "不明なエラーが発生しました");
                    const partialRawContent = state.partialStreamContentpush({
                                    inlineData: {
                                        mimeType: att.mimeType,
                                        data: att.base64Data
                                    }
                                });
                            });
                        }
                        return { role: msg || error.cause?.partialChunks?.join('');

                    if (partialRawContent && state.settings.streamingOutput) {
.role, parts: parts };
                    });

                const dummyUserText = state.settings.dummyUser?.trim();
                const dummyModelText = state.settings.dummyModel?.trim();
                if (dummyUser                         const finalPartialContent = partialRawContent + `\n\n(${isAbort ? '中断されました' : 'エラーが発生Text) apiMessages.push({ role: 'user', parts: [{ text: dummyUserText }] });
                if (dummyModelText) apiMessages.push({ role: 'model', parts: [{ text: dummyModelText }] });


しました'})`;
                         const partialMessage = {
                             role: 'model', content: finalPartialContent, timestamp                const generationConfig = {};
                if (state.settings.temperature !== null) generationConfig.temperature = state: Date.now(), error: true,
                             finishReason: isAbort ? 'ABORTED' : (model.settings.temperature;
                if (state.settings.maxTokens !== null) generationConfig.maxOutputTokensResponseMetadata.finishReason || 'ERROR'),
                             ...(modelResponseMetadata.safetyRatings && { safetyRatings: model = state.settings.maxTokens;
                if (state.settings.topK !== null) generationConfig.topK = state.settings.topK;
                if (state.settings.topP !== null) generationResponseMetadata.safetyRatings })
                         };
                         if (isRetry && isAbort) {
                             if (siblingConfig.topP = state.settings.topP;
                if (state.settings.presencePenalty !== nullGroupIdToUse === null) {
                                 siblingGroupIdToUse = `gid-${Date.now()}-${Math) generationConfig.presencePenalty = state.settings.presencePenalty;
                if (state.settings.frequencyPenalty !== null) generationConfig.frequencyPenalty = state.settings.frequencyPenalty;

                if (state.settings..random().toString(36).substring(2, 8)}`;
                             }
                             partialMessage.isthinkingBudget !== null && Number.isInteger(state.settings.thinkingBudget) && state.settings.thinkingBudget >= 0) {
                    generationConfig.thinkingConfig = {
                        "thinkingBudget": state.settings.thinkingBudgetCascaded = true;
                             partialMessage.siblingGroupId = siblingGroupIdToUse;
                             partialMessage.isSelected = true;,
                    };
                }

                const systemInstruction = state.currentSystemPrompt?.trim()
                    ? { role: "system", parts: [{ text: state.currentSystemPrompt.trim() }] }
                    :
                             if (firstResponseIndexForRetry !== -1 && state.currentMessages[firstResponseIndexForRetry] null;

                let modelResponseRawContent = '';
                let modelResponseMetadata = {};
                let groundingMetadata = null && !state.currentMessages[firstResponseIndexForRetry].isCascaded) {
                                 state.current;
                let usageMetadata = null;

                try {
                    const response = await apiUtils.callGemMessages[firstResponseIndexForRetry].isCascaded = true;
                                 state.currentMessages[firstResponseiniApi(apiMessages, generationConfig, systemInstruction);
                    const dummyModelPrefix = (state.settings.IndexForRetry].siblingGroupId = siblingGroupIdToUse;
                             }
                         }

                         const newModelIndexconcatDummyModel && state.settings.dummyModel) ? state.settings.dummyModel : '';

                    if (state.settings.streamingOutput && !state.settings.pseudoStreaming) {
                        const tempPlaceholderIndex = state = state.currentMessages.length;
                         state.currentMessages.push(partialMessage);
                         state.messageCollapsed.currentMessages.length;
                        uiUtils.appendMessage('model', '', tempPlaceholderIndex, true);
                        constStates.set(newModelIndex, false);
                         try {
                             await dbUtils.saveChat();
 streamResult = await apiUtils.handleStreamingResponse(response);
                        modelResponseMetadata = { finishReason: streamResult.finishReason, safetyRatings: streamResult.safetyRatings };
                        groundingMetadata = streamResult.grounding                             uiUtils.renderChatMessages();
                         } catch (saveError) {
                             console.error("ErrorMetadata;
                        usageMetadata = streamResult.usageMetadata;

                        modelResponseRawContent = await this.type saving chat after partial response:", saveError);
                             uiUtils.displayError(displayErrorMessage, !isAbort);
                         CharacterByCharacter(streamResult.processedChunks, tempPlaceholderIndex, state.abortController.signal, dummyModelPrefix);

                        if (modelResponseMetadata.finishReason === 'ABORTED' || state.abortController?.signal.ab}
                    } else {
                        uiUtils.displayError(displayErrorMessage, !isAbort);
                    }
                }orted) {
                            throw new Error("リクエストがキャンセルされました。");
                        }
                        const placeholderElement finally {
                    uiUtils.setSendingState(false);
                    state.abortController = null;
                     = document.getElementById(`streaming-message-${tempPlaceholderIndex}`);
                        if (placeholderElement) placeholderElement.remove();
                    } else if (state.settings.streamingOutput && state.settings.pseudoStreaming) {
                        const tempstate.partialStreamContent = '';
                    if (state.settings.autoScrollOnNewMessage) {
                        PlaceholderIndex = state.currentMessages.length;
                        uiUtils.appendMessage('model', '', tempPlaceholderIndexuiUtils.scrollToBottom();
                    }
                    uiUtils.updateAttachmentBadgeVisibility();
                }
            , true);
                        const streamResult = await apiUtils.handleStreamingResponse(response);
                        modelResponseMetadata = { finishReason: streamResult.finishReason, safetyRatings: streamResult.safetyRatings };
                        groundingMetadata =},
            abortRequest() {
                if (state.abortController) {
                    state.abortController.abort();
 streamResult.groundingMetadata;
                        usageMetadata = streamResult.usageMetadata;
                        modelResponseRawContent = await this.typeCharacterByCharacter(streamResult.processedChunks, tempPlaceholderIndex, state.abortController.                }
            },
            async handleHistoryImport(file) {
                if (!file || !file.signal, dummyModelPrefix);

                        if (modelResponseMetadata.finishReason === 'ABORTED' || state.abortControllertype.startsWith('text/plain')) {
                    await uiUtils.showCustomAlert("テキストファイル (.txt)?.signal.aborted) {
                            throw new Error("リクエストがキャンセルされました。");
                        }
 を選択してください。");
                    return;
                }
                const reader = new FileReader();
                reader.                        const placeholderElement = document.getElementById(`streaming-message-${tempPlaceholderIndex}`);
                        if (placeholderElement) placeholderElementonload = async (event) => {
                    const textContent = event.target.result;
                    if (!.remove();
                    } else {
                        const data = await response.json();
                        const candidate = data.candidates?.[0];
                        let rawContentFromApi = "";
                        if (candidate) {
                            modelResponsetextContent) {
                        await uiUtils.showCustomAlert("ファイルの内容が空です。");
                        return;Metadata = { finishReason: candidate.finishReason, safetyRatings: candidate.safetyRatings };
                            rawContentFromApi = candidate.content?.parts?.map(p => p.text || "").join('\n\n') ||
                    }
                    try {
                        const { messages: importedMessages, systemPrompt: importedSystemPrompt } = "";
                            groundingMetadata = candidate.groundingMetadata || null;
                            usageMetadata = data.usageMetadata this.parseImportedHistory(textContent);
                        if (importedMessages.length === 0 && !importedSystemPrompt) { || null;

                            if (candidate.finishReason && candidate.finishReason !== "STOP" && candidate.finishReason !== "MAX_TOKENS") {
                                rawContentFromApi += `\n\n(理由: ${candidate.finishReason})`;
                            }
                            if (!rawContentFromApi && candidate.finishReason === "STOP")
                            await uiUtils.showCustomAlert("ファイルから有効なメッセージまたはシステムプロンプトを読み込めませんでした。 {
                                rawContentFromApi = "(応答が空です)";
                            }
                        } else {
                            形式を確認してください。");
                            return;
                        }

                        let currentGroupId = null;
                        let lastUserrawContentFromApi = "応答候補がありません";
                            if(data.promptFeedback) {
                                rawContentFromApi += ` (理由: ${data.promptFeedback.blockReason || '不明'})`;
                                modelResponseMetadata.promptIndex = -1;
                        for (let i = 0; i < importedMessages.length; i++)Feedback = data.promptFeedback;
                                modelResponseMetadata.finishReason = data.promptFeedback.blockReason || 'ERROR';
                            } else {
                                modelResponseMetadata.finishReason = 'ERROR';
                            }
 {
                            const msg = importedMessages[i];
                            if (msg.role === 'user') {
                            usageMetadata = data.usageMetadata || null;
                        }
                        modelResponseRawContent = dummyModelPrefix + raw                                lastUserIndex = i;
                                currentGroupId = null;
                            } else if (msg.role ===ContentFromApi;
                    }


                    if (modelResponseRawContent || modelResponseMetadata.finishReason) {
                         const newModelMessage = {
                             role: 'model', content: modelResponseRawContent, timestamp: Date. 'model' && msg.isCascaded) {
                                if (currentGroupId === null && lastUserIndex !==now(),
                             ...modelResponseMetadata, groundingMetadata: groundingMetadata, usageMetadata: usageMetadata
                         };

                         const targetUserIndexForCascade = userMessageIndex;
                         if (targetUserIndexForCascade !== -1) { -1) {
                                    currentGroupId = `imp-${Date.now()}-${Math.random().toString(
                             if (siblingGroupIdToUse === null) {
                                 siblingGroupIdToUse = `gid-${Date36).substring(2, 8)}`;
                                }
                                if (currentGroupId) {
                                    .now()}-${Math.random().toString(36).substring(2, 8)}`;
                             }
                             msg.siblingGroupId = currentGroupId;
                                }
                            } else {
                                currentGroupId = null;
newModelMessage.isCascaded = true;
                             newModelMessage.isSelected = true;
                             newModelMessage.siblingGroupId = siblingGroupIdToUse;

                             if (isRetry && firstResponseIndexForRetry !== -                            }
                        }
                        const groupIds = new Set(importedMessages.filter(m => m.sibling1 && state.currentMessages[firstResponseIndexForRetry] && !state.currentMessages[firstResponseIndexForGroupId).map(m => m.siblingGroupId));
                        groupIds.forEach(gid => {
                            constRetry].isCascaded) {
                                 state.currentMessages[firstResponseIndexForRetry].isCascaded = true;
                                 state.currentMessages[firstResponseIndexForRetry].siblingGroupId = siblingGroupIdToUse siblings = importedMessages.filter(m => m.siblingGroupId === gid);
                            const selected = siblings.filter(m =>;
                             }
                         }

                         const newModelIndex = state.currentMessages.length;
                         state.currentMessages m.isSelected);
                            if (selected.length === 0 && siblings.length > 0) {
.push(newModelMessage);
                         state.messageCollapsedStates.set(newModelIndex, false);
                                siblings[siblings.length - 1].isSelected = true;
                            } else if (selected.length >                         uiUtils.renderChatMessages();
                         await dbUtils.saveChat();
                    }
                } catch (error) {
                    console.error("Error during API call or response handling:", error);
                    const isAbort = error. 1) {
                                selected.slice(0, -1).forEach(m => m.isSelected = falsemessage === "リクエストがキャンセルされました。";
                    const displayErrorMessage = isAbort ? error.message : (error.message || "不明なエラーが発生しました");
                    const partialRawContent = state.partialStreamContent || error.cause);
                            }
                        });


                        const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
?.partialChunks?.join('');

                    if (partialRawContent && state.settings.streamingOutput) {
                         const final                        const newTitle = IMPORT_PREFIX + (fileNameWithoutExt || `Imported_${Date.now()}`);

                        constPartialContent = partialRawContent + `\n\n(${isAbort ? '中断されました' : 'エラーが発生しました'}) newChatData = {
                            messages: importedMessages, systemPrompt: importedSystemPrompt || '',
                            updatedAt`;
                         const partialMessage = {
                             role: 'model', content: finalPartialContent, timestamp: Date.now(), error: true,
                             finishReason: isAbort ? 'ABORTED' : (modelResponseMetadata.: Date.now(), createdAt: Date.now(),
                            title: newTitle.substring(0, 1finishReason || 'ERROR'),
                             ...(modelResponseMetadata.safetyRatings && { safetyRatings: modelResponseMetadata.00)
                        };
                        const newChatId = await new Promise((resolve, reject) => {
safetyRatings })
                         };
                         if (isRetry && isAbort) {
                             if (siblingGroupIdToUse === null) {
                                 siblingGroupIdToUse = `gid-${Date.now()}-${Math.random().toString                            const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                            const request =(36).substring(2, 8)}`;
                             }
                             partialMessage.isCascaded = true store.add(newChatData);
                            request.onsuccess = (event) => resolve(event.target.result;
                             partialMessage.siblingGroupId = siblingGroupIdToUse;
                             partialMessage.isSelected = true;
                             if ();
                            request.onerror = (event) => reject(event.target.error);
                        });
                        firstResponseIndexForRetry !== -1 && state.currentMessages[firstResponseIndexForRetry] && !state.currentMessages[firstResponseIndexForRetry].isCascaded) {
                                 state.currentMessages[firstResponseIndexForRetry].isCascaded = true;
                                 state.currentMessages[firstResponseIndexForRetry].siblingGroupId = siblingGroupIdToUse;
                             }
                         }

                         const newModelIndex = state.currentMessages.length;
                         state.currentMessages.push(partialMessage);
                         state.messageCollapsedStates.set(newModelIndex, false);
                         try {
                             await dbUtils.saveChat();
                             uiUtils.renderChatMessages();
                         } catch (saveError) {
                             console.error("Error saving chat after partial response:", saveError);
                             uiUtils.displayError(displayErrorMessage, !isAbort);
                         }
                    } else {
                        uiUtils.displayError(displayErrorMessage, !isAbort);
                    }
                } finally {
                    uiUtils.setSendingState(false);
                    state.abortController = null;
                    state.partialStreamContent = '';
                    if (state.settings.autoScrollOnNewMessage) {
                        uiUtils.scrollToBottom();
                    }
                    uiUtils.updateAttachmentBadgeVisibility();
                }
            },
            abortRequest() {
                if (state.abortController) {
                    state.abortController.abort();
                }
            },
            async handleHistoryImport(file) {
                if (!file || !file.type.startsWith('text/plain')) {
                    await uiUtils.showCustomAlert("テキストファイル (.txt) を選択してください。");
                    return;
                }
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const textContent = event.target.result;
                    if (!textContent) {
                        await uiUtils.showCustomAlert("ファイルの内容が空です。");
                        return;
                    }
                    try {
                        const { messages: importedMessages, systemPrompt: importedSystemPrompt } = this.parseImportedHistory(textContent);
                        if (importedMessages.length === 0 && !importedSystemPrompt) {await uiUtils.showCustomAlert(`履歴「${newChatData.title}」をインポートしました。`);
                            await uiUtils.showCustomAlert("ファイルから有効なメッセージまたはシステムプロンプトを読み込めませんでした。
                        uiUtils.renderHistoryList();
                    } catch (error) {
                        console.error("History import形式を確認してください。");
                            return;
                        }

                        let currentGroupId = null;
                        let lastUser error:", error);
                        await uiUtils.showCustomAlert(`履歴のインポート中にエラーが発生しました: ${Index = -1;
                        for (let i = 0; i < importedMessages.length; i++)error.message}`);
                    }
                };
                reader.onerror = async (event) => {
                    console.error {
                            const msg = importedMessages[i];
                            if (msg.role === 'user') {
("File read error:", event.target.error);
                    await uiUtils.showCustomAlert("ファイルの読み込みに失敗                                lastUserIndex = i;
                                currentGroupId = null;
                            } else if (msg.role ===しました。");
                };
                reader.readAsText(file);
            },
            parseImported 'model' && msg.isCascaded) {
                                if (currentGroupId === null && lastUserIndex !==History(text) {
                const messages = [];
                let systemPrompt = '';
                const blockRegex = /<\| -1) {
                                    currentGroupId = `imp-${Date.now()}-${Math.random().toString(#\|(system|user|model)\|#\|([^>]*)>([\s\S]*?)<\|#\|\/\136).substring(2, 8)}`;
                                }
                                if (currentGroupId) {
                                    msg.siblingGroupId = currentGroupId;
                                }
                            } else {
                                currentGroupId = null;
\|#\|>/g;
                let match;

                while ((match = blockRegex.exec(text)) !== null)                            }
                        }
                        const groupIds = new Set(importedMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                        groupIds.forEach(gid => {
                            const {
                    const role = match[1];
                    const attributesString = match[2].trim();
                    const content = match[3].trim();

                    if (role === 'system' && content) {
                        systemPrompt siblings = importedMessages.filter(m => m.siblingGroupId === gid);
                            const selected = siblings.filter(m => = content;
                    } else if ((role === 'user' || role === 'model') && (content || m.isSelected);
                            if (selected.length === 0 && siblings.length > 0) {
 attributesString.includes('attachments'))) {
                        const messageData = {
                            role: role, content: content                                siblings[siblings.length - 1].isSelected = true;
                            } else if (selected.length > 1), timestamp: Date.now(), attachments: []
                        };
                        const attributes = {};
                        attributesString. {
                                selected.slice(0, -1).forEach(m => m.isSelected = false);
                            split(/\s+/).forEach(attr => {
                            const eqIndex = attr.indexOf('=');
                            if}
                        });


                        const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
 (eqIndex > 0) {
                                const key = attr.substring(0, eqIndex);
                                                       const newTitle = IMPORT_PREFIX + (fileNameWithoutExt || `Imported_${Date.now()}`);

                        const let value = attr.substring(eqIndex + 1);
                                if (value.startsWith('"') && value.endsWith('"')) {
                                    value = value.substring(1, value.length - 1);
 newChatData = {
                            messages: importedMessages, systemPrompt: importedSystemPrompt || '',
                            updatedAt: Date.                                }
                                attributes[key] = value.replace(/&quot;/g, '"');
                            } elsenow(), createdAt: Date.now(),
                            title: newTitle.substring(0, 100) if (attr) {
                                attributes[attr] = true;
                            }
                        });

                        if (
                        };
                        const newChatId = await new Promise((resolve, reject) => {
                            const storerole === 'model') {
                            messageData.isCascaded = attributes['isCascaded'] === true; = dbUtils._getStore(CHATS_STORE, 'readwrite');
                            const request = store.add
                            messageData.isSelected = attributes['isSelected'] === true;
                        }
                        if (role === 'user' && attributes['attachments']) {
                            const fileNames = attributes['attachments'].split(';');
                            messageData.(newChatData);
                            request.onsuccess = (event) => resolve(event.target.result);
                            request.onerror = (event) => reject(event.target.error);
                        });
                        attachments = fileNames.map(name => ({
                                name: name, mimeType: 'unknown/unknown',await uiUtils.showCustomAlert(`履歴「${newChatData.title}」をインポートしました。`); base64Data: ''
                            }));
                        }
                        messages.push(messageData);
                    }
                }
                return { messages, systemPrompt };
            },
            async exportAllSessions() {
                const confirmed = await ui
                        uiUtils.renderHistoryList();
                    } catch (error) {
                        console.error("History importUtils.showCustomConfirm("全てのセッションを1つのJSONファイルとしてエクスポートしますか？");
                if (!confirmed error:", error);
                        await uiUtils.showCustomAlert(`履歴のインポート中にエラーが発生しました: ${error.message}`);
                    }
                };
                reader.onerror = async (event) => {
                    console.error) return;

                try {
                    const chats = await dbUtils.getAllChats();
                    if (!chats("File read error:", event.target.error);
                    await uiUtils.showCustomAlert("ファイルの読み込みに失敗 || chats.length === 0) {
                        await uiUtils.showCustomAlert("エクスポートするセしました。");
                };
                reader.readAsText(file);
            },
            parseImportedッションがありません。");
                        return;
                    }

                    const exportableChats = chats.map(chatHistory(text) {
                const messages = [];
                let systemPrompt = '';
                const blockRegex = /<\| => ({
                        title: chat.title,
                        systemPrompt: chat.systemPrompt,
                        messages:#\|(system|user|model)\|#\|([^>]*)>([\s\S]*?)<\|#\|\/\1\|#\|>/g;
                let match;

                while ((match = blockRegex.exec(text)) !== null chat.messages.map(msg => {
                            const messageExport = {
                                role: msg.role,
                                content: msg.content,
                                timestamp: msg.timestamp,
                            };
                            if (msg) {
                    const role = match[1];
                    const attributesString = match[2].trim();
                    const.isCascaded !== undefined) messageExport.isCascaded = msg.isCascaded;
                            if ( content = match[3].trim();

                    if (role === 'system' && content) {
                        systemPrompt = content;
                    } else if ((role === 'user' || role === 'model') && (content ||msg.isSelected !== undefined) messageExport.isSelected = msg.isSelected;
                            if (msg.siblingGroupId !== attributesString.includes('attachments'))) {
                        const messageData = {
                            role: role, content: content undefined) messageExport.siblingGroupId = msg.siblingGroupId;
                            if (msg.groundingMetadata) message, timestamp: Date.now(), attachments: []
                        };
                        const attributes = {};
                        attributesString.split(/\s+/).forEach(attr => {
                            const eqIndex = attr.indexOf('=');
                            if (eqExport.groundingMetadata = msg.groundingMetadata;
                            if (msg.usageMetadata) messageExport.Index > 0) {
                                const key = attr.substring(0, eqIndex);
                                let value = attr.usageMetadata = msg.usageMetadata;
                            if (msg.attachments && msg.attachments.length > 0substring(eqIndex + 1);
                                if (value.startsWith('"') && value.endsWith('"')) {) {
                                messageExport.attachments = msg.attachments.map(att => ({ name: att.name,
                                    value = value.substring(1, value.length - 1);
                                }
                                attributes mimeType: att.mimeType }));
                            }
                            return messageExport;
                        }),
                        createdAt: chat.createdAt[key] = value.replace(/&quot;/g, '"');
                            } else if (attr) {,
                        updatedAt: chat.updatedAt,
                        ...(state.settings.persistMessageCollapseState && chat
                                attributes[attr] = true;
                            }
                        });

                        if (role === 'model').collapsedStates && { collapsedStates: chat.collapsedStates })
                    }));

                    const jsonString = JSON. {
                            messageData.isCascaded = attributes['isCascaded'] === true;
                            messageData.stringify(exportableChats, null, 2);
                    const blob = new Blob([jsonString], { typeisSelected = attributes['isSelected'] === true;
                        }
                        if (role === 'user' && attributes['attachments']) {: 'application/json;charset=utf-8' });
                    const url = URL.createObjectURL(blob
                            const fileNames = attributes['attachments'].split(';');
                            messageData.attachments = fileNames.map);
                    const a = document.createElement('a');
                    const timestamp = new Date().toISOString().slice((name => ({
                                name: name, mimeType: 'unknown/unknown', base64Data: ''
                            }));
                        }
                        messages.push(messageData);
                    }
                }
                return { messages0, 10).replace(/-/g, '');
                    a.href = url;
                    a., systemPrompt };
            },
            async exportAllSessions() {
                const confirmed = await uiUtils.showCustomdownload = `gemini_pwa_all_sessions_${timestamp}.json`;
                    document.body.appendChildConfirm("全てのセッションを1つのJSONファイルとしてエクスポートしますか？");
                if (!confirmed) return;

(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revoke                try {
                    const chats = await dbUtils.getAllChats();
                    if (!chats || chats.length === 0ObjectURL(url);
                    await uiUtils.showCustomAlert(`${chats.length}件のセッションをエ) {
                        await uiUtils.showCustomAlert("エクスポートするセッションがありません。");
                        return;
                    }

                    const exportableChats = chats.map(chat => ({
                        title: chatクスポートしました。`);
                } catch (error) {
                    await uiUtils.showCustomAlert(`全.title,
                        systemPrompt: chat.systemPrompt,
                        messages: chat.messages.map(msg => {セッションのエクスポート中にエラーが発生しました: ${error.message || error}`);
                    console.error("Error exporting all sessions
                            const messageExport = {
                                role: msg.role,
                                content: msg.content,
:", error);
                }
            },
            async handleAllSessionsImport(file) {
                if (!                                timestamp: msg.timestamp,
                            };
                            if (msg.isCascaded !== undefined) messageExportfile || file.type !== 'application/json') {
                    await uiUtils.showCustomAlert("JSONファイル (.json).isCascaded = msg.isCascaded;
                            if (msg.isSelected !== undefined) messageExport.isSelected = msg.isSelected;
                            if (msg.siblingGroupId !== undefined) messageExport.siblingGroupId = msg を選択してください。");
                    return;
                }
                const reader = new FileReader();
                reader..siblingGroupId;
                            if (msg.groundingMetadata) messageExport.groundingMetadata = msg.groundingMetadata;
                            if (msg.usageMetadata) messageExport.usageMetadata = msg.usageMetadata;
onload = async (event) => {
                    const textContent = event.target.result;
                    if (!                            if (msg.attachments && msg.attachments.length > 0) {
                                messageExport.attachments = msg.attachments.map(att => ({ name: att.name, mimeType: att.mimeType }));
textContent) {
                        await uiUtils.showCustomAlert("ファイルの内容が空です。");
                        return;                            }
                            return messageExport;
                        }),
                        createdAt: chat.createdAt,
                        updatedAt: chat.
                    }
                    try {
                        const importedData = JSON.parse(textContent);
                        if (!ArrayupdatedAt,
                        ...(state.settings.persistMessageCollapseState && chat.collapsedStates && { collapsedStates:.isArray(importedData)) {
                            await uiUtils.showCustomAlert("無効なファイル形式です。チャ chat.collapsedStates })
                    }));

                    const jsonString = JSON.stringify(exportableChats, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json;charset=ットデータの配列ではありません。");
                            return;
                        }

                        if (importedData.length === 0) {utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.
                            await uiUtils.showCustomAlert("ファイルにインポート対象のセッションデータが含まれていません。");createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 10).replace(
                            return;
                        }

                        const confirmed = await uiUtils.showCustomConfirm(
                            `${imported/-/g, '');
                    a.href = url;
                    a.download = `gemini_pwa_all_sessions_${timestamp}.json`;
                    document.body.appendChild(a);
                    a.clickData.length}件のセッションをインポートしますか？\n(既存の履歴とタイトルが重複();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    await uiする場合、別履歴として追加されます)`
                        );
                        if (!confirmed) return;

                        let importedCount = 0Utils.showCustomAlert(`${chats.length}件のセッションをエクスポートしました。`);
                } catch (;
                        let skippedCount = 0;
                        const importTimestamp = Date.now();

                        for (const chaterror) {
                    await uiUtils.showCustomAlert(`全セッションのエクスポート中にエラーが発生しました: ${error.message || error}`);
                    console.error("Error exporting all sessions:", error);
                }
            },Data of importedData) {
                            if (typeof chatData.title !== 'string' || !Array.isArray(chatData
            async handleAllSessionsImport(file) {
                if (!file || file.type !== 'application/json') {
                    await uiUtils.showCustomAlert("JSONファイル (.json) を選択してください。");
                    return.messages)) {
                                skippedCount++;
                                continue;
                            }

                            const newChat = {
;
                }
                const reader = new FileReader();
                reader.onload = async (event) => {                                title: `${IMPORT_PREFIX}(全) ${chatData.title}`.substring(0,100
                    const textContent = event.target.result;
                    if (!textContent) {
                        await uiUtils),
                                systemPrompt: chatData.systemPrompt || '',
                                messages: (chatData.messages || [].showCustomAlert("ファイルの内容が空です。");
                        return;
                    }
                    try {
).map(msg => ({
                                    role: msg.role,
                                    content: msg.content ||                        const importedData = JSON.parse(textContent);
                        if (!Array.isArray(importedData)) {
                            await '',
                                    timestamp: typeof msg.timestamp === 'number' ? msg.timestamp : importTimestamp,
                                uiUtils.showCustomAlert("無効なファイル形式です。チャットデータの配列ではありません。");
                            return;
                        }

                        if (importedData.length === 0) {
                            await uiUtils.showCustom     isCascaded: msg.isCascaded === true,
                                    isSelected: msg.isSelected === true,Alert("ファイルにインポート対象のセッションデータが含まれていません。");
                            return;
                        }

                        const confirmed = await uiUtils.showCustomConfirm(
                            `${importedData.length}件のセッション
                                    siblingGroupId: msg.siblingGroupId || undefined,
                                    attachments: (msg.attachments || []をインポートしますか？\n(既存の履歴とタイトルが重複する場合、別履歴として追加されます)`).map(att => ({
                                        name: att.name || 'imported_file',
                                        mime
                        );
                        if (!confirmed) return;

                        let importedCount = 0;
                        let skippedCount = 0;
                        const importTimestamp = Date.now();

                        for (const chatData of importedData) {Type: att.mimeType || 'application/octet-stream',
                                        base64Data: ''

                            if (typeof chatData.title !== 'string' || !Array.isArray(chatData.messages))                                    })),
                                    groundingMetadata: msg.groundingMetadata || undefined,
                                    usageMetadata {
                                skippedCount++;
                                continue;
                            }

                            const newChat = {
                                title: `${IMPORT_PREFIX}(全) ${chatData.title}`.substring(0,100),
                                system: msg.usageMetadata || undefined,
                                    error: msg.error || undefined,
                                })),
                               Prompt: chatData.systemPrompt || '',
                                messages: (chatData.messages || []).map(msg createdAt: typeof chatData.createdAt === 'number' ? chatData.createdAt : importTimestamp,
                                updatedAt: typeof chatData => ({
                                    role: msg.role,
                                    content: msg.content || '',
                                    .updatedAt === 'number' ? chatData.updatedAt : importTimestamp,
                            };
                            if (timestamp: typeof msg.timestamp === 'number' ? msg.timestamp : importTimestamp,
                                    isCascaded: msg.isCascaded === true,
                                    isSelected: msg.isSelected === true,
                                    siblingstate.settings.persistMessageCollapseState && chatData.collapsedStates) {
                                newChat.collapsedStates =GroupId: msg.siblingGroupId || undefined,
                                    attachments: (msg.attachments || []).map(att { ...chatData.collapsedStates };
                            }


                            const groupIds = new Set(newChat.messages => ({
                                        name: att.name || 'imported_file',
                                        mimeType: att..filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                            groupIds.mimeType || 'application/octet-stream',
                                        base64Data: ''
                                    })),forEach(gid => {
                                const siblings = newChat.messages.filter(m => m.siblingGroupId === gid);

                                    groundingMetadata: msg.groundingMetadata || undefined,
                                    usageMetadata: msg.usage                                const selectedSiblings = siblings.filter(m => m.isSelected);
                                if (selectedSiblings.Metadata || undefined,
                                    error: msg.error || undefined,
                                })),
                                createdAt: typeof chatData.createdAt === 'number' ? chatData.createdAt : importTimestamp,
                                updatedAt: typeof chatData.updatedAt === 'number' ? chatData.updatedAt : importTimestamp,
                            };
                            if (state.settings.length === 0 && siblings.length > 0) {
                                    siblings[siblings.length - 1].isSelectedpersistMessageCollapseState && chatData.collapsedStates) {
                                newChat.collapsedStates = { ...chatData = true;
                                } else if (selectedSiblings.length > 1) {
                                    for (.collapsedStates };
                            }


                            const groupIds = new Set(newChat.messages.filter(mlet i = 0; i < selectedSiblings.length - 1; i++) {
                                        selected => m.siblingGroupId).map(m => m.siblingGroupId));
                            groupIds.forEach(gid =>Siblings[i].isSelected = false;
                                    }
                                }
                            });

                            try {
                                await {
                                const siblings = newChat.messages.filter(m => m.siblingGroupId === gid);
                                new Promise((resolve, reject) => {
                                    const store = dbUtils._getStore(CHATS_ const selectedSiblings = siblings.filter(m => m.isSelected);
                                if (selectedSiblings.length === 0STORE, 'readwrite');
                                    const request = store.add(newChat);
                                    request. && siblings.length > 0) {
                                    siblings[siblings.length - 1].isSelected = true;
                                } else if (selectedSiblings.length > 1) {
                                    for (let i = onsuccess = () => {
                                        importedCount++;
                                        resolve();
                                    };
                               0; i < selectedSiblings.length - 1; i++) {
                                        selectedSiblings[i].isSelected = false;
                                    }
                                }
                            });

                            try {
                                await new Promise((resolve     request.onerror = (e) => {
                                        console.error("Failed to import session:", chatData.title, reject) => {
                                    const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                                    const request = store.add(newChat);
                                    request.onsuccess =, e.target.error);
                                        skippedCount++;
                                        resolve();
                                    };
                                });
                             () => {
                                        importedCount++;
                                        resolve();
                                    };
                                    request.onerror} catch (e) {
                                console.error("Error during DB operation for session:", chatData.title, e);
 = (e) => {
                                        console.error("Failed to import session:", chatData.title, e.target.error);
                                        skippedCount++;
                                        resolve();
                                    };
                                });
                                                            skippedCount++;
                            }
                        }

                        let message = `${importedCount}件のセッションを} catch (e) {
                                console.error("Error during DB operation for session:", chatData.title, e);
                                skippedCount++;
                            }
                        }

                        let message = `${importedCount}件のセッションをインポートしました。`;
                        if (skippedCount > 0) {
                            message += ` ${skippedCountインポートしました。`;
                        if (skippedCount > 0) {
                            message += ` ${skippedCount}件は形式エラー等でスキップされました。`;
                        }
                        await uiUtils.showCustomAlert}件は形式エラー等でスキップされました。`;
                        }
                        await uiUtils.showCustomAlert((message);
                        if (importedCount > 0) {
                            uiUtils.renderHistoryList();
message);
                        if (importedCount > 0) {
                            uiUtils.renderHistoryList();
                        }

                        }

                    } catch (error) {
                        await uiUtils.showCustomAlert(`全セッションのイン                    } catch (error) {
                        await uiUtils.showCustomAlert(`全セッションのインポート中にエラーが発生ポート中にエラーが発生しました: ${error.message || error}`);
                        console.error("Error importing all sessions:",しました: ${error.message || error}`);
                        console.error("Error importing all sessions:", error);
                    }
                 error);
                    }
                };
                reader.onerror = async () => {
                    await uiUtils.};
                reader.onerror = async () => {
                    await uiUtils.showCustomAlert("ファイルの読み込みに失敗showCustomAlert("ファイルの読み込みに失敗しました。");
                };
                reader.readAsText(fileしました。");
                };
                reader.readAsText(file);
            },
             async handleBackgroundImage);
            },
             async handleBackgroundImageUpload(file) {
                 const maxSize = 5 * 102Upload(file) {
                 const maxSize = 5 * 1024 * 1024;
                 if (file.size > maxSize) {
                     await uiUtils.showCustomAlert(`画像サイズが4 * 1024;
                 if (file.size > maxSize) {
                     await uiUtils大きすぎます (${(maxSize / 1024 / 1024).toFixed(1)}.showCustomAlert(`画像サイズが大きすぎます (${(maxSize / 1024 / 1MB以下にしてください)`);
                     return;
                 }
                 if (!file.type.startsWith('image/024).toFixed(1)}MB以下にしてください)`);
                     return;
                 }
                 if (!file.type.startsWith('image/')) {
                     await uiUtils.showCustomAlert("画像ファイルを選択してください (')) {
                     await uiUtils.showCustomAlert("画像ファイルを選択してください (JPEG, PNG, GIF, WebPなど)");
                     return;
                 }

                 try {
                     uiUtils.revokeExistingObjectUrl();
                     constJPEG, PNG, GIF, WebPなど)");
                     return;
                 }

                 try {
                     uiUtils.revoke blob = file;
                     await dbUtils.saveSetting('backgroundImageBlob', blob);
                     state.settings.backgroundImageBlob =ExistingObjectUrl();
                     const blob = file;
                     await dbUtils.saveSetting('backgroundImageBlob', blob);
                     state.settings.backgroundImageBlob = blob;
                     state.backgroundImageUrl = URL.createObjectURL(blob);
 blob;
                     state.backgroundImageUrl = URL.createObjectURL(blob);
                     document.documentElement.style.setProperty('--chat                     document.documentElement.style.setProperty('--chat-background-image', `url(${state.backgroundImageUrl})`);-background-image', `url(${state.backgroundImageUrl})`);
                     uiUtils.updateBackgroundSettingsUI();
                 } catch (error) {
                     console.error("Background image upload error:", error);
                     await uiUtils.
                     uiUtils.updateBackgroundSettingsUI();
                 } catch (error) {
                     console.error("showCustomAlert(`背景画像の処理中にエラーが発生しました: ${error}`);
                     uiUtils.revokeExistingObjectUrl();
                     Background image upload error:", error);
                     await uiUtils.showCustomAlert(`背景画像の処理中にエラーが発生しましたdocument.documentElement.style.setProperty('--chat-background-image', 'none');
                     state.settings.backgroundImage: ${error}`);
                     uiUtils.revokeExistingObjectUrl();
                     document.documentElement.style.setProperty('--chat-background-image', 'none');
                     state.settings.backgroundImageBlob = null;
                     uiUtilsBlob = null;
                     uiUtils.updateBackgroundSettingsUI();
                 }
             },
             async confirmDeleteBackgroundImage() {
                 const confirmed = await uiUtils.showCustomConfirm("背景画像を削除しますか？");
.updateBackgroundSettingsUI();
                 }
             },
             async confirmDeleteBackgroundImage() {
                 const confirmed = await uiUtils.showCustomConfirm("背景画像を削除しますか？");
                 if (confirmed) {
                                      if (confirmed) {
                     await this.handleBackgroundImageDelete();
                 }
             },
             async handleBackgroundImageDeleteawait this.handleBackgroundImageDelete();
                 }
             },
             async handleBackgroundImageDelete() {
                 try() {
                 try {
                     uiUtils.revokeExistingObjectUrl();
                     await dbUtils.saveSetting {
                     uiUtils.revokeExistingObjectUrl();
                     await dbUtils.saveSetting('backgroundImageBlob', null('backgroundImageBlob', null);
                     state.settings.backgroundImageBlob = null;
                     document.documentElement.style.);
                     state.settings.backgroundImageBlob = null;
                     document.documentElement.style.setProperty('--chat-setProperty('--chat-background-image', 'none');
                     uiUtils.updateBackgroundSettingsUI();
                 }background-image', 'none');
                     uiUtils.updateBackgroundSettingsUI();
                 } catch (error) catch (error) {
                     console.error("Background image delete error:", error);
                     await uiUtils. {
                     console.error("Background image delete error:", error);
                     await uiUtils.showCustomAlert(`showCustomAlert(`背景画像の削除中にエラーが発生しました: ${error}`);
                 }
             },
            async背景画像の削除中にエラーが発生しました: ${error}`);
                 }
             },
            async handleIconUpload( handleIconUpload(type, file) {
                 const maxSize = 1 * 1024 * type, file) {
                 const maxSize = 1 * 1024 * 1024;
                 1024;
                 if (file.size > maxSize) {
                     await uiUtils.showCustomif (file.size > maxSize) {
                     await uiUtils.showCustomAlert(`画像サイズが大きすぎます (${(Alert(`画像サイズが大きすぎます (${(maxSize / 1024 / 1024).maxSize / 1024 / 1024).toFixed(1)}MB以下)。`);
toFixed(1)}MB以下)。`);
                     return;
                 }
                 if (!file.type.startsWith('image/                     return;
                 }
                 if (!file.type.startsWith('image/')) {
                     await uiUtils.showCustomAlert("画像ファイルを選択してください。");
                     return;
                 }

                 try {
                     ')) {
                     await uiUtils.showCustomAlert("画像ファイルを選択してください。");
                     return;
                 const blob = file;
                     if (type === 'user') {
                         if(state.userIconUrl}

                 try {
                     const blob = file;
                     if (type === 'user') {
                         ) URL.revokeObjectURL(state.userIconUrl);
                         await dbUtils.saveSetting('userIconBlob', blobif(state.userIconUrl) URL.revokeObjectURL(state.userIconUrl);
                         await dbUtils.saveSetting('userIconBlob', blob);
                         state.settings.userIconBlob = blob;
                         state.userIcon);
                         state.settings.userIconBlob = blob;
                         state.userIconUrl = URL.createObjectURL(blobUrl = URL.createObjectURL(blob);
                     } else if (type === 'ai') {
                         if();
                     } else if (type === 'ai') {
                         if(state.aiIconUrl) URL.state.aiIconUrl) URL.revokeObjectURL(state.aiIconUrl);
                         await dbUtils.saverevokeObjectURL(state.aiIconUrl);
                         await dbUtils.saveSetting('aiIconBlob', blob);Setting('aiIconBlob', blob);
                         state.settings.aiIconBlob = blob;
                         state.aiIcon
                         state.settings.aiIconBlob = blob;
                         state.aiIconUrl = URL.createObjectURL(Url = URL.createObjectURL(blob);
                     }
                     uiUtils.updateIconSettingsUI();
                     blob);
                     }
                     uiUtils.updateIconSettingsUI();
                     uiUtils.renderChatMessages(uiUtils.renderChatMessages(true);
                 } catch (error) {
                     console.error(`${type} icon uploadtrue);
                 } catch (error) {
                     console.error(`${type} icon upload error:`, error);
 error:`, error);
                     await uiUtils.showCustomAlert(`${type === 'user' ? 'ユーザー' : 'AI                     await uiUtils.showCustomAlert(`${type === 'user' ? 'ユーザー' : 'AI'}アイコンの処理'}アイコンの処理エラー: ${error}`);
                 }
            },
            async confirmDeleteIcon(type) {
                エラー: ${error}`);
                 }
            },
            async confirmDeleteIcon(type) {
                const iconName =const iconName = type === 'user' ? 'ユーザー' : 'AI';
                const confirmed = await ui type === 'user' ? 'ユーザー' : 'AI';
                const confirmed = await uiUtils.showCustomUtils.showCustomConfirm(`${iconName}アイコンを削除しますか？`);
                if (confirmed) {
Confirm(`${iconName}アイコンを削除しますか？`);
                if (confirmed) {
                    await this.handle                    await this.handleIconDelete(type);
                }
            },
            async handleIconDelete(typeIconDelete(type);
                }
            },
            async handleIconDelete(type) {
                 try {
                     ) {
                 try {
                     if (type === 'user') {
                         if (state.userIconUrl)if (type === 'user') {
                         if (state.userIconUrl) URL.revokeObjectURL(state.user URL.revokeObjectURL(state.userIconUrl);
                         state.userIconUrl = null;
                         stateIconUrl);
                         state.userIconUrl = null;
                         state.settings.userIconBlob = null.settings.userIconBlob = null;
                         await dbUtils.saveSetting('userIconBlob', null);;
                         await dbUtils.saveSetting('userIconBlob', null);
                     } else if (type === 'ai
                     } else if (type === 'ai') {
                         if (state.aiIconUrl) URL.revokeObjectURL') {
                         if (state.aiIconUrl) URL.revokeObjectURL(state.aiIconUrl);
(state.aiIconUrl);
                         state.aiIconUrl = null;
                         state.settings.ai                         state.aiIconUrl = null;
                         state.settings.aiIconBlob = null;
                         awaitIconBlob = null;
                         await dbUtils.saveSetting('aiIconBlob', null);
                     }
                     ui dbUtils.saveSetting('aiIconBlob', null);
                     }
                     uiUtils.updateIconSettingsUIUtils.updateIconSettingsUI();
                     uiUtils.renderChatMessages(true);
                 } catch (error();
                     uiUtils.renderChatMessages(true);
                 } catch (error) {
                     console.) {
                     console.error(`${type} icon delete error:`, error);
                     await uiUtils.showCustomAlerterror(`${type} icon delete error:`, error);
                     await uiUtils.showCustomAlert(`${type === 'user(`${type === 'user' ? 'ユーザー' : 'AI'}アイコンの削除エラー: ${error}`);
                 }' ? 'ユーザー' : 'AI'}アイコンの削除エラー: ${error}`);
                 }
            },

            },
            async saveSettings() {
                 const newSettings = {
                     apiKey: elements.apiKey            async saveSettings() {
                 const newSettings = {
                     apiKey: elements.apiKeyInput.value.Input.value.trim(),
                     modelName: elements.modelNameSelect.value,
                     streamingOutput:trim(),
                     modelName: elements.modelNameSelect.value,
                     streamingOutput: elements.streamingOutput elements.streamingOutputCheckbox.checked,
                     streamingSpeed: elements.streamingSpeedInput.value === '' ? DEFAULT_STREAMCheckbox.checked,
                     streamingSpeed: elements.streamingSpeedInput.value === '' ? DEFAULT_STREAMING_SPEED :ING_SPEED : parseInt(elements.streamingSpeedInput.value),
                     systemPrompt: elements.systemPromptDefault parseInt(elements.streamingSpeedInput.value),
                     systemPrompt: elements.systemPromptDefaultTextarea.valueTextarea.value.trim(),
                     temperature: elements.temperatureInput.value === '' ? null : parseFloat(.trim(),
                     temperature: elements.temperatureInput.value === '' ? null : parseFloat(elements.temperatureInputelements.temperatureInput.value),
                     maxTokens: elements.maxTokensInput.value === '' ? null : parseInt.value),
                     maxTokens: elements.maxTokensInput.value === '' ? null : parseInt(elements.maxTokensInput(elements.maxTokensInput.value),
                     topK: elements.topKInput.value === '' ?.value),
                     topK: elements.topKInput.value === '' ? null : parseInt(elements. null : parseInt(elements.topKInput.value),
                     topP: elements.topPInput.value === '' ?topKInput.value),
                     topP: elements.topPInput.value === '' ? null : parseFloat null : parseFloat(elements.topPInput.value),
                     presencePenalty: elements.presencePenaltyInput.value(elements.topPInput.value),
                     presencePenalty: elements.presencePenaltyInput.value === '' ? === '' ? null : parseFloat(elements.presencePenaltyInput.value),
                     frequencyPenalty: elements.frequencyPenalty null : parseFloat(elements.presencePenaltyInput.value),
                     frequencyPenalty: elements.frequencyPenaltyInput.valueInput.value === '' ? null : parseFloat(elements.frequencyPenaltyInput.value),
                     thinkingBudget: elements === '' ? null : parseFloat(elements.frequencyPenaltyInput.value),
                     thinkingBudget: elements.thinkingBudget.thinkingBudgetInput.value === '' ? null : parseInt(elements.thinkingBudgetInput.value, 10Input.value === '' ? null : parseInt(elements.thinkingBudgetInput.value, 10),
                     dummyUser:),
                     dummyUser: elements.dummyUserInput.value.trim(),
                     dummyModel: elements.dummyModel elements.dummyUserInput.value.trim(),
                     dummyModel: elements.dummyModelInput.value.trim(),Input.value.trim(),
                     concatDummyModel: elements.concatDummyModelCheckbox.checked,
                     additional
                     concatDummyModel: elements.concatDummyModelCheckbox.checked,
                     additionalModels: elements.additionalModelsModels: elements.additionalModelsTextarea.value.trim(),
                     pseudoStreaming: elements.pseudoStreamingCheckbox.Textarea.value.trim(),
                     pseudoStreaming: elements.pseudoStreamingCheckbox.checked,
                     enterToSendchecked,
                     enterToSend: elements.enterToSendCheckbox.checked,
                     autoScrollOnNewMessage: elements.auto: elements.enterToSendCheckbox.checked,
                     autoScrollOnNewMessage: elements.autoScrollOnNewMessageScrollOnNewMessageCheckbox.checked,
                     historySortOrder: elements.historySortOrderSelect.value,
                     theme:Checkbox.checked,
                     historySortOrder: elements.historySortOrderSelect.value,
                     theme: elements.themeSelect elements.themeSelect.value,
                     fontFamily: elements.fontFamilyInput.value.trim(),
                     .value,
                     fontFamily: elements.fontFamilyInput.value.trim(),
                     messageBodyFontSize:messageBodyFontSize: elements.messageBodyFontSizeInput.value === '' ? null : parseInt(elements.messageBodyFontSize elements.messageBodyFontSizeInput.value === '' ? null : parseInt(elements.messageBodyFontSizeInput.value,Input.value, 10),
                     codeBlockFontSize: elements.codeBlockFontSizeInput.value === '' 10),
                     codeBlockFontSize: elements.codeBlockFontSizeInput.value === '' ? null : parseInt ? null : parseInt(elements.codeBlockFontSizeInput.value, 10),
                     hideSystemPromptIn(elements.codeBlockFontSizeInput.value, 10),
                     hideSystemPromptInChat: elements.Chat: elements.hideSystemPromptToggle.checked,
                     enableGrounding: elements.enableGroundingToggle.checked,
hideSystemPromptToggle.checked,
                     enableGrounding: elements.enableGroundingToggle.checked,
                                          enableSwipeNavigation: elements.swipeNavigationToggle.checked,
                     preventZoom: elements.preventZoomToggle.enableSwipeNavigation: elements.swipeNavigationToggle.checked,
                     preventZoom: elements.preventZoomToggle.checked,
                     checked,
                     showNewChatButton: elements.showNewChatButtonToggle.checked,
                     showDeleteSessionshowNewChatButton: elements.showNewChatButtonToggle.checked,
                     showDeleteSessionButton: elements.Button: elements.showDeleteSessionButtonToggle.checked,
                     showCopySessionButton: elements.showCopySessionshowDeleteSessionButtonToggle.checked,
                     showCopySessionButton: elements.showCopySessionButtonToggle.checkedButtonToggle.checked,
                     showScrollToTopButton: elements.showScrollToTopButtonToggle.checked,,
                     showScrollToTopButton: elements.showScrollToTopButtonToggle.checked,
                     showScroll
                     showScrollToBottomButton: elements.showScrollToBottomButtonToggle.checked,
                     showToggleAllContentButton:ToBottomButton: elements.showScrollToBottomButtonToggle.checked,
                     showToggleAllContentButton: elements.showToggle elements.showToggleAllContentButtonToggle.checked,
                     showBulkHistoryActions: elements.showBulkHistoryActionsAllContentButtonToggle.checked,
                     showBulkHistoryActions: elements.showBulkHistoryActionsToggle.checked,Toggle.checked,
                     showPasteButtonInFooter: elements.showPasteButtonInFooterToggle.checked,

                     showPasteButtonInFooter: elements.showPasteButtonInFooterToggle.checked,
                     showPasteButtonInEdit:                     showPasteButtonInEdit: elements.showPasteButtonInEditToggle.checked,
                     showMemoButton: elements.showPasteButtonInEditToggle.checked,
                     showMemoButton: elements.showMemoButtonToggle. elements.showMemoButtonToggle.checked,
                     memoHeight: elements.memoHeightInput.value.trim()checked,
                     memoHeight: elements.memoHeightInput.value.trim() || DEFAULT_MEMO_HEIGHT,
                      || DEFAULT_MEMO_HEIGHT,
                     showClipboardStackButton: elements.showClipboardStackButtonToggle.checked,
                     showClipboardStackButton: elements.showClipboardStackButtonToggle.checked,
                     clipboardStackHeight: state.settingsclipboardStackHeight: state.settings.clipboardStackHeight,
                     showUserIcon: elements.showUserIconToggle.clipboardStackHeight,
                     showUserIcon: elements.showUserIconToggle.checked,
                     showUserName.checked,
                     showUserName: elements.showUserNameToggle.checked,
                     userName: elements.userNameInput: elements.showUserNameToggle.checked,
                     userName: elements.userNameInput.value.trim() || DEFAULT.value.trim() || DEFAULT_USER_NAME,
                     showAiIcon: elements.showAiIconToggle.checked,_USER_NAME,
                     showAiIcon: elements.showAiIconToggle.checked,
                     showAi
                     showAiName: elements.showAiNameToggle.checked,
                     aiName: elements.aiNameName: elements.showAiNameToggle.checked,
                     aiName: elements.aiNameInput.value.Input.value.trim() || DEFAULT_AI_NAME,
                     iconNameFontSize: parseInt(elements.icontrim() || DEFAULT_AI_NAME,
                     iconNameFontSize: parseInt(elements.iconNameFontSizeInput.NameFontSizeInput.value, 10) || DEFAULT_ICON_NAME_FONT_SIZE,
                     iconvalue, 10) || DEFAULT_ICON_NAME_FONT_SIZE,
                     iconNameOffsetY: (NameOffsetY: (elements.iconNameOffsetYInput.value === '' ? DEFAULT_ICON_NAME_OFFSET_Yelements.iconNameOffsetYInput.value === '' ? DEFAULT_ICON_NAME_OFFSET_Y : parseInt(elements.icon : parseInt(elements.iconNameOffsetYInput.value, 10) * -1),
                     messageIconSize:NameOffsetYInput.value, 10) * -1),
                     messageIconSize: parseInt(elements. parseInt(elements.messageIconSizeInput.value, 10) || DEFAULT_MESSAGE_ICON_SIZE,messageIconSizeInput.value, 10) || DEFAULT_MESSAGE_ICON_SIZE,
                     messageIcon
                     messageIconOffsetY: (elements.messageIconOffsetYInput.value === '' ? DEFAULT_MESSAGE_ICON_OffsetY: (elements.messageIconOffsetYInput.value === '' ? DEFAULT_MESSAGE_ICON_OFFSET_Y :OFFSET_Y : parseInt(elements.messageIconOffsetYInput.value, 10) * -1),
 parseInt(elements.messageIconOffsetYInput.value, 10) * -1),
                     showUserNameBubble                     showUserNameBubble: elements.userNameBubbleToggle.checked,
                     userNameBubbleUseThemeColor: elements.userName: elements.userNameBubbleToggle.checked,
                     userNameBubbleUseThemeColor: elements.userNameBubbleUseThemeColorToggle.BubbleUseThemeColorToggle.checked,
                     userNameBubbleColor: elements.userNameBubbleColorInput.value.trimchecked,
                     userNameBubbleColor: elements.userNameBubbleColorInput.value.trim() || DEFAULT_USER_() || DEFAULT_USER_NAME_BUBBLE_COLOR,
                     userNameBubbleOpacity: elements.userNameBubbleOpacityNAME_BUBBLE_COLOR,
                     userNameBubbleOpacity: elements.userNameBubbleOpacityInput.value === ''Input.value === '' ? DEFAULT_USER_NAME_BUBBLE_OPACITY : parseFloat(elements.userName ? DEFAULT_USER_NAME_BUBBLE_OPACITY : parseFloat(elements.userNameBubbleOpacityInput.valueBubbleOpacityInput.value),
                     showAiNameBubble: elements.aiNameBubbleToggle.checked,
                     ),
                     showAiNameBubble: elements.aiNameBubbleToggle.checked,
                     aiNameBubbleUseThemeaiNameBubbleUseThemeColor: elements.aiNameBubbleUseThemeColorToggle.checked,
                     aiNameBubbleColor: elements.aiNameBubbleUseThemeColorToggle.checked,
                     aiNameBubbleColor: elements.aiColor: elements.aiNameBubbleColorInput.value.trim() || DEFAULT_AI_NAME_BUBBLENameBubbleColorInput.value.trim() || DEFAULT_AI_NAME_BUBBLE_COLOR,
                     _COLOR,
                     aiNameBubbleOpacity: elements.aiNameBubbleOpacityInput.value === '' ? DEFAULT_aiNameBubbleOpacity: elements.aiNameBubbleOpacityInput.value === '' ? DEFAULT_AI_NAME_BUAI_NAME_BUBBLE_OPACITY : parseFloat(elements.aiNameBubbleOpacityInput.value),
BBLE_OPACITY : parseFloat(elements.aiNameBubbleOpacityInput.value),
                     showCollapseButtons:                     showCollapseButtons: elements.showCollapseButtonsToggle.checked,
                     persistMessageCollapseState: elements.persist elements.showCollapseButtonsToggle.checked,
                     persistMessageCollapseState: elements.persistMessageCollapseStateCheckbox.MessageCollapseStateCheckbox.checked,
                     messageBubbleOpacity: elements.messageBubbleOpacityInput.value === '' ?checked,
                     messageBubbleOpacity: elements.messageBubbleOpacityInput.value === '' ? DEFAULT_MESSAGE_BU DEFAULT_MESSAGE_BUBBLE_OPACITY : parseFloat(elements.messageBubbleOpacityInput.value),
                     BBLE_OPACITY : parseFloat(elements.messageBubbleOpacityInput.value),
                     chatOverlayOpacity: elementschatOverlayOpacity: elements.chatOverlayOpacityInput.value === '' ? DEFAULT_CHAT_OVERLAY_OPACITY.chatOverlayOpacityInput.value === '' ? DEFAULT_CHAT_OVERLAY_OPACITY : parseFloat(elements. : parseFloat(elements.chatOverlayOpacityInput.value),
                     headerFooterOpacity: elements.headerFooterOpacityInputchatOverlayOpacityInput.value),
                     headerFooterOpacity: elements.headerFooterOpacityInput.value === '' ?.value === '' ? DEFAULT_HEADER_FOOTER_OPACITY : parseFloat(elements.headerFooterOpacityInput. DEFAULT_HEADER_FOOTER_OPACITY : parseFloat(elements.headerFooterOpacityInput.value),
                     messageActionsBackgroundOpacity: elements.messageActionsBackgroundOpacityInput.value === '' ? DEFAULT_MESSAGE_ACTIONS_BACKGROUND_value),
                     messageActionsBackgroundOpacity: elements.messageActionsBackgroundOpacityInput.value === '' ? DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY : parseFloat(elements.messageActionsBackgroundOpacityInput.value),
                     toggleButtonTopWidthOPACITY : parseFloat(elements.messageActionsBackgroundOpacityInput.value),
                     toggleButtonTopWidth: parseInt(elements.toggle: parseInt(elements.toggleButtonTopWidthInput.value, 10) || DEFAULT_TOGGLE_BUTTONButtonTopWidthInput.value, 10) || DEFAULT_TOGGLE_BUTTON_TOP_WIDTH,
                     toggleButton_TOP_WIDTH,
                     toggleButtonTopHeight: parseInt(elements.toggleButtonTopHeightInput.value,TopHeight: parseInt(elements.toggleButtonTopHeightInput.value, 10) || DEFAULT_TOGGLE 10) || DEFAULT_TOGGLE_BUTTON_TOP_HEIGHT,
                     toggleButtonTopFontSize: parseInt_BUTTON_TOP_HEIGHT,
                     toggleButtonTopFontSize: parseInt(elements.toggleButtonTopFontSizeInput.value, (elements.toggleButtonTopFontSizeInput.value, 10) || DEFAULT_TOGGLE_BUTTON_TOP10) || DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE,
                     toggleButtonTopOpacity:_FONT_SIZE,
                     toggleButtonTopOpacity: elements.toggleButtonTopOpacityInput.value === '' ? elements.toggleButtonTopOpacityInput.value === '' ? DEFAULT_TOGGLE_BUTTON_TOP_OPACITY : parseFloat(elements DEFAULT_TOGGLE_BUTTON_TOP_OPACITY : parseFloat(elements.toggleButtonTopOpacityInput.value),.toggleButtonTopOpacityInput.value),
                     toggleButtonTopTextCollapse: elements.toggleButtonTopTextCollapseInput.
                     toggleButtonTopTextCollapse: elements.toggleButtonTopTextCollapseInput.value.trim() || DEFAULT_TOGvalue.trim() || DEFAULT_TOGGLE_BUTTON_TOP_TEXT_COLLAPSE,
                     toggleButtonGLE_BUTTON_TOP_TEXT_COLLAPSE,
                     toggleButtonTopTextExpand: elements.toggleButtonTopTextExpand: elements.toggleButtonTopTextExpandInput.value.trim() || DEFAULT_TOGGLE_BUTTONTopTextExpandInput.value.trim() || DEFAULT_TOGGLE_BUTTON_TOP_TEXT_EXPAND,_TOP_TEXT_EXPAND,
                     toggleButtonBottomFontSize: parseInt(elements.toggleButtonBottomFontSizeInput
                     toggleButtonBottomFontSize: parseInt(elements.toggleButtonBottomFontSizeInput.value, 10) ||.value, 10) || DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE,
                     toggle DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE,
                     toggleButtonBottomTextCollapse: elements.toggleButtonBottomTextButtonBottomTextCollapse: elements.toggleButtonBottomTextCollapseInput.value.trim() || DEFAULT_TOGGLE_CollapseInput.value.trim() || DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_COLLAPSE,
BUTTON_BOTTOM_TEXT_COLLAPSE,
                     toggleButtonBottomTextExpand: elements.toggleButtonBottomText                     toggleButtonBottomTextExpand: elements.toggleButtonBottomTextExpandInput.value.trim() || DEFAULT_TOGExpandInput.value.trim() || DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_EXPAND,
                 GLE_BUTTON_BOTTOM_TEXT_EXPAND,
                 };

                 if (isNaN(newSettings.streamingSpeed) ||};

                 if (isNaN(newSettings.streamingSpeed) || newSettings.streamingSpeed < 0) { newSettings.streamingSpeed < 0) {
                     newSettings.streamingSpeed = DEFAULT_STREAMING_SPEED
                     newSettings.streamingSpeed = DEFAULT_STREAMING_SPEED;
                 }
                 if (newSettings;
                 }
                 if (newSettings.temperature !== null && (isNaN(newSettings.temperature) ||.temperature !== null && (isNaN(newSettings.temperature) || newSettings.temperature < 0 || newSettings newSettings.temperature < 0 || newSettings.temperature > 2)) {
                     newSettings.temperature =.temperature > 2)) {
                     newSettings.temperature = null;
                 }
                 if (new null;
                 }
                 if (newSettings.maxTokens !== null && (isNaN(newSettings.maxSettings.maxTokens !== null && (isNaN(newSettings.maxTokens) || newSettings.maxTokens < Tokens) || newSettings.maxTokens < 1)) {
                     newSettings.maxTokens = null;
1)) {
                     newSettings.maxTokens = null;
                 }
                 if (newSettings.top                 }
                 if (newSettings.topK !== null && (isNaN(newSettings.topK) ||K !== null && (isNaN(newSettings.topK) || newSettings.topK < 1)) {
                      newSettings.topK < 1)) {
                     newSettings.topK = null;
                 }
newSettings.topK = null;
                 }
                 if (newSettings.topP !== null && (                 if (newSettings.topP !== null && (isNaN(newSettings.topP) || newSettings.isNaN(newSettings.topP) || newSettings.topP < 0 || newSettings.topP > 1topP < 0 || newSettings.topP > 1)) {
                     newSettings.topP =)) {
                     newSettings.topP = null;
                 }
                 if (newSettings.presencePenalty null;
                 }
                 if (newSettings.presencePenalty !== null && (isNaN(newSettings.presence !== null && (isNaN(newSettings.presencePenalty) || newSettings.presencePenalty < -2.0 ||Penalty) || newSettings.presencePenalty < -2.0 || newSettings.presencePenalty >= 2.0)) { newSettings.presencePenalty >= 2.0)) {
                     newSettings.presencePenalty = null;
                 
                     newSettings.presencePenalty = null;
                 }
                 if (newSettings.frequencyPenalty !== null}
                 if (newSettings.frequencyPenalty !== null && (isNaN(newSettings.frequencyPenalty) || new && (isNaN(newSettings.frequencyPenalty) || newSettings.frequencyPenalty < -2.0 || newSettingsSettings.frequencyPenalty < -2.0 || newSettings.frequencyPenalty >= 2.0)) {
                     .frequencyPenalty >= 2.0)) {
                     newSettings.frequencyPenalty = null;
                 }
newSettings.frequencyPenalty = null;
                 }
                 if (newSettings.thinkingBudget !== null && (                 if (newSettings.thinkingBudget !== null && (isNaN(newSettings.thinkingBudget) || newSettings.isNaN(newSettings.thinkingBudget) || newSettings.thinkingBudget < 0 || !Number.isInteger(thinkingBudget < 0 || !Number.isInteger(newSettings.thinkingBudget))) {
                     newSettings.newSettings.thinkingBudget))) {
                     newSettings.thinkingBudget = null;
                 }
                 if (thinkingBudget = null;
                 }
                 if (newSettings.messageBodyFontSize !== null && (isNaN(newSettings.messageBodyFontSize !== null && (isNaN(newSettings.messageBodyFontSize))) {
                    newSettingsnewSettings.messageBodyFontSize))) {
                    newSettings.messageBodyFontSize = DEFAULT_MESSAGE_BODY_FONT.messageBodyFontSize = DEFAULT_MESSAGE_BODY_FONT_SIZE;
                 }
                 if (newSettings_SIZE;
                 }
                 if (newSettings.codeBlockFontSize !== null && (isNaN(newSettings.codeBlockFontSize !== null && (isNaN(newSettings.codeBlockFontSize))) {
                    newSettings.code.codeBlockFontSize))) {
                    newSettings.codeBlockFontSize = DEFAULT_CODE_BLOCK_FONT_SIZEBlockFontSize = DEFAULT_CODE_BLOCK_FONT_SIZE;
                 }
                 if (newSettings.message;
                 }
                 if (newSettings.messageIconSize !== null && (isNaN(newSettings.messageIconSize)IconSize !== null && (isNaN(newSettings.messageIconSize) || newSettings.messageIconSize < 1 || new || newSettings.messageIconSize < 1 || newSettings.messageIconSize > 300)) {Settings.messageIconSize > 300)) {
                     newSettings.messageIconSize = DEFAULT_MESSAGE_ICON
                     newSettings.messageIconSize = DEFAULT_MESSAGE_ICON_SIZE;
                 }
                 if (newSettings_SIZE;
                 }
                 if (newSettings.messageIconOffsetY !== null && (isNaN(newSettings.messageIconOffsetY !== null && (isNaN(newSettings.messageIconOffsetY) || newSettings.messageIconOffsetY.messageIconOffsetY) || newSettings.messageIconOffsetY < -200 || newSettings.messageIconOffsetY < -200 || newSettings.messageIconOffsetY > 200)) {
                     newSettings. > 200)) {
                     newSettings.messageIconOffsetY = DEFAULT_MESSAGE_ICON_OFFSET_messageIconOffsetY = DEFAULT_MESSAGE_ICON_OFFSET_Y;
                 }
                 if (newSettings.Y;
                 }
                 if (newSettings.iconNameFontSize !== null && (isNaN(newSettings.iconNameFontSize !== null && (isNaN(newSettings.iconNameFontSize) || newSettings.iconNameFontSize <iconNameFontSize) || newSettings.iconNameFontSize < 1 || newSettings.iconNameFontSize > 4 1 || newSettings.iconNameFontSize > 46)) {
                     newSettings.iconNameFontSize =6)) {
                     newSettings.iconNameFontSize = DEFAULT_ICON_NAME_FONT_SIZE;
                  DEFAULT_ICON_NAME_FONT_SIZE;
                 }
                 if (newSettings.iconNameOffsetY !==}
                 if (newSettings.iconNameOffsetY !== null && (isNaN(newSettings.iconNameOffsetY) null && (isNaN(newSettings.iconNameOffsetY) || newSettings.iconNameOffsetY < -200 || newSettings.iconNameOffsetY < -200 || newSettings.iconNameOffsetY > 200 || newSettings.iconNameOffsetY > 200)) {
                     newSettings.iconNameOffsetY = DEFAULT)) {
                     newSettings.iconNameOffsetY = DEFAULT_ICON_NAME_OFFSET_Y;
                 }_ICON_NAME_OFFSET_Y;
                 }
                 if (!/^#([0-9A-Fa-f
                 if (!/^#([0-9A-Fa-f]{3}){1,2}$/.test(newSettings]{3}){1,2}$/.test(newSettings.userNameBubbleColor)) {
                    newSettings.userName.userNameBubbleColor)) {
                    newSettings.userNameBubbleColor = DEFAULT_USER_NAME_BUBBLEBubbleColor = DEFAULT_USER_NAME_BUBBLE_COLOR;
                 }
                 if (newSettings_COLOR;
                 }
                 if (newSettings.userNameBubbleOpacity !== null && (isNaN(newSettings.userNameBubbleOpacity !== null && (isNaN(newSettings.userNameBubbleOpacity) || newSettings.userNameBubbleOpacity.userNameBubbleOpacity) || newSettings.userNameBubbleOpacity < 0 || newSettings.userNameBubbleOpacity >  < 0 || newSettings.userNameBubbleOpacity > 1)) {
                    newSettings.userNameBubbleOpacity =1)) {
                    newSettings.userNameBubbleOpacity = DEFAULT_USER_NAME_BUBBLE_OPACITY DEFAULT_USER_NAME_BUBBLE_OPACITY;
                 }
                 if (!/^#([0;
                 }
                 if (!/^#([0-9A-Fa-f]{3}){1,-9A-Fa-f]{3}){1,2}$/.test(newSettings.aiNameBubbleColor2}$/.test(newSettings.aiNameBubbleColor)) {
                    newSettings.aiNameBubbleColor =)) {
                    newSettings.aiNameBubbleColor = DEFAULT_AI_NAME_BUBBLE_COLOR;
                  DEFAULT_AI_NAME_BUBBLE_COLOR;
                 }
                 if (newSettings.aiName}
                 if (newSettings.aiNameBubbleOpacity !== null && (isNaN(newSettings.aiNameBubbleBubbleOpacity !== null && (isNaN(newSettings.aiNameBubbleOpacity) || newSettings.aiNameBubbleOpacityOpacity) || newSettings.aiNameBubbleOpacity < 0 || newSettings.aiNameBubbleOpacity > 1 < 0 || newSettings.aiNameBubbleOpacity > 1)) {
                    newSettings.aiNameBubble)) {
                    newSettings.aiNameBubbleOpacity = DEFAULT_AI_NAME_BUBBLE_OPACITYOpacity = DEFAULT_AI_NAME_BUBBLE_OPACITY;
                 }
                 if (newSettings.messageBubble;
                 }
                 if (newSettings.messageBubbleOpacity !== null && (isNaN(newSettings.messageOpacity !== null && (isNaN(newSettings.messageBubbleOpacity) || newSettings.messageBubbleOpacity < 0BubbleOpacity) || newSettings.messageBubbleOpacity < 0 || newSettings.messageBubbleOpacity > 1)) || newSettings.messageBubbleOpacity > 1)) {
                    newSettings.messageBubbleOpacity = DEFAULT_MESSAGE_BU {
                    newSettings.messageBubbleOpacity = DEFAULT_MESSAGE_BUBBLE_OPACITY;
                 }
                 ifBBLE_OPACITY;
                 }
                 if (newSettings.chatOverlayOpacity !== null && (isNaN (newSettings.chatOverlayOpacity !== null && (isNaN(newSettings.chatOverlayOpacity) || newSettings.(newSettings.chatOverlayOpacity) || newSettings.chatOverlayOpacity < 0 || newSettings.chatOverlaychatOverlayOpacity < 0 || newSettings.chatOverlayOpacity > 1)) {
                    newSettings.chatOpacity > 1)) {
                    newSettings.chatOverlayOpacity = DEFAULT_CHAT_OVERLAY_OPACITYOverlayOpacity = DEFAULT_CHAT_OVERLAY_OPACITY;
                 }
                 if (newSettings.header;
                 }
                 if (newSettings.headerFooterOpacity !== null && (isNaN(newSettings.headerFooterOpacity)FooterOpacity !== null && (isNaN(newSettings.headerFooterOpacity) || newSettings.headerFooterOpacity < 0 || new || newSettings.headerFooterOpacity < 0 || newSettings.headerFooterOpacity > 1)) {
                    Settings.headerFooterOpacity > 1)) {
                    newSettings.headerFooterOpacity = DEFAULT_HEADER_FOOTnewSettings.headerFooterOpacity = DEFAULT_HEADER_FOOTER_OPACITY;
                 }
                 if (ER_OPACITY;
                 }
                 if (newSettings.messageActionsBackgroundOpacity !== null && (isNaNnewSettings.messageActionsBackgroundOpacity !== null && (isNaN(newSettings.messageActionsBackgroundOpacity) || newSettings(newSettings.messageActionsBackgroundOpacity) || newSettings.messageActionsBackgroundOpacity < 0 || newSettings..messageActionsBackgroundOpacity < 0 || newSettings.messageActionsBackgroundOpacity > 1)) {
                    newmessageActionsBackgroundOpacity > 1)) {
                    newSettings.messageActionsBackgroundOpacity = DEFAULT_MESSAGE_ACTIONSSettings.messageActionsBackgroundOpacity = DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY;
                 }
                 if_BACKGROUND_OPACITY;
                 }
                 if (newSettings.toggleButtonTopOpacity !== null && ( (newSettings.toggleButtonTopOpacity !== null && (isNaN(newSettings.toggleButtonTopOpacity) || newSettings.isNaN(newSettings.toggleButtonTopOpacity) || newSettings.toggleButtonTopOpacity < 0 || newSettings.toggletoggleButtonTopOpacity < 0 || newSettings.toggleButtonTopOpacity > 1)) {
                    newSettingsButtonTopOpacity > 1)) {
                    newSettings.toggleButtonTopOpacity = DEFAULT_TOGGLE_BUTTON_TOP_.toggleButtonTopOpacity = DEFAULT_TOGGLE_BUTTON_TOP_OPACITY;
                 }
                 if (isNaNOPACITY;
                 }
                 if (isNaN(newSettings.toggleButtonTopWidth) || newSettings.toggleButtonTop(newSettings.toggleButtonTopWidth) || newSettings.toggleButtonTopWidth < 1 || newSettings.toggleButtonTopWidth < 1 || newSettings.toggleButtonTopWidth > 100) {
                     newSettings.Width > 100) {
                     newSettings.toggleButtonTopWidth = DEFAULT_TOGGLE_BUTTON_TOP_toggleButtonTopWidth = DEFAULT_TOGGLE_BUTTON_TOP_WIDTH;
                 }
                 if (isNaNWIDTH;
                 }
                 if (isNaN(newSettings.toggleButtonTopHeight) || newSettings.toggle(newSettings.toggleButtonTopHeight) || newSettings.toggleButtonTopHeight < 1 || newSettings.toggleButtonButtonTopHeight < 1 || newSettings.toggleButtonTopHeight > 100) {
                     newTopHeight > 100) {
                     newSettings.toggleButtonTopHeight = DEFAULT_TOGGLE_Settings.toggleButtonTopHeight = DEFAULT_TOGGLE_BUTTON_TOP_HEIGHT;
                 }
                 ifBUTTON_TOP_HEIGHT;
                 }
                 if (isNaN(newSettings.toggleButtonTopFontSize) || (isNaN(newSettings.toggleButtonTopFontSize) || newSettings.toggleButtonTopFontSize < 1 || new newSettings.toggleButtonTopFontSize < 1 || newSettings.toggleButtonTopFontSize > 50) {
                     newSettings.toggleButtonTopFontSize = DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE;
                 }
Settings.toggleButtonTopFontSize > 50) {
                     newSettings.toggleButtonTopFontSize = DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE;
                 }
                 if (isNaN(newSettings.toggleButtonBottomFontSize                 if (isNaN(newSettings.toggleButtonBottomFontSize) || newSettings.toggleButtonBottomFontSize < 1 || new) || newSettings.toggleButtonBottomFontSize < 1 || newSettings.toggleButtonBottomFontSize > 34Settings.toggleButtonBottomFontSize > 34) {
                     newSettings.toggleButtonBottomFontSize = DEFAULT_) {
                     newSettings.toggleButtonBottomFontSize = DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZETOGGLE_BUTTON_BOTTOM_FONT_SIZE;
                 }


                 try {
                     const oldSortOrder = state;
                 }


                 try {
                     const oldSortOrder = state.settings.historySortOrder;
                     .settings.historySortOrder;
                     const { memoWidth, backgroundImageBlob, userIconBlob, aiIconBlob, ...settingsconst { memoWidth, backgroundImageBlob, userIconBlob, aiIconBlob, ...settingsToSave } = newSettings;

                     ToSave } = newSettings;

                     const promises = Object.entries(settingsToSave).map(([key, value])const promises = Object.entries(settingsToSave).map(([key, value]) =>
                         dbUtils.saveSetting =>
                         dbUtils.saveSetting(key, value)
                     );

                     const currentSettingsFromDB = await(key, value)
                     );

                     const currentSettingsFromDB = await dbUtils.loadSettings();
                     if dbUtils.loadSettings();
                     if (state.settings.backgroundImageBlob !== currentSettingsFromDB.backgroundImageBlob (state.settings.backgroundImageBlob !== currentSettingsFromDB.backgroundImageBlob) {
                         promises.push(db) {
                         promises.push(dbUtils.saveSetting('backgroundImageBlob', state.settings.backgroundImageBlob));Utils.saveSetting('backgroundImageBlob', state.settings.backgroundImageBlob));
                     }
                     if (state.
                     }
                     if (state.settings.userIconBlob !== currentSettingsFromDB.userIconBlob)settings.userIconBlob !== currentSettingsFromDB.userIconBlob) {
                         promises.push(dbUtils {
                         promises.push(dbUtils.saveSetting('userIconBlob', state.settings.userIconBlob));
                     .saveSetting('userIconBlob', state.settings.userIconBlob));
                     }
                      if (state}
                      if (state.settings.aiIconBlob !== currentSettingsFromDB.aiIconBlob) {
                         promises..settings.aiIconBlob !== currentSettingsFromDB.aiIconBlob) {
                         promises.push(dbUtils.savepush(dbUtils.saveSetting('aiIconBlob', state.settings.aiIconBlob));
                     }

Setting('aiIconBlob', state.settings.aiIconBlob));
                     }

                     await Promise.all(                     await Promise.all(promises);

                     const currentBgBlob = state.settings.backgroundImageBlob;
                     constpromises);

                     const currentBgBlob = state.settings.backgroundImageBlob;
                     const currentUserIconBlob = state.settings currentUserIconBlob = state.settings.userIconBlob;
                     const currentAiIconBlob = state.settings..userIconBlob;
                     const currentAiIconBlob = state.settings.aiIconBlob;

                     stateaiIconBlob;

                     state.settings = { ...state.settings, ...settingsToSave };

                     state.settings = { ...state.settings, ...settingsToSave };

                     state.settings.backgroundImageBlob = current.settings.backgroundImageBlob = currentBgBlob;
                     state.settings.userIconBlob = currentUserIconBlob;BgBlob;
                     state.settings.userIconBlob = currentUserIconBlob;
                     state.settings.aiIconBlob
                     state.settings.aiIconBlob = currentAiIconBlob;

                     uiUtils.applySettingsToUI = currentAiIconBlob;

                     uiUtils.applySettingsToUI();
                     await uiUtils.showCustomAlert();
                     await uiUtils.showCustomAlert("設定を保存しました。");

                     if (newSettings.historySort("設定を保存しました。");

                     if (newSettings.historySortOrder !== oldSortOrder && state.currentScreen ===Order !== oldSortOrder && state.currentScreen === 'history') {
                         uiUtils.renderHistoryList();
                     } 'history') {
                         uiUtils.renderHistoryList();
                     }
                     uiUtils.renderChatMessages
                     uiUtils.renderChatMessages(true);
                 } catch (error) {
                     console.error(true);
                 } catch (error) {
                     console.error("Save settings error:", error);
                     await("Save settings error:", error);
                     await uiUtils.showCustomAlert(`設定の保存中にエラーが発生しました: ${ uiUtils.showCustomAlert(`設定の保存中にエラーが発生しました: ${error}`);
                 }
            },error}`);
                 }
            },
            async updateApp() {
                if (!navigator.serviceWorker || !navigator
            async updateApp() {
                if (!navigator.serviceWorker || !navigator.serviceWorker.controller).serviceWorker.controller) {
                    await uiUtils.showCustomAlert("Service Workerが検出されませんでした。ページ {
                    await uiUtils.showCustomAlert("Service Workerが検出されませんでした。ページをリロードしてから再試行してくださいをリロードしてから再試行してください。");
                    return;
                }
                const confirmed = await ui。");
                    return;
                }
                const confirmed = await uiUtils.showCustomConfirm("アプリのキャッシュをクリアUtils.showCustomConfirm("アプリのキャッシュをクリアして最新版を再取得しますか？ (ページがリロードして最新版を再取得しますか？ (ページがリロードされます)");
                if (confirmed) {
                    navigatorされます)");
                if (confirmed) {
                    navigator.serviceWorker.ready.then(reg => {
.serviceWorker.ready.then(reg => {
                        if (reg.active) {
                            reg.                        if (reg.active) {
                            reg.active.postMessage({ action: 'clearCache' });active.postMessage({ action: 'clearCache' });
                        } else {
                            uiUtils.showCustom
                        } else {
                            uiUtils.showCustomAlert("アクティブなService Workerが見つかりません。手動でAlert("アクティブなService Workerが見つかりません。手動でリロードが必要かもしれません。");
                        }
                    }).リロードが必要かもしれません。");
                        }
                    }).catch(async err => {
                        console.error("Servicecatch(async err => {
                        console.error("Service Worker ready error:", err);
                        await uiUtils.showCustom Worker ready error:", err);
                        await uiUtils.showCustomAlert("Service Workerの準備中にエラーが発生しました。");Alert("Service Workerの準備中にエラーが発生しました。");
                    });
                }
            },
            async
                    });
                }
            },
            async confirmClearAllData() {
                const confirmed = await confirmClearAllData() {
                const confirmed = await uiUtils.showCustomConfirm("本当にすべてのデータ（チャ uiUtils.showCustomConfirm("本当にすべてのデータ（チャット履歴と設定）を削除しますか？この操作は元に戻ット履歴と設定）を削除しますか？この操作は元に戻せません。");
                if (confirmed) {
せません。");
                if (confirmed) {
                    try {
                        uiUtils.revokeExistingObjectUrl                    try {
                        uiUtils.revokeExistingObjectUrl();
                        uiUtils.revokeExistingIconUrls();
();
                        uiUtils.revokeExistingIconUrls();
                        await dbUtils.clearAllData();
                        await                        await dbUtils.clearAllData();
                        await uiUtils.showCustomAlert("すべてのデータが削除されました uiUtils.showCustomAlert("すべてのデータが削除されました。アプリをリセットします。");

                        state.。アプリをリセットします。");

                        state.currentChatId = null;
                        state.currentMessages =currentChatId = null;
                        state.currentMessages = [];
                        state.currentSystemPrompt = '';
 [];
                        state.currentSystemPrompt = '';
                        state.pendingAttachments = [];
                        state.isMemo                        state.pendingAttachments = [];
                        state.isMemoVisible = false;
                        elements.memoArea.Visible = false;
                        elements.memoArea.classList.add('hidden');
                        elements.memoEditor.classList.add('hidden');
                        elements.memoEditor.value = '';
                        state.isClipboardStackVisiblevalue = '';
                        state.isClipboardStackVisible = false;
                        elements.clipboardStackArea.classList. = false;
                        elements.clipboardStackArea.classList.add('hidden');
                        state.clipboardStackContentadd('hidden');
                        state.clipboardStackContent = '';

                        state.settings = {
                            apiKey: = '';

                        state.settings = {
                            apiKey: '', modelName: DEFAULT_MODEL, streamingOutput: true, '', modelName: DEFAULT_MODEL, streamingOutput: true,
                            streamingSpeed: DEFAULT_STREAMING_SPEED
                            streamingSpeed: DEFAULT_STREAMING_SPEED, systemPrompt: '',
                            temperature: null, maxTokens: null,, systemPrompt: '',
                            temperature: null, maxTokens: null, topK: null, topP: null, topK: null, topP: null,
                            presencePenalty: null, frequencyPenalty: null, thinkingBudget: null,
                            presencePenalty: null, frequencyPenalty: null, thinkingBudget: null,
                            dummyUser: '', dummy
                            dummyUser: '', dummyModel: '', concatDummyModel: false,
                            additionalModels: '', pseudoStreaming: false,Model: '', concatDummyModel: false,
                            additionalModels: '', pseudoStreaming: false, enterToSend: true enterToSend: true,
                            autoScrollOnNewMessage: DEFAULT_AUTO_SCROLL_ON_NEW_,
                            autoScrollOnNewMessage: DEFAULT_AUTO_SCROLL_ON_NEW_MESSAGE,
                            historySortMESSAGE,
                            historySortOrder: 'updatedAt',
                            theme: window.matchMedia?.('(prefersOrder: 'updatedAt',
                            theme: window.matchMedia?.('(prefers-color-scheme: light-color-scheme: light)').matches ? 'dark' : 'light',
                            backgroundImageBlob: null, fontFamily)').matches ? 'dark' : 'light',
                            backgroundImageBlob: null, fontFamily: '',
                            messageBodyFontSize:: '',
                            messageBodyFontSize: DEFAULT_MESSAGE_BODY_FONT_SIZE,
                            codeBlockFontSize: DEFAULT_MESSAGE_BODY_FONT_SIZE,
                            codeBlockFontSize: DEFAULT_CODE_BLOCK_FONT_ DEFAULT_CODE_BLOCK_FONT_SIZE,
                            hideSystemPromptInChat: false, enableSwipeNavigation:SIZE,
                            hideSystemPromptInChat: false, enableSwipeNavigation: true,
                            preventZoom: true true,
                            preventZoom: true,
                            showNewChatButton: true,
                            showDeleteSessionButton: false,
                            showNewChatButton: true,
                            showDeleteSessionButton: false, showCopySessionButton: false,, showCopySessionButton: false,
                            showScrollToTopButton: true,
                            showScrollToBottom
                            showScrollToTopButton: true,
                            showScrollToBottomButton: true,
                            showToggleButton: true,
                            showToggleAllContentButton: false,
                            showBulkHistoryActions: true,
AllContentButton: false,
                            showBulkHistoryActions: true,
                            showPasteButtonInFooter: false                            showPasteButtonInFooter: false,
                            showPasteButtonInEdit: false,
                            showMemoButton,
                            showPasteButtonInEdit: false,
                            showMemoButton: false,
                            memoHeight:: false,
                            memoHeight: DEFAULT_MEMO_HEIGHT,
                            showClipboardStackButton: false, DEFAULT_MEMO_HEIGHT,
                            showClipboardStackButton: false,
                            clipboardStackHeight: DEFAULT_
                            clipboardStackHeight: DEFAULT_CLIPBOARD_STACK_HEIGHT,
                            showUserIcon: false,
CLIPBOARD_STACK_HEIGHT,
                            showUserIcon: false,
                            userIconBlob: null,
                            userIconBlob: null,
                            showUserName: false,
                            userName: DEFAULT_USER_NAME,                            showUserName: false,
                            userName: DEFAULT_USER_NAME,
                            showAiIcon: false,
                            showAiIcon: false,
                            aiIconBlob: null,
                            showAiName: false,
                            aiIconBlob: null,
                            showAiName: false,
                            aiName: DEFAULT_AI
                            aiName: DEFAULT_AI_NAME,
                            iconNameFontSize: DEFAULT_ICON_NAME_FONT_NAME,
                            iconNameFontSize: DEFAULT_ICON_NAME_FONT_SIZE,
                            iconNameOffsetY_SIZE,
                            iconNameOffsetY: DEFAULT_ICON_NAME_OFFSET_Y,
                            messageIconSize: DEFAULT_ICON_NAME_OFFSET_Y,
                            messageIconSize: DEFAULT_MESSAGE_ICON_SIZE: DEFAULT_MESSAGE_ICON_SIZE,
                            messageIconOffsetY: DEFAULT_MESSAGE_ICON_OFFSET_Y,
                            messageIconOffsetY: DEFAULT_MESSAGE_ICON_OFFSET_Y,
                            showUserNameBubble: false,
                            showUserNameBubble: false,
                            userNameBubbleUseThemeColor: false,
                            userNameBubbleColor,
                            userNameBubbleUseThemeColor: false,
                            userNameBubbleColor: DEFAULT_USER_NAME_BU: DEFAULT_USER_NAME_BUBBLE_COLOR,
                            userNameBubbleOpacity: DEFAULT_USER_NAMEBBLE_COLOR,
                            userNameBubbleOpacity: DEFAULT_USER_NAME_BUBBLE_OPACITY,_BUBBLE_OPACITY,
                            showAiNameBubble: false,
                            aiNameBubbleUseTheme
                            showAiNameBubble: false,
                            aiNameBubbleUseThemeColor: false,
                            aiNameColor: false,
                            aiNameBubbleColor: DEFAULT_AI_NAME_BUBBLE_COLOR,
BubbleColor: DEFAULT_AI_NAME_BUBBLE_COLOR,
                            aiNameBubbleOpacity: DEFAULT_AI_                            aiNameBubbleOpacity: DEFAULT_AI_NAME_BUBBLE_OPACITY,
                            showCollapseButtonsNAME_BUBBLE_OPACITY,
                            showCollapseButtons: true,
                            persistMessageCollapseState:: true,
                            persistMessageCollapseState: DEFAULT_PERSIST_MESSAGE_COLLAPSE_STATE,
 DEFAULT_PERSIST_MESSAGE_COLLAPSE_STATE,
                            messageBubbleOpacity: DEFAULT_MESSAGE_BU                            messageBubbleOpacity: DEFAULT_MESSAGE_BUBBLE_OPACITY,
                            chatOverlayOpacity: DEFAULT_BBLE_OPACITY,
                            chatOverlayOpacity: DEFAULT_CHAT_OVERLAY_OPACITY,
                            CHAT_OVERLAY_OPACITY,
                            headerFooterOpacity: DEFAULT_HEADER_FOOTER_OPACITY,headerFooterOpacity: DEFAULT_HEADER_FOOTER_OPACITY,
                            messageActionsBackgroundOpacity: DEFAULT_MESSAGE
                            messageActionsBackgroundOpacity: DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY,
                            toggleButtonTopWidth_ACTIONS_BACKGROUND_OPACITY,
                            toggleButtonTopWidth: DEFAULT_TOGGLE_BUTTON_TOP_: DEFAULT_TOGGLE_BUTTON_TOP_WIDTH,
                            toggleButtonTopHeight: DEFAULT_TOGGLE_WIDTH,
                            toggleButtonTopHeight: DEFAULT_TOGGLE_BUTTON_TOP_HEIGHT,
                            toggleButtonBUTTON_TOP_HEIGHT,
                            toggleButtonTopFontSize: DEFAULT_TOGGLE_BUTTON_TOP_FONT_TopFontSize: DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE,
                            toggleButtonTopOpacity: DEFAULTSIZE,
                            toggleButtonTopOpacity: DEFAULT_TOGGLE_BUTTON_TOP_OPACITY,
                            toggle_TOGGLE_BUTTON_TOP_OPACITY,
                            toggleButtonTopTextCollapse: DEFAULT_TOGGLE_ButtonTopTextCollapse: DEFAULT_TOGGLE_BUTTON_TOP_TEXT_COLLAPSE,
                            toggleButtonTopTextBUTTON_TOP_TEXT_COLLAPSE,
                            toggleButtonTopTextExpand: DEFAULT_TOGGLE_BUTTONExpand: DEFAULT_TOGGLE_BUTTON_TOP_TEXT_EXPAND,
                            toggleButtonBottomFontSize: DEFAULT_TOG_TOP_TEXT_EXPAND,
                            toggleButtonBottomFontSize: DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_GLE_BUTTON_BOTTOM_FONT_SIZE,
                            toggleButtonBottomTextCollapse: DEFAULT_TOGGLE_BUTTONSIZE,
                            toggleButtonBottomTextCollapse: DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_COLLAPSE_BOTTOM_TEXT_COLLAPSE,
                            toggleButtonBottomTextExpand: DEFAULT_TOGGLE_BUTTON_,
                            toggleButtonBottomTextExpand: DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_EXPAND,
BOTTOM_TEXT_EXPAND,
                        };
                        state.backgroundImageUrl = null;
                        state.userIconUrl =                        };
                        state.backgroundImageUrl = null;
                        state.userIconUrl = null;
                        state.aiIcon null;
                        state.aiIconUrl = null;
                        state.areAllMessagesHidden = false;
Url = null;
                        state.areAllMessagesHidden = false;
                        state.messageCollapsedStates.clear                        state.messageCollapsedStates.clear();

                        document.documentElement.style.setProperty('--chat-background-image();

                        document.documentElement.style.setProperty('--chat-background-image', 'none');
                        uiUtils', 'none');
                        uiUtils.applySettingsToUI();
                        uiUtils.updateAttachmentBadgeVisibility();.applySettingsToUI();
                        uiUtils.updateAttachmentBadgeVisibility();
                        this.startNewChat();
                        this.startNewChat();
                        uiUtils.showScreen('chat', true);
                    } catch
                        uiUtils.showScreen('chat', true);
                    } catch (error) {
                        console. (error) {
                        console.error("Clear all data error:", error);
                        await uiUtils.showCustomAlert(`error("Clear all data error:", error);
                        await uiUtils.showCustomAlert(`データ削除中にエラーが発生しました: ${データ削除中にエラーが発生しました: ${error}`);
                    }
                }
            },
            async confirmClearAllHistoryerror}`);
                    }
                }
            },
            async confirmClearAllHistory() {
                const confirmed = await() {
                const confirmed = await uiUtils.showCustomConfirm("本当にすべてのチャット履歴を削除しますか uiUtils.showCustomConfirm("本当にすべてのチャット履歴を削除しますか？\nこの操作は元に戻？\nこの操作は元に戻せません。設定は保持されます。");
                if (confirmed) {せません。設定は保持されます。");
                if (confirmed) {
                    try {
                        await db
                    try {
                        await dbUtils.clearAllChatsStore();
                        state.currentChatId = nullUtils.clearAllChatsStore();
                        state.currentChatId = null;
                        state.currentMessages =;
                        state.currentMessages = [];
                        state.pendingAttachments = [];
                        state.isMemoVisible [];
                        state.pendingAttachments = [];
                        state.isMemoVisible = false;
                        elements.memo = false;
                        elements.memoArea.classList.add('hidden');
                        elements.memoEditor.valueArea.classList.add('hidden');
                        elements.memoEditor.value = '';
                        state.isClipboard = '';
                        state.isClipboardStackVisible = false;
                        elements.clipboardStackArea.classList.addStackVisible = false;
                        elements.clipboardStackArea.classList.add('hidden');
                        state.clipboard('hidden');
                        state.clipboardStackContent = '';
                        state.areAllMessagesHidden = false;
StackContent = '';
                        state.areAllMessagesHidden = false;
                        uiUtils.updateToggleAllContentButton                        uiUtils.updateToggleAllContentButton();
                        state.messageCollapsedStates.clear();

                        this.startNewChat();
                        state.messageCollapsedStates.clear();

                        this.startNewChat();
                        await uiUtils();
                        await uiUtils.showCustomAlert("すべてのチャット履歴が削除されました。");

                        if (.showCustomAlert("すべてのチャット履歴が削除されました。");

                        if (state.currentScreen === 'history')state.currentScreen === 'history') {
                            uiUtils.renderHistoryList();
                        }

                    } {
                            uiUtils.renderHistoryList();
                        }

                    } catch (error) {
                        console catch (error) {
                        console.error("Clear all history error:", error);
                        await uiUtils..error("Clear all history error:", error);
                        await uiUtils.showCustomAlert(`チャット履歴のshowCustomAlert(`チャット履歴の削除中にエラーが発生しました: ${error}`);
                    }
                }
削除中にエラーが発生しました: ${error}`);
                    }
                }
            },
            startEditSystemPrompt() {            },
            startEditSystemPrompt() {
                if (state.isSending) return;
                state.isEditingSystemPrompt = true;
                elements.systemPromptEditor.value = state.currentSystemPrompt;
                if (state.isSending) return;
                state.isEditingSystemPrompt = true;
                elements.
                uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
                elementssystemPromptEditor.value = state.currentSystemPrompt;
                uiUtils.adjustTextareaHeight(elements..systemPromptEditor.focus();
            },
            async saveCurrentSystemPrompt() {
                const newPrompt = elementssystemPromptEditor, 200);
                elements.systemPromptEditor.focus();
            },
            .systemPromptEditor.value.trim();
                if (newPrompt !== state.currentSystemPrompt) {
async saveCurrentSystemPrompt() {
                const newPrompt = elements.systemPromptEditor.value.trim();
                if                    state.currentSystemPrompt = newPrompt;
                    try {
                        await dbUtils.saveChat();
 (newPrompt !== state.currentSystemPrompt) {
                    state.currentSystemPrompt = newPrompt;
                                        } catch (error) {
                        console.error("Error saving system prompt:", error);
                        await uitry {
                        await dbUtils.saveChat();
                    } catch (error) {
                        console.errorUtils.showCustomAlert("システムプロンプトの保存に失敗しました。");
                    }
                }
                state.("Error saving system prompt:", error);
                        await uiUtils.showCustomAlert("システムプロンプトの保存に失敗しました。");
                    }
                }
                state.isEditingSystemPrompt = false;
                elements.systemisEditingSystemPrompt = false;
                elements.systemPromptDetails.removeAttribute('open');
            },
            cancelEditSystemPrompt() {
                state.isEditingSystemPrompt = false;
                elements.systemPromptEditorPromptDetails.removeAttribute('open');
            },
            cancelEditSystemPrompt() {
                state.isEditing.value = state.currentSystemPrompt;
                elements.systemPromptDetails.removeAttribute('open');
                uiSystemPrompt = false;
                elements.systemPromptEditor.value = state.currentSystemPrompt;
                elementsUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
            },
            async.systemPromptDetails.removeAttribute('open');
                uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
            },
            async startEditMessage(index, messageElement) {
                  startEditMessage(index, messageElement) {
                 if (state.isSending) {
                     await uiUtils.if (state.isSending) {
                     await uiUtils.showCustomAlert("送信中は編集できません。");
showCustomAlert("送信中は編集できません。");
                     return;
                 }
                 if (state.editingMessageIndex !==                     return;
                 }
                 if (state.editingMessageIndex !== null && state.editingMessageIndex !== null && state.editingMessageIndex !== index) {
                     await uiUtils.showCustomAlert("他のメッセージを編 index) {
                     await uiUtils.showCustomAlert("他のメッセージを編集中です。");
                     return;集中です。");
                     return;
                 }
                 if (state.isEditingSystemPrompt) {

                 }
                 if (state.isEditingSystemPrompt) {
                     await uiUtils.showCustomAlert                     await uiUtils.showCustomAlert("システムプロンプト編集中です。");
                     return;
                 ("システムプロンプト編集中です。");
                     return;
                 }
                 if (state.editingMessageIndex ===}
                 if (state.editingMessageIndex === index) {
                     messageElement.querySelector('.edit-textarea index) {
                     messageElement.querySelector('.edit-textarea')?.focus();
                     return;
                 }

')?.focus();
                     return;
                 }

                 const message = state.currentMessages[index];
                 if (!                 const message = state.currentMessages[index];
                 if (!message) return;

                 const rawContentmessage) return;

                 const rawContent = message.content;
                 state.editingMessageIndex = index;

                 const = message.content;
                 state.editingMessageIndex = index;

                 const contentDiv = messageElement.querySelector('. contentDiv = messageElement.querySelector('.message-content');
                 const editArea = messageElement.querySelector('.message-editmessage-content');
                 const editArea = messageElement.querySelector('.message-edit-area');
                 const-area');
                 const cascadeControls = messageElement.querySelector('.message-cascade-controls');

                 editArea.innerHTML cascadeControls = messageElement.querySelector('.message-cascade-controls');

                 editArea.innerHTML = '';

                 let horizontalPadding = '';

                 let horizontalPadding = 0;
                 try {
                     const computedStyle = window.get = 0;
                 try {
                     const computedStyle = window.getComputedStyle(messageElement);
ComputedStyle(messageElement);
                     const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;                     const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
                     const paddingRight = parseFloat
                     const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
                     horizontalPadding = padding(computedStyle.paddingRight) || 0;
                     horizontalPadding = paddingLeft + paddingRight;
                 Left + paddingRight;
                 } catch (e) {
                 }
                 messageElement.style.width = `} catch (e) {
                 }
                 messageElement.style.width = `calc(var(--message-max-calc(var(--message-max-width) + ${horizontalPadding}px + 17px)`;


                 width) + ${horizontalPadding}px + 17px)`;


                 const textarea = document.createElement('textareaconst textarea = document.createElement('textarea');
                 textarea.value = rawContent;
                 textarea.classList.');
                 textarea.value = rawContent;
                 textarea.classList.add('edit-textarea');
                 add('edit-textarea');
                 textarea.rows = 3;
                 textarea.oninput = () => uiUtils.textarea.rows = 3;
                 textarea.oninput = () => uiUtils.adjustTextareaHeight(textarea, adjustTextareaHeight(textarea, 400);

                 const actionsDiv = document.createElement('div');
                 actions400);

                 const actionsDiv = document.createElement('div');
                 actionsDiv.classList.add('message-Div.classList.add('message-edit-actions');

                 if (state.settings.showPasteButtonInedit-actions');

                 if (state.settings.showPasteButtonInEdit) {
                    const pasteButtonEdit) {
                    const pasteButton = document.createElement('button');
                    pasteButton.textContent = '貼 = document.createElement('button');
                    pasteButton.textContent = '貼';
                    pasteButton.title =';
                    pasteButton.title = 'テキストエリアに貼り付け';
                    pasteButton.style.backgroundColor = 'var(-- 'テキストエリアに貼り付け';
                    pasteButton.style.backgroundColor = 'var(--bg-button-paste)';bg-button-paste)';
                    pasteButton.style.marginRight = 'auto';
                    pasteButton.onclick =
                    pasteButton.style.marginRight = 'auto';
                    pasteButton.onclick = async () => {
                        const async () => {
                        const originalText = pasteButton.textContent;
                        const originalTitle = pasteButton.title;
 originalText = pasteButton.textContent;
                        const originalTitle = pasteButton.title;
                        try {
                        try {
                            if (!navigator.clipboard || !navigator.clipboard.readText) {
                                pasteButton.textContent =                            if (!navigator.clipboard || !navigator.clipboard.readText) {
                                pasteButton.textContent = "!";
                                "!";
                                pasteButton.title = "クリップボードAPI非対応";
                                pasteButton.disabled = true;
 pasteButton.title = "クリップボードAPI非対応";
                                pasteButton.disabled = true;
                                setTimeout(()                                setTimeout(() => {
                                    pasteButton.textContent = originalText;
                                    pasteButton.title = => {
                                    pasteButton.textContent = originalText;
                                    pasteButton.title = originalTitle; originalTitle;
                                    pasteButton.disabled = false;
                                }, 2000);
                                return;
                                    pasteButton.disabled = false;
                                }, 2000);
                                return;
                            }

                            }
                            const textToPaste = await navigator.clipboard.readText();
                            if (textTo                            const textToPaste = await navigator.clipboard.readText();
                            if (textToPaste) {
Paste) {
                                const currentText = textarea.value;
                                const selectionStart = textarea.selectionStart;                                const currentText = textarea.value;
                                const selectionStart = textarea.selectionStart;
                                const selectionEnd = textarea.selectionEnd;
                                textarea.value = currentText.substring(0, selectionStart) +
                                const selectionEnd = textarea.selectionEnd;
                                textarea.value = currentText.substring(0, selectionStart) + textToPaste + currentText.substring(selectionEnd);
                                textarea.selectionStart = textarea.selectionEnd textToPaste + currentText.substring(selectionEnd);
                                textarea.selectionStart = textarea.selectionEnd = = selectionStart + textToPaste.length;
                                textarea.focus();
                                uiUtils.adjustTextarea selectionStart + textToPaste.length;
                                textarea.focus();
                                uiUtils.adjustTextareaHeightHeight(textarea, 400);
                                pasteButton.textContent = "✓";
                                pasteButton.(textarea, 400);
                                pasteButton.textContent = "✓";
                                pasteButton.titletitle = "貼り付け完了";
                                setTimeout(() => {
                                    pasteButton.textContent = originalText; = "貼り付け完了";
                                setTimeout(() => {
                                    pasteButton.textContent = originalText;

                                    pasteButton.title = originalTitle;
                                }, 1500);
                            } else                                    pasteButton.title = originalTitle;
                                }, 1500);
                            } else { {
                                pasteButton.textContent = "空";
                                pasteButton.title = "クリップボードは空
                                pasteButton.textContent = "空";
                                pasteButton.title = "クリップボードは空です";
                                setTimeout(() => {
                                    pasteButton.textContent = originalText;
                                    pasteButton.title = originalです";
                                setTimeout(() => {
                                    pasteButton.textContent = originalText;
                                    pasteButton.title = originalTitle;
                                }, 1500);
                            }
                        } catch (errTitle;
                                }, 1500);
                            }
                        } catch (err) {
                             ) {
                             console.error("Paste to edit textarea error:", err);
                             if (err.name ===console.error("Paste to edit textarea error:", err);
                             if (err.name === 'NotAllowedError 'NotAllowedError' || err.message.includes('Read permission denied')) {
                                pasteButton.textContent =' || err.message.includes('Read permission denied')) {
                                pasteButton.textContent = "!";
                                "!";
                                pasteButton.title = "クリップボードの許可なし";
                             } else {
                                pasteButton. pasteButton.title = "クリップボードの許可なし";
                             } else {
                                pasteButton.textContent = "XtextContent = "X";
                                pasteButton.title = "貼り付け失敗";
                             }
                             pasteButton.disabled =";
                                pasteButton.title = "貼り付け失敗";
                             }
                             pasteButton.disabled = true;
                              true;
                             setTimeout(() => {
                                pasteButton.textContent = originalText;
                                pasteButton.titlesetTimeout(() => {
                                pasteButton.textContent = originalText;
                                pasteButton.title = originalTitle; = originalTitle;
                                pasteButton.disabled = false;
                             }, 2000);
                        
                                pasteButton.disabled = false;
                             }, 2000);
                        }
                    };}
                    };
                    actionsDiv.appendChild(pasteButton);
                 }

                 const saveButton = document.
                    actionsDiv.appendChild(pasteButton);
                 }

                 const saveButton = document.createElement('button');createElement('button');
                 saveButton.textContent = '保存';
                 saveButton.classList.add('save
                 saveButton.textContent = '保存';
                 saveButton.classList.add('save-edit-btn-edit-btn');
                 saveButton.onclick = () => this.saveEditMessage(index, messageElement');
                 saveButton.onclick = () => this.saveEditMessage(index, messageElement);
                 const);
                 const cancelButton = document.createElement('button');
                 cancelButton.textContent = 'キャンセル';
                 cancel cancelButton = document.createElement('button');
                 cancelButton.textContent = 'キャンセル';
                 cancelButton.classList.Button.classList.add('cancel-edit-btn');
                 cancelButton.onclick = () => this.canceladd('cancel-edit-btn');
                 cancelButton.onclick = () => this.cancelEditMessage(indexEditMessage(index, messageElement);
                 actionsDiv.appendChild(saveButton);
                 actionsDiv.appendChild, messageElement);
                 actionsDiv.appendChild(saveButton);
                 actionsDiv.appendChild(cancelButton);(cancelButton);

                 editArea.appendChild(textarea);
                 editArea.appendChild(actionsDiv);

                 message

                 editArea.appendChild(textarea);
                 editArea.appendChild(actionsDiv);

                 messageElement.classList.Element.classList.add('editing');
                 if(contentDiv) contentDiv.classList.add('hidden');add('editing');
                 if(contentDiv) contentDiv.classList.add('hidden');
                 if(
                 if(cascadeControls) cascadeControls.classList.add('hidden');
                 editArea.classList.remove('hidden');cascadeControls) cascadeControls.classList.add('hidden');
                 editArea.classList.remove('hidden');

                 uiUtils.adjustTextareaHeight(textarea, 400);
                 textarea.focus();
                 textarea.select

                 uiUtils.adjustTextareaHeight(textarea, 400);
                 textarea.focus();
                 textarea.select();

                 this.uncollapseMessage(index, messageElement);
            },
            async saveEdit();

                 this.uncollapseMessage(index, messageElement);
            },
            async saveEditMessage(Message(index, messageElement) {
                const textarea = messageElement.querySelector('.edit-textarea');
                index, messageElement) {
                const textarea = messageElement.querySelector('.edit-textarea');
                if (!textarea)if (!textarea) {
                    this.cancelEditMessage(index, messageElement);
                    return;
                 {
                    this.cancelEditMessage(index, messageElement);
                    return;
                }
                const}
                const newRawContent = textarea.value.trim();
                const originalMessage = state.currentMessages[ newRawContent = textarea.value.trim();
                const originalMessage = state.currentMessages[index];

                if (newRawContent === originalMessage.content) {
                    this.cancelEditMessage(index, messageindex];

                if (newRawContent === originalMessage.content) {
                    this.cancelEditMessage(index, messageElement);
                    return;
                }

                originalMessage.content = newRawContent;
                originalMessage.timestamp =Element);
                    return;
                }

                originalMessage.content = newRawContent;
                originalMessage Date.now();
                delete originalMessage.error;

                const contentDiv = messageElement.querySelector('.message-content');.timestamp = Date.now();
                delete originalMessage.error;

                const contentDiv = messageElement.querySelector('.
                if (contentDiv && typeof marked !== 'undefined' && originalMessage.role === 'model') {
                    try {message-content');
                if (contentDiv && typeof marked !== 'undefined' && originalMessage.role === 'model') {
                        contentDiv.innerHTML = marked.parse(newRawContent || '');
                        uiUtils.processInteractiveTitles
                    try {
                        contentDiv.innerHTML = marked.parse(newRawContent || '');
                        uiUtils(contentDiv);
                        uiUtils.addCopyButtonsToCodeBlocks(contentDiv);
                    } catch (.processInteractiveTitles(contentDiv);
                        uiUtils.addCopyButtonsToCodeBlocks(contentDiv);
e) {
                        console.error("Markdown parse error on save edit:", e);
                        contentDiv.textContent =                    } catch (e) {
                        console.error("Markdown parse error on save edit:", e);
                        content newRawContent;
                    }
                } else if (contentDiv) {
                    const pre = contentDivDiv.textContent = newRawContent;
                    }
                } else if (contentDiv) {
                    const pre = contentDiv.querySelector('pre') || document.createElement('pre');
                    pre.textContent = newRaw.querySelector('pre') || document.createElement('pre');
                    pre.textContent = newRawContent;
                    if (!Content;
                    if (!contentDiv.querySelector('pre')) {
                        contentDiv.innerHTML = '';
                        contentDivcontentDiv.querySelector('pre')) {
                        contentDiv.innerHTML = '';
                        contentDiv.appendChild(pre);
                    }
                }

                this.finishEditing(messageElement);
                this.uncollapseMessage(index,.appendChild(pre);
                    }
                }

                this.finishEditing(messageElement);
                this.uncollapseMessage(index, messageElement);

                const isFirstUserMessage = (index === state.currentMessages.findIndex(m => messageElement);

                const isFirstUserMessage = (index === state.currentMessages.findIndex(m => m.role === 'user'));
                let titleForSave = null;
                if (isFirstUserMessage) {
                    titleForSave m.role === 'user'));
                let titleForSave = null;
                if (isFirstUserMessage) {
                    titleForSave = newRawContent.substring(0, 50) || "無題のチャット";
 = newRawContent.substring(0, 50) || "無題のチャット";
                }

                                }

                try {
                    await dbUtils.saveChat(titleForSave);
                    if (istry {
                    await dbUtils.saveChat(titleForSave);
                    if (isFirstUserMessage)FirstUserMessage) {
                        uiUtils.updateChatTitle(titleForSave);
                    }
                    if {
                        uiUtils.updateChatTitle(titleForSave);
                    }
                    if (state.currentMessages.length === 0 && !state.currentSystemPrompt && state.currentChatId) {
                        this (state.currentMessages.length === 0 && !state.currentSystemPrompt && state.currentChatId) {
.startNewChat();
                    }
                } catch (error) {
                    console.error("Error saving chat after message edit:", error);
                    await uiUtils.showCustomAlert("メッセージ編集後のチャット保存に失敗しました。");
                }
            },
            cancelEditMessage(index, messageElement = null) {
                  if (!messageElement) {
                      messageElement = elements.messageContainer.querySelector(`.message[data-index="${index}"]`);
                  }
                  if (messageElement) {
                      this.finishEditing(messageElement);
                  } else if (state.editingMessageIndex === index) {
                      state.editingMessageIndex = null;
                  }
            },
            finishEditing(messageElement) {
                if (!messageElement) return;
                const editArea = messageElement.querySelector('.message-edit-area');
                const contentDiv = messageElement.querySelector('.message-content');
                const cascadeControls = messageElement.querySelector('.message-cascade-controls');
                const textarea = messageElement.querySelector('.edit-textarea');

                messageElement.style.removeProperty('width');
                messageElement.classList.remove('editing');
                if(contentDiv) contentDiv.classList.remove('hidden');
                if(cascadeControls) cascadeControls.classList.remove('hidden');
                if(editArea) {                        this.startNewChat();
                    }
                } catch (error) {
                    console.error("
                    editArea.classList.add('hidden');
                    editArea.innerHTML = '';
                }

                const index =Error saving chat after message edit:", error);
                    await uiUtils.showCustomAlert("メッセージ編集後のチャット parseInt(messageElement.dataset.index, 10);
                if (state.editingMessageIndex === index保存に失敗しました。");
                }
            },
            cancelEditMessage(index, messageElement = null) {
                    state.editingMessageIndex = null;
                }
            },
            async copyMessageText) {
                  if (!messageElement) {
                      messageElement = elements.messageContainer.querySelector(`.message[data-index="${index}"]`);
                  }
                  if (messageElement) {
                      this.finishEditing(index, buttonElement) {
                const message = state.currentMessages[index];
                if (!message(messageElement);
                  } else if (state.editingMessageIndex === index) {
                      state.editing) return;

                let textToCopy = message.content;
                if (!textToCopy && message.role === 'MessageIndex = null;
                  }
            },
            finishEditing(messageElement) {
                if (!messageElement) return;
                const editArea = messageElement.querySelector('.message-edit-area');
                user' && message.attachments && message.attachments.length > 0) {
                    textToCopy = `const contentDiv = messageElement.querySelector('.message-content');
                const cascadeControls = messageElement.querySelector('.[添付ファイル: ${message.attachments.map(a => a.name).join(', ')}]`;
                }message-cascade-controls');
                const textarea = messageElement.querySelector('.edit-textarea');

                messageElement.style.removeProperty('width');
                messageElement.classList.remove('editing');
                if(contentDiv) content else if (!textToCopy) {
                    textToCopy = "";
                }

                try {
                    Div.classList.remove('hidden');
                if(cascadeControls) cascadeControls.classList.remove('hidden');
                if(editArea) {
                    editArea.classList.add('hidden');
                    editArea.await navigator.clipboard.writeText(textToCopy);
                    const originalText = buttonElement.textContent;
innerHTML = '';
                }

                const index = parseInt(messageElement.dataset.index, 10);
                if                    buttonElement.textContent = '完了！';
                    buttonElement.disabled = true;
                    setTimeout(() => (state.editingMessageIndex === index) {
                    state.editingMessageIndex = null;
                }
 {
                        buttonElement.textContent = originalText;
                        buttonElement.disabled = false;
                    },             },
            async copyMessageText(index, buttonElement) {
                const message = state.currentMessages1500);
                } catch (err) {
                    console.error("Copy message text to OS clipboard error:",[index];
                if (!message) return;

                let textToCopy = message.content;
                if (!textToCopy && message.role === 'user' && message.attachments && message.attachments.length > 0) err);
                    await uiUtils.showCustomAlert("OSクリップボードへのコピーに失敗しました。");
 {
                    textToCopy = `[添付ファイル: ${message.attachments.map(a => a.name                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = 'コピー失敗';
                    button).join(', ')}]`;
                } else if (!textToCopy) {
                    textToCopy = "";
Element.disabled = true;
                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                                        }

                try {
                    await navigator.clipboard.writeText(textToCopy);
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = '完了！';
                    buttonElement.disabled = true;
                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                        buttonElement.buttonElement.disabled = false;
                    }, 2000);
                }

                const currentStackdisabled = false;
                    }, 1500);
                } catch (err) {
                    console.error("Content = elements.clipboardStackEditor.value;
                const separator = currentStackContent.length > 0 &&Copy message text to OS clipboard error:", err);
                    await uiUtils.showCustomAlert("OSクリップボード !currentStackContent.endsWith('\n\n') ? "\n\n" : "";
                elements.clipboardへのコピーに失敗しました。");
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = 'コピー失敗';
                    buttonElement.disabled = true;
                    setTimeout(() => {
                        buttonElementStackEditor.value += separator + textToCopy;
                state.clipboardStackContent = elements.clipboardStackEditor.value.textContent = originalText;
                        buttonElement.disabled = false;
                    }, 2000);;
                elements.clipboardStackEditor.scrollTop = elements.clipboardStackEditor.scrollHeight;
            },
            
                }

                const currentStackContent = elements.clipboardStackEditor.value;
                const separator = currentasync deleteMessage(index) {
                if (state.editingMessageIndex === index) {
                    this.StackContent.length > 0 && !currentStackContent.endsWith('\n\n') ? "\n\n" : "";
                elements.clipboardStackEditor.value += separator + textToCopy;
                state.clipboardStackContent = elements.clipboardStackEditor.value;
                elements.clipboardStackEditor.scrollTop = elements.clipboardStackEditorcancelEditMessage(index);
                }
                if (state.isSending) {
                    await uiUtils.scrollHeight;
            },
            async deleteMessage(index) {
                if (state.editingMessageIndex.showCustomAlert("送信中は削除できません。");
                    return;
                }
                if (state.isEditingSystem === index) {
                    this.cancelEditMessage(index);
                }
                if (state.isPrompt) {
                    await uiUtils.showCustomAlert("システムプロンプト編集中は削除できません。");Sending) {
                    await uiUtils.showCustomAlert("送信中は削除できません。");
                    return;
                }
                if (state.isEditingSystemPrompt) {
                    await uiUtils.showCustomAlert("
                    return;
                }
                if (index < 0 || index >= state.currentMessages.lengthシステムプロンプト編集中は削除できません。");
                    return;
                }
                if (index < 0 || index >= state.currentMessages.length) {
                     return;
                }

                const messageToDelete = state) {
                     return;
                }

                const messageToDelete = state.currentMessages[index];
                const messageContentPreview = messageToDelete.content.substring(0, 30) + "...";
                let.currentMessages[index];
                const messageContentPreview = messageToDelete.content.substring(0, 30) confirmMessage = "";
                let indicesToDelete = [];

                if (messageToDelete.role === 'model' && messageToDelete. + "...";
                let confirmMessage = "";
                let indicesToDelete = [];

                if (messageToDelete.role === 'model' && messageToDelete.isCascaded && messageToDelete.siblingGroupId) {
                    const groupIdisCascaded && messageToDelete.siblingGroupId) {
                    const groupId = messageToDelete.siblingGroupId;
                    const siblings = = messageToDelete.siblingGroupId;
                    const siblings = state.currentMessages.filter(msg => msg.role state.currentMessages.filter(msg => msg.role === 'model' && msg.isCascaded && msg === 'model' && msg.isCascaded && msg.siblingGroupId === groupId);
                    indicesToDelete = state.siblingGroupId === groupId);
                    indicesToDelete = state.currentMessages
                        .map((msg, i).currentMessages
                        .map((msg, i) => (msg.role === 'model' && msg. => (msg.role === 'model' && msg.isCascaded && msg.siblingGroupId === groupId) ?isCascaded && msg.siblingGroupId === groupId) ? i : -1)
                        .filter(i => i !== i : -1)
                        .filter(i => i !== -1);
                    confirmMessage = `「${messageContentPreview}」を含む応答グループ全体 (${siblings.length}件) を削除しますか？`;
                } else { -1);
                    confirmMessage = `「${messageContentPreview}」を含む応答グループ全体 (${siblings.length}件
                    indicesToDelete.push(index);
                    confirmMessage = `メッセージ「${messageContentPreview}」(${messageToDelete.) を削除しますか？`;
                } else {
                    indicesToDelete.push(index);
                    confirmMessage = `role}) を削除しますか？`;
                }

                const confirmed = await uiUtils.showCustomConfirm(メッセージ「${messageContentPreview}」(${messageToDelete.role}) を削除しますか？`;
                }

                constconfirmMessage);
                if (confirmed) {
                    const originalFirstUserMsgIndex = state.currentMessages. confirmed = await uiUtils.showCustomConfirm(confirmMessage);
                if (confirmed) {
                    const originalfindIndex(m => m.role === 'user');

                    indicesToDelete.sort((a, b) => b - aFirstUserMsgIndex = state.currentMessages.findIndex(m => m.role === 'user');

                    indicesToDelete.).forEach(idx => {
                        state.currentMessages.splice(idx, 1);
                        state.sort((a, b) => b - a).forEach(idx => {
                        state.currentMessages.splice(idx,messageCollapsedStates.delete(idx);
                    });

                    const oldCollapsedStates = new Map(state.message 1);
                        state.messageCollapsedStates.delete(idx);
                    });

                    const oldCollapsedStatesCollapsedStates);
                    state.messageCollapsedStates.clear();
                     state.currentMessages.forEach((msg, newIdx = new Map(state.messageCollapsedStates);
                    state.messageCollapsedStates.clear();
                     state.) => {
                        const oldIdxEquivalent = newIdx >= Math.min(...indicesToDelete) ? newIdx + indicescurrentMessages.forEach((msg, newIdx) => {
                        const oldIdxEquivalent = newIdx >= Math.min(...indicesToDelete.filter(i => i <= newIdx).length : newIdx;
                        if (oldCollapsedStates.has(ToDelete) ? newIdx + indicesToDelete.filter(i => i <= newIdx).length : newIdx;
                        if (oldIdxEquivalent)) {
                            state.messageCollapsedStates.set(newIdx, oldCollapsedStates.get(oldCollapsedStates.has(oldIdxEquivalent)) {
                            state.messageCollapsedStates.set(newIdx,oldIdxEquivalent));
                        } else {
                            state.messageCollapsedStates.set(newIdx, false); oldCollapsedStates.get(oldIdxEquivalent));
                        } else {
                            state.messageCollapsedStates.set
                        }
                    });


                    uiUtils.renderChatMessages();

                    const newFirstUserMsgIndex =(newIdx, false);
                        }
                    });


                    uiUtils.renderChatMessages();

                    const newFirstUser state.currentMessages.findIndex(m => m.role === 'user');
                    let requiresTitleUpdate = indicesToDelete.includesMsgIndex = state.currentMessages.findIndex(m => m.role === 'user');
                    let requiresTitle(originalFirstUserMsgIndex);

                    try {
                        let newTitleForSave = null;
                        constUpdate = indicesToDelete.includes(originalFirstUserMsgIndex);

                    try {
                        let newTitleForSave = null currentChatData = state.currentChatId ? await dbUtils.getChat(state.currentChatId) :;
                        const currentChatData = state.currentChatId ? await dbUtils.getChat(state.current null;

                        if (requiresTitleUpdate) {
                            const newFirstUserMessage = newFirstUserMsgIndex !== -1ChatId) : null;

                        if (requiresTitleUpdate) {
                            const newFirstUserMessage = new ? state.currentMessages[newFirstUserMsgIndex] : null;
                            newTitleForSave = newFirstUserMessageFirstUserMsgIndex !== -1 ? state.currentMessages[newFirstUserMsgIndex] : null;
                             ? newFirstUserMessage.content.substring(0, 50) : "無題のチャット";newTitleForSave = newFirstUserMessage ? newFirstUserMessage.content.substring(0, 50
                        } else if (currentChatData) {
                            newTitleForSave = currentChatData.title;) : "無題のチャット";
                        } else if (currentChatData) {
                            newTitle
                        }

                        await dbUtils.saveChat(newTitleForSave);
                        if (requiresTitleUpdateForSave = currentChatData.title;
                        }

                        await dbUtils.saveChat(newTitleFor) {
                            uiUtils.updateChatTitle(newTitleForSave);
                        }
                        if (stateSave);
                        if (requiresTitleUpdate) {
                            uiUtils.updateChatTitle(newTitleForSave.currentMessages.length === 0 && !state.currentSystemPrompt && state.currentChatId) {
);
                        }
                        if (state.currentMessages.length === 0 && !state.currentSystemPrompt                            this.startNewChat();
                        }
                    } catch (error) {
                        console.error(" && state.currentChatId) {
                            this.startNewChat();
                        }
                    } catch (errorError saving chat after message delete:", error);
                        await uiUtils.showCustomAlert("メッセージ削除後のチャット) {
                        console.error("Error saving chat after message delete:", error);
                        await uiUtils.show保存に失敗しました。");
                    }
                }
            },
            findPreviousUserIndex(modelMessageIndex) {CustomAlert("メッセージ削除後のチャット保存に失敗しました。");
                    }
                }
            },
            findPrevious
                for (let i = modelMessageIndex - 1; i >= 0; i--) {
                    UserIndex(modelMessageIndex) {
                for (let i = modelMessageIndex - 1; i >=if (state.currentMessages[i].role === 'user') {
                        return i;
                    }
 0; i--) {
                    if (state.currentMessages[i].role === 'user') {
                }
                return -1;
            },
            async retryFromMessage(index) {
                if                        return i;
                    }
                }
                return -1;
            },
            async retryFrom (state.editingMessageIndex !== null) {
                    await uiUtils.showCustomAlert("編集中はリMessage(index) {
                if (state.editingMessageIndex !== null) {
                    await uiUtils.トライできません。");
                    return;
                }
                if (state.isSending) {
                    await uishowCustomAlert("編集中はリトライできません。");
                    return;
                }
                if (state.Utils.showCustomAlert("送信中です。");
                    return;
                }
                if (state.isisSending) {
                    await uiUtils.showCustomAlert("送信中です。");
                    return;
                EditingSystemPrompt) {
                    await uiUtils.showCustomAlert("システムプロンプト編集中はリトライ}
                if (state.isEditingSystemPrompt) {
                    await uiUtils.showCustomAlert("システムできません。");
                    return;
                }

                const userMessage = state.currentMessages[index];
                ifプロンプト編集中はリトライできません。");
                    return;
                }

                const userMessage = state.currentMessages[index];
                if (!userMessage || userMessage.role !== 'user') return;

                 (!userMessage || userMessage.role !== 'user') return;

                const messageContentPreview = userMessage.content.const messageContentPreview = userMessage.content.substring(0, 30) + "...";
                const confirmed =substring(0, 30) + "...";
                const confirmed = await uiUtils.showCustomConfirm(` await uiUtils.showCustomConfirm(`「${messageContentPreview}」から再生成しますか？\n(「${messageContentPreview}」から再生成しますか？\n(この入力に対する既存の応答は保持この入力に対する既存の応答は保持されますが、**これより未来の会話履歴は削除されます**)`);
                ifされますが、**これより未来の会話履歴は削除されます**)`);
                if (confirmed) {
                    let deleteStartIndex = -1;
                    let scanIndex = index + 1;
                    let targetSiblingGroupId (confirmed) {
                    let deleteStartIndex = -1;
                    let scanIndex = index + 1; = null;

                    if (scanIndex < state.currentMessages.length && state.currentMessages[scanIndex].role
                    let targetSiblingGroupId = null;

                    if (scanIndex < state.currentMessages.length && state === 'model') {
                        targetSiblingGroupId = state.currentMessages[scanIndex].siblingGroupId || null;
                    }

                    if (targetSiblingGroupId !== null) {
                        while (
                            scanIndex < state.currentMessages[scanIndex].role === 'model') {
                        targetSiblingGroupId = state.currentMessages[scanIndex].siblingGroupId || null;
                    }

                    if (targetSiblingGroupId !== null) {
                        .currentMessages.length &&
                            state.currentMessages[scanIndex].role === 'model' &&
                            while (
                            scanIndex < state.currentMessages.length &&
                            state.currentMessages[scanIndex].state.currentMessages[scanIndex].siblingGroupId === targetSiblingGroupId
                        ) {
                            scanIndex++;
role === 'model' &&
                            state.currentMessages[scanIndex].siblingGroupId === targetSiblingGroupId
                                                }
                    } else {
                         if (scanIndex < state.currentMessages.length && state.currentMessages[) {
                            scanIndex++;
                        }
                    } else {
                         if (scanIndex < state.scanIndex].role === 'model') {
                            scanIndex++;
                        }
                    }

                    if (currentMessages.length && state.currentMessages[scanIndex].role === 'model') {
                            scanIndex++;
                        }
                    }

                    if (scanIndex < state.currentMessages.length) {
                        deleteStartIndex =scanIndex < state.currentMessages.length) {
                        deleteStartIndex = scanIndex;
                    }

                     scanIndex;
                    }

                    if (deleteStartIndex !== -1) {
                        for(let i =if (deleteStartIndex !== -1) {
                        for(let i = deleteStartIndex; i < state.current deleteStartIndex; i < state.currentMessages.length; i++) {
                            state.messageCollapsedStates.deleteMessages.length; i++) {
                            state.messageCollapsedStates.delete(i);
                        }
                        state.currentMessages.splice(deleteStartIndex);
                    }

                    uiUtils.renderChatMessages();
                    if (state(i);
                        }
                        state.currentMessages.splice(deleteStartIndex);
                    }

                    ui.settings.autoScrollOnNewMessage) uiUtils.scrollToBottom();

                    const elementsToHide = [];
Utils.renderChatMessages();
                    if (state.settings.autoScrollOnNewMessage) uiUtils.scrollToBottom();

                    const messageContainer = elements.messageContainer;
                    if (targetSiblingGroupId) {
                        messageContainer.querySelectorAll(`.message                    const elementsToHide = [];
                    const messageContainer = elements.messageContainer;
                    if (targetSiblingGroupId) {.model[data-index]`).forEach(el => {
                            const msgIndex = parseInt(el.dataset.index
                        messageContainer.querySelectorAll(`.message.model[data-index]`).forEach(el => {
                            const msgIndex, 10);
                            const potentialMsg = state.currentMessages[msgIndex];
                            if (potential = parseInt(el.dataset.index, 10);
                            const potentialMsg = state.currentMessages[Msg && potentialMsg.role === 'model' && potentialMsg.siblingGroupId === targetSiblingGroupId) {
                                 el.msgIndex];
                            if (potentialMsg && potentialMsg.role === 'model' && potentialMsg.siblingGroupId === targetSiblingGroupId) {
                                 el.classList.add('retrying-hidden');
                                 elementsToHideclassList.add('retrying-hidden');
                                 elementsToHide.push(el);
                            }
.push(el);
                            }
                        });
                    } else if (index + 1 < state.                        });
                    } else if (index + 1 < state.currentMessages.length && state.currentMessagescurrentMessages.length && state.currentMessages[index + 1]?.role === 'model') {
                        const[index + 1]?.role === 'model') {
                        const element = messageContainer.querySelector(`.message.model[data-index="${index + 1}"]`);
                        if (element) {
                            element.classList element = messageContainer.querySelector(`.message.model[data-index="${index + 1}"]`);
                        if (.add('retrying-hidden');
                            elementsToHide.push(element);
                        }
                    }element) {
                            element.classList.add('retrying-hidden');
                            elementsToHide.push(

                    await this.handleSend(true, index);
                }
            },
            getCascadedSibelement);
                        }
                    }

                    await this.handleSend(true, index);
                }
lings(index, includeSelf = false) {
                const targetMsg = state.currentMessages[index];
                if            },
            getCascadedSiblings(index, includeSelf = false) {
                const targetMsg = state. (!targetMsg || !targetMsg.isCascaded || !targetMsg.siblingGroupId) {
                    return [];currentMessages[index];
                if (!targetMsg || !targetMsg.isCascaded || !targetMsg.
                }
                const groupId = targetMsg.siblingGroupId;
                const siblings = state.currentMessages.filtersiblingGroupId) {
                    return [];
                }
                const groupId = targetMsg.siblingGroupId;
                ((msg, i) =>
                    msg.role === 'model' &&
                    msg.isCascaded &&const siblings = state.currentMessages.filter((msg, i) =>
                    msg.role === 'model' &&

                    msg.siblingGroupId === groupId &&
                    (includeSelf || i !== index)
                );
                                    msg.isCascaded &&
                    msg.siblingGroupId === groupId &&
                    (includeSelf || i !== index)
return siblings;
            },
            async navigateCascade(currentIndex, direction) {
                const currentMsg = state.                );
                return siblings;
            },
            async navigateCascade(currentIndex, direction) {
                const currentcurrentMessages[currentIndex];
                if (!currentMsg || !currentMsg.isCascaded || !currentMsg.Msg = state.currentMessages[currentIndex];
                if (!currentMsg || !currentMsg.isCascaded ||siblingGroupId) return;

                const groupId = currentMsg.siblingGroupId;
                const siblingsWithIndices = state.currentMessages !currentMsg.siblingGroupId) return;

                const groupId = currentMsg.siblingGroupId;
                const siblingsWithIndices
                    .map((msg, i) => ({ msg, originalIndex: i }))
                    .filter(item = state.currentMessages
                    .map((msg, i) => ({ msg, originalIndex: i }))
                    .filter => item.msg.role === 'model' && item.msg.isCascaded && item.msg.sibling(item => item.msg.role === 'model' && item.msg.isCascaded && item.msgGroupId === groupId);

                const currentSiblingIndexInGroup = siblingsWithIndices.findIndex(item => item.originalIndex === currentIndex.siblingGroupId === groupId);

                const currentSiblingIndexInGroup = siblingsWithIndices.findIndex(item => item.original);
                if (currentSiblingIndexInGroup === -1) return;

                let targetSiblingIndexInGroup = -1Index === currentIndex);
                if (currentSiblingIndexInGroup === -1) return;

                let targetSibling;
                if (direction === 'prev' && currentSiblingIndexInGroup > 0) {
                    targetIndexInGroup = -1;
                if (direction === 'prev' && currentSiblingIndexInGroup > SiblingIndexInGroup = currentSiblingIndexInGroup - 1;
                } else if (direction === 'next0) {
                    targetSiblingIndexInGroup = currentSiblingIndexInGroup - 1;
                } else' && currentSiblingIndexInGroup < siblingsWithIndices.length - 1) {
                    targetSiblingIndexIn if (direction === 'next' && currentSiblingIndexInGroup < siblingsWithIndices.length - 1) {Group = currentSiblingIndexInGroup + 1;
                }

                if (targetSiblingIndexInGroup !==
                    targetSiblingIndexInGroup = currentSiblingIndexInGroup + 1;
                }

                if ( -1) {
                    currentMsg.isSelected = false;
                    const newlySelectedMessage = siblingsWithIndices[targetSiblingIndexInGroup !== -1) {
                    currentMsg.isSelected = false;
                    const newlySelectedtargetSiblingIndexInGroup].msg;
                    newlySelectedMessage.isSelected = true;
                    const newlySelectedIndexMessage = siblingsWithIndices[targetSiblingIndexInGroup].msg;
                    newlySelectedMessage.isSelected = true; = siblingsWithIndices[targetSiblingIndexInGroup].originalIndex;

                    uiUtils.renderChatMessages();

                    
                    const newlySelectedIndex = siblingsWithIndices[targetSiblingIndexInGroup].originalIndex;

                    uiUtils.renderChatrequestAnimationFrame(() => {
                        const newlySelectedElement = elements.messageContainer.querySelector(`.message[data-index="${newlySelectedIndex}"]`);
                        if (newlySelectedElement && !newlySelectedElement.classList.containsMessages();

                    requestAnimationFrame(() => {
                        const newlySelectedElement = elements.messageContainer.querySelector(`.message('editing')) {
                             const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
[data-index="${newlySelectedIndex}"]`);
                        if (newlySelectedElement && !newlySelectedElement                             if (currentlyShown && currentlyShown !== newlySelectedElement) {
                                 currentlyShown.classList.remove('show-.classList.contains('editing')) {
                             const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                             if (currentlyShown && currentlyShown !== newlySelectedElement) {
                                 currentlyShown.classList.actions');
                             }
                             newlySelectedElement.classList.add('show-actions');
                        }
                    });

                    try {
                        await dbUtils.saveChat();
                    } catch (error) {
remove('show-actions');
                             }
                             newlySelectedElement.classList.add('show-actions');
                        }                        console.error("Error saving cascade navigation:", error);
                        await uiUtils.showCustomAlert("応答の切り替え状態
                    });

                    try {
                        await dbUtils.saveChat();
                    } catch (error) {の保存に失敗しました。");
                    }
                }
            },
            async confirmDeleteCascadeResponse(
                        console.error("Error saving cascade navigation:", error);
                        await uiUtils.showCustomAlert("応答indexToDelete) {
                const msgToDelete = state.currentMessages[indexToDelete];
                if (!msgToDeleteの切り替え状態の保存に失敗しました。");
                    }
                }
            },
            async confirm || msgToDelete.role !== 'model' || !msgToDelete.isCascaded || !msgToDelete.siblingGroupId) {DeleteCascadeResponse(indexToDelete) {
                const msgToDelete = state.currentMessages[indexToDelete];
                
                    return;
                }
                if (state.editingMessageIndex !== null) { await uiUtils.if (!msgToDelete || msgToDelete.role !== 'model' || !msgToDelete.isCascaded || !msgToDelete.showCustomAlert("編集中は削除できません。"); return; }
                if (state.isSending) {siblingGroupId) {
                    return;
                }
                if (state.editingMessageIndex !== null) { await uiUtils.showCustomAlert("送信中は削除できません。"); return; }
                if (state.isEditingSystem await uiUtils.showCustomAlert("編集中は削除できません。"); return; }
                if (state.Prompt) { await uiUtils.showCustomAlert("システムプロンプト編集中は削除できません。"); return; }

isSending) { await uiUtils.showCustomAlert("送信中は削除できません。"); return; }
                if (state                const siblings = this.getCascadedSiblings(indexToDelete, true);
                const currentIndexInGroup = siblings.findIndex.isEditingSystemPrompt) { await uiUtils.showCustomAlert("システムプロンプト編集中は削除できません。");(m => m === msgToDelete) + 1;
                const totalSiblings = siblings.length;
 return; }

                const siblings = this.getCascadedSiblings(indexToDelete, true);
                const currentIndex                const contentPreview = msgToDelete.content.substring(0, 30) + "...";
                constInGroup = siblings.findIndex(m => m === msgToDelete) + 1;
                const totalSiblings = siblings confirmMsg = `この応答 (${currentIndexInGroup}/${totalSiblings})「${contentPreview}」を削除しますか？.length;
                const contentPreview = msgToDelete.content.substring(0, 30) + "...";
                const confirmMsg = `この応答 (${currentIndexInGroup}/${totalSiblings})「${contentPreview}」を\n(この応答のみが削除されます)`;

                const confirmed = await uiUtils.showCustomConfirm(confirmMsg);
削除しますか？\n(この応答のみが削除されます)`;

                const confirmed = await uiUtils.showCustom                if (confirmed) {
                    const wasSelected = msgToDelete.isSelected;
                    const groupId = msgToDelete.Confirm(confirmMsg);
                if (confirmed) {
                    const wasSelected = msgToDelete.isSelected;
                    constsiblingGroupId;

                    state.currentMessages.splice(indexToDelete, 1);
                    state.messageCollapsedStates.delete(indexToDelete);

                    const oldCollapsedStates = new Map(state.messageCollapsedStates);
 groupId = msgToDelete.siblingGroupId;

                    state.currentMessages.splice(indexToDelete, 1);
                    state.messageCollapsedStates.clear();
                     state.currentMessages.forEach((msg, newIdx) => {
                    state.messageCollapsedStates.delete(indexToDelete);

                    const oldCollapsedStates = new Map(state.messageCollapsedStates                        const oldIdxEquivalent = newIdx >= indexToDelete ? newIdx + 1 : newIdx;
                        if);
                    state.messageCollapsedStates.clear();
                     state.currentMessages.forEach((msg, newIdx (oldCollapsedStates.has(oldIdxEquivalent)) {
                            state.messageCollapsedStates.set(newIdx) => {
                        const oldIdxEquivalent = newIdx >= indexToDelete ? newIdx + 1 : newIdx, oldCollapsedStates.get(oldIdxEquivalent));
                        } else {
                            state.messageCollapsedStates.;
                        if (oldCollapsedStates.has(oldIdxEquivalent)) {
                            state.messageCollapsedStates.set(newIdx, false);
                        }
                    });


                    let newlySelectedIndex = -1;
                    set(newIdx, oldCollapsedStates.get(oldIdxEquivalent));
                        } else {
                            state.messageCollapsedStatesconst remainingSiblingsWithIndices = state.currentMessages.map((msg, i) => ({ msg, originalIndex: i })).set(newIdx, false);
                        }
                    });


                    let newlySelectedIndex = -1;
                    const remaining
                    .filter(item => item.msg.role === 'model' && item.msg.isCascaded && itemSiblingsWithIndices = state.currentMessages.map((msg, i) => ({ msg, originalIndex: i }))
                    .msg.siblingGroupId === groupId);

                    if (remainingSiblingsWithIndices.length > 0) {.filter(item => item.msg.role === 'model' && item.msg.isCascaded && item
                        if (wasSelected) {
                            const lastSiblingItem = remainingSiblingsWithIndices[remainingSiblings.msg.siblingGroupId === groupId);

                    if (remainingSiblingsWithIndices.length > 0) {WithIndices.length - 1];
                            if (!lastSiblingItem.msg.isSelected) {
                                lastSiblingItem.msg.isSelected = true;
                                newlySelectedIndex = lastSiblingItem.originalIndex;
                            }
                        if (wasSelected) {
                            const lastSiblingItem = remainingSiblingsWithIndices[remainingSiblingsWithIndices.length - 1];
                            if (!lastSiblingItem.msg.isSelected) {
                                last else {
                                newlySelectedIndex = lastSiblingItem.originalIndex;
                            }
                        } else {
                             SiblingItem.msg.isSelected = true;
                                newlySelectedIndex = lastSiblingItem.originalIndex;
                            }const stillSelectedItem = remainingSiblingsWithIndices.find(item => item.msg.isSelected);
                             if ( else {
                                newlySelectedIndex = lastSiblingItem.originalIndex;
                            }
                        } else {
                             stillSelectedItem) {
                                 newlySelectedIndex = stillSelectedItem.originalIndex;
                             }
                        }
                    }

const stillSelectedItem = remainingSiblingsWithIndices.find(item => item.msg.isSelected);
                             if (                    uiUtils.renderChatMessages();

                    requestAnimationFrame(() => {
                         if (newlySelectedIndex !== -1) {stillSelectedItem) {
                                 newlySelectedIndex = stillSelectedItem.originalIndex;
                             }
                        }
                    
                             const elementToShowActions = elements.messageContainer.querySelector(`.message[data-index="${newlySelectedIndex}"]}

                    uiUtils.renderChatMessages();

                    requestAnimationFrame(() => {
                         if (newlySelectedIndex !== -1`);
                             if (elementToShowActions && !elementToShowActions.classList.contains('editing')) {
                                  ) {
                             const elementToShowActions = elements.messageContainer.querySelector(`.message[data-index="${newlySelectedIndex}"]const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                                  if (currentlyShown`);
                             if (elementToShowActions && !elementToShowActions.classList.contains('editing')) {
                                   && currentlyShown !== elementToShowActions) {
                                      currentlyShown.classList.remove('show-actions');
                                  const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                                  if (currentlyShown}
                                  elementToShowActions.classList.add('show-actions');
                             }
                         }
                    }); && currentlyShown !== elementToShowActions) {
                                      currentlyShown.classList.remove('show-actions');
                                  

                    try {
                        await dbUtils.saveChat();
                    } catch (error) {
                        console.error("}
                                  elementToShowActions.classList.add('show-actions');
                             }
                         }
                    Error saving chat after cascade delete:", error);
                        await uiUtils.showCustomAlert("応答削除後のチャット状態の保存});

                    try {
                        await dbUtils.saveChat();
                    } catch (error) {
                        に失敗しました。");
                    }
                }
            },
            async handleFileSelection(fileList)console.error("Error saving chat after cascade delete:", error);
                        await uiUtils.showCustomAlert("応答 {
                if (!fileList || fileList.length === 0) return;
                const newFiles =削除後のチャット状態の保存に失敗しました。");
                    }
                }
            },
            async handle Array.from(fileList);
                let currentTotalSize = state.selectedFilesForUpload.reduce((sum, item)FileSelection(fileList) {
                if (!fileList || fileList.length === 0) return;
                 => sum + item.file.size, 0);
                let addedCount = 0;
                let skippedCount =const newFiles = Array.from(fileList);
                let currentTotalSize = state.selectedFilesForUpload.reduce(( 0;
                let sizeError = false;

                elements.selectFilesBtn.disabled = true;
sum, item) => sum + item.file.size, 0);
                let addedCount = 0;
                                elements.selectFilesBtn.textContent = '処理中...';

                for (const file of newFiles)let skippedCount = 0;
                let sizeError = false;

                elements.selectFilesBtn.disabled {
                    if (file.size > MAX_FILE_SIZE) {
                        await uiUtils.showCustom = true;
                elements.selectFilesBtn.textContent = '処理中...';

                for (const file of newFilesAlert(`ファイル "${file.name}" はサイズが大きすぎます (${formatFileSize(MAX_FILE_SIZE)}) {
                    if (file.size > MAX_FILE_SIZE) {
                        await uiUtils.showCustomAlert以下)。`);
                        skippedCount++;
                        continue;
                    }
                    if (currentTotalSize + file(`ファイル "${file.name}" はサイズが大きすぎます (${formatFileSize(MAX_FILE_SIZE)}以下)。`);
.size > MAX_TOTAL_ATTACHMENT_SIZE) {
                        sizeError = true;
                        skippedCount                        skippedCount++;
                        continue;
                    }
                    if (currentTotalSize + file.size > MAX++;
                        continue;
                    }
                    if (state.selectedFilesForUpload.some(item => item_TOTAL_ATTACHMENT_SIZE) {
                        sizeError = true;
                        skippedCount++;
                        continue.file.name === file.name)) {
                        skippedCount++;
                        continue;
                    }

                    ;
                    }
                    if (state.selectedFilesForUpload.some(item => item.file.name === filestate.selectedFilesForUpload.push({ file: file });
                    currentTotalSize += file.size;
                    addedCount++;
                }
                elements.selectFilesBtn.disabled = false;
                elements.select.name)) {
                        skippedCount++;
                        continue;
                    }

                    state.selectedFilesForUpload.push({FilesBtn.textContent = 'ファイルを選択';

                if (sizeError) {
                    await uiUtils.showCustomAlert(` file: file });
                    currentTotalSize += file.size;
                    addedCount++;
                }
                elements.select合計ファイルサイズの上限 (${formatFileSize(MAX_TOTAL_ATTACHMENT_SIZE)}) を超えるため、一部FilesBtn.disabled = false;
                elements.selectFilesBtn.textContent = 'ファイルを選択';

                if (sizeのファイルは追加されませんでした。`);
                }
                uiUtils.updateSelectedFilesUI();
            },Error) {
                    await uiUtils.showCustomAlert(`合計ファイルサイズの上限 (${formatFileSize(MAX_
            removeSelectedFile(indexToRemove) {
                if (indexToRemove >= 0 && indexToRemove < stateTOTAL_ATTACHMENT_SIZE)}) を超えるため、一部のファイルは追加されませんでした。`);
                }.selectedFilesForUpload.length) {
                    const removedFile = state.selectedFilesForUpload.splice(
                uiUtils.updateSelectedFilesUI();
            },
            removeSelectedFile(indexToRemove) {
                if (indexToRemove, 1)[0];
                    uiUtils.updateSelectedFilesUI();
                }
            },
            asyncindexToRemove >= 0 && indexToRemove < state.selectedFilesForUpload.length) {
                    const removedFile confirmAttachment() {
                if (state.selectedFilesForUpload.length === 0) {
                    state = state.selectedFilesForUpload.splice(indexToRemove, 1)[0];
                    uiUtils.update.pendingAttachments = [];
                    elements.fileUploadDialog.close('ok');
                    uiUtils.adjustTextSelectedFilesUI();
                }
            },
            async confirmAttachment() {
                if (state.selectedFilesareaHeight();
                    uiUtils.updateAttachmentBadgeVisibility();
                    return;
                }

                elements.confirmAttachBtnForUpload.length === 0) {
                    state.pendingAttachments = [];
                    elements.fileUploadDialog.close('ok');
                    uiUtils.adjustTextareaHeight();
                    uiUtils.updateAttachmentBadgeVisibility.disabled = true;
                elements.confirmAttachBtn.textContent = '処理中...';

                const attachmentsToAdd = [];
                let encodingError = false;

                for (const item of state.selectedFilesForUpload) {
();
                    return;
                }

                elements.confirmAttachBtn.disabled = true;
                elements.confirmAttachBtn                    try {
                        const base64Data = await fileToBase64(item.file);
                        let.textContent = '処理中...';

                const attachmentsToAdd = [];
                let encodingError = false;

                for ( browserMimeType = item.file.type || '';
                        const fileName = item.file.name;
                        const fileconst item of state.selectedFilesForUpload) {
                    try {
                        const base64Data = awaitExtension = fileName.slice(((fileName.lastIndexOf(".") - 1) >>> 0) + 2).toLowerCase(); fileToBase64(item.file);
                        let browserMimeType = item.file.type || '';

                        let guessedMimeType = null;
                        if (fileExtension && extensionToMimeTypeMap[fileExtension])
                        const fileName = item.file.name;
                        const fileExtension = fileName.slice(((fileName.lastIndexOf {
                            guessedMimeType = extensionToMimeTypeMap[fileExtension];
                        }

                        let(".") - 1) >>> 0) + 2).toLowerCase();

                        let guessedMimeType = null;
                         finalMimeType;
                        if (guessedMimeType) {
                            finalMimeType = guessedMif (fileExtension && extensionToMimeTypeMap[fileExtension]) {
                            guessedMimeType = extensionimeType;
                        } else if (browserMimeType) {
                            finalMimeType = browserMToMimeTypeMap[fileExtension];
                        }

                        let finalMimeType;
                        if (guessedMimeimeType;
                        } else {
                            finalMimeType = 'application/octet-stream';
                        Type) {
                            finalMimeType = guessedMimeType;
                        } else if (browserMime}

                        attachmentsToAdd.push({
                            file: item.file,
                            name: fileName,
                            Type) {
                            finalMimeType = browserMimeType;
                        } else {
                            finalMmimeType: finalMimeType,
                            base64Data: base64Data
                        });
                    imeType = 'application/octet-stream';
                        }

                        attachmentsToAdd.push({
                            file:} catch (error) {
                        console.error("File encoding error:", error);
                        encodingError = true item.file,
                            name: fileName,
                            mimeType: finalMimeType,
                            base6;
                        await uiUtils.showCustomAlert(`ファイル "${item.file.name}" の処理中にエラーが発生4Data: base64Data
                        });
                    } catch (error) {
                        console.error("しました。`);
                        break;
                    }
                }

                elements.confirmAttachBtn.disabled = false;
File encoding error:", error);
                        encodingError = true;
                        await uiUtils.showCustomAlert(`ファイル "${item.file.name}" の処理中にエラーが発生しました。`);
                        break;
                    }
                }

                elements.confirmAttachBtn.textContent = '添付して閉じる';

                if (!encodingError) {
                    state.pendingAttachments = attachmentsToAdd;
                    elements.fileUploadDialog.close('ok');
                    uiUtils.adjust                elements.confirmAttachBtn.disabled = false;
                elements.confirmAttachBtn.textContent = '添付して閉じる';TextareaHeight();
                    uiUtils.updateAttachmentBadgeVisibility();
                }
            },
            cancelAttachment

                if (!encodingError) {
                    state.pendingAttachments = attachmentsToAdd;
                    elements.fileUpload() {
                state.selectedFilesForUpload = [];
                elements.fileUploadDialog.close('cancel');Dialog.close('ok');
                    uiUtils.adjustTextareaHeight();
                    uiUtils.updateAttachmentBadge
                uiUtils.updateAttachmentBadgeVisibility();
            },
            toggleMessageCollapse(index) {
                Visibility();
                }
            },
            cancelAttachment() {
                state.selectedFilesForUpload = [];const messageElement = elements.messageContainer.querySelector(`.message[data-index="${index}"]`);
                const content
                elements.fileUploadDialog.close('cancel');
                uiUtils.updateAttachmentBadgeVisibility();
            Div = messageElement?.querySelector('.message-content');
                const toggleButtons = messageElement?.querySelectorAll('.message-toggle},
            toggleMessageCollapse(index) {
                const messageElement = elements.messageContainer.querySelector(`.message[data-index="${index}"]`);
                const contentDiv = messageElement?.querySelector('.message-content');
                const toggle-button[data-action="toggle-collapse"]');

                if (contentDiv && toggleButtons && toggleButtons.length >Buttons = messageElement?.querySelectorAll('.message-toggle-button[data-action="toggle-collapse"]');

                if (content 0) {
                    const isCollapsed = contentDiv.classList.toggle('collapsed');
                    state.messageCollapsedDiv && toggleButtons && toggleButtons.length > 0) {
                    const isCollapsed = contentDiv.classList.States.set(index, isCollapsed);
                    if (state.settings.persistMessageCollapseState && state.toggle('collapsed');
                    state.messageCollapsedStates.set(index, isCollapsed);
                    if (statecurrentChatId) {
                        dbUtils.saveChat();
                    }

                    toggleButtons.forEach(button => {
.settings.persistMessageCollapseState && state.currentChatId) {
                        dbUtils.saveChat();
                        let textCollapse, textExpand, baseTitle;
                        if (button.classList.contains('top')) {                    }

                    toggleButtons.forEach(button => {
                        let textCollapse, textExpand, baseTitle;
                        
                            textCollapse = state.settings.toggleButtonTopTextCollapse;
                            textExpand = state.settings.toggleButtonTopTextExpand;
                        } else {
                            textCollapse = state.settings.toggleButtonBottomTextif (button.classList.contains('top')) {
                            textCollapse = state.settings.toggleButtonTopTextCollapse;
Collapse;
                            textExpand = state.settings.toggleButtonBottomTextExpand;
                        }
                        baseTitle                            textExpand = state.settings.toggleButtonTopTextExpand;
                        } else {
                            textCollapse = = isCollapsed ? 'メッセージを展開' : 'メッセージを折りたたむ';
                        button.textContent = isCollapsed ? textExpand state.settings.toggleButtonBottomTextCollapse;
                            textExpand = state.settings.toggleButtonBottomTextExpand : textCollapse;
                        button.title = baseTitle;
                        button.setAttribute('aria-label', base;
                        }
                        baseTitle = isCollapsed ? 'メッセージを展開' : 'メッセージを折りたたむ';
                        Title);
                    });
                }
            },
            uncollapseMessage(index, messageElement = null) {
                 button.textContent = isCollapsed ? textExpand : textCollapse;
                        button.title = baseTitle;
                        if (!messageElement) {
                     messageElement = elements.messageContainer.querySelector(`.message[data-index="${button.setAttribute('aria-label', baseTitle);
                    });
                }
            },
            uncollapseMessage(index, messageElement = null) {
                 if (!messageElement) {
                     messageElement = elementsindex}"]`);
                 }
                 const contentDiv = messageElement?.querySelector('.message-content');
                 const toggleButtons = messageElement?.querySelectorAll('.message-toggle-button[data-action="toggle-collapse"]');

.messageContainer.querySelector(`.message[data-index="${index}"]`);
                 }
                 const contentDiv = message                 if (contentDiv && contentDiv.classList.contains('collapsed')) {
                     contentDiv.classList.removeElement?.querySelector('.message-content');
                 const toggleButtons = messageElement?.querySelectorAll('.message-toggle-button[data-('collapsed');
                     state.messageCollapsedStates.set(index, false);
                     if (state.settingsaction="toggle-collapse"]');

                 if (contentDiv && contentDiv.classList.contains('collapsed')) {.persistMessageCollapseState && state.currentChatId) {
                        dbUtils.saveChat();
                     }

                     
                     contentDiv.classList.remove('collapsed');
                     state.messageCollapsedStates.set(index, falseif (toggleButtons) {
                         toggleButtons.forEach(button => {
                            let textCollapse;
                            );
                     if (state.settings.persistMessageCollapseState && state.currentChatId) {
                        dbUtils.saveChat();
                     }

                     if (toggleButtons) {
                         toggleButtons.forEach(buttonif (button.classList.contains('top')) {
                                textCollapse = state.settings.toggleButtonTopText => {
                            let textCollapse;
                            if (button.classList.contains('top')) {
                                textCollapse;
                            } else {
                                textCollapse = state.settings.toggleButtonBottomTextCollapse;
                            Collapse = state.settings.toggleButtonTopTextCollapse;
                            } else {
                                textCollapse = state.}
                            button.textContent = textCollapse;
                            button.title = 'メッセージを折りたたむ';
                            button.setAttribute('aria-label', 'メッセージを折りたたむ');
                         });
                     }
                 }
settings.toggleButtonBottomTextCollapse;
                            }
                            button.textContent = textCollapse;
                            button.title = '            },
            toggleAllMessagesVisibility() {
                if (state.isSending) {
                    uiUtilsメッセージを折りたたむ';
                            button.setAttribute('aria-label', 'メッセージを折りたたむ');
.showCustomAlert("送信中は操作できません。");
                    return;
                }
                if (state.                         });
                     }
                 }
            },
            toggleAllMessagesVisibility() {
                if (stateeditingMessageIndex !== null) {
                     uiUtils.showCustomAlert("メッセージ編集中は操作できません。");.isSending) {
                    uiUtils.showCustomAlert("送信中は操作できません。");
                    return;
                }
                if (state.editingMessageIndex !== null) {
                     uiUtils.showCustomAlert
                     return;
                 }
                 if (state.isEditingSystemPrompt) {
                     uiUtils.showCustomAlert("システムプロンプト編集中は操作できません。");
                     return;
                 }

                state.are("メッセージ編集中は操作できません。");
                     return;
                 }
                 if (state.isEditingSystemPrompt) {
                     uiUtils.showCustomAlert("システムプロンプト編集中は操作できません。");
                     return;AllMessagesHidden = !state.areAllMessagesHidden;
                uiUtils.updateToggleAllContentButton();

                const messages = elements.messageContainer.querySelectorAll('.message:not(.message-error)');
                messages.forEach
                 }

                state.areAllMessagesHidden = !state.areAllMessagesHidden;
                uiUtils(msgElement => {
                    if (msgElement.id && msgElement.id.startsWith('streaming-message.updateToggleAllContentButton();

                const messages = elements.messageContainer.querySelectorAll('.message:not(.message-')) {
                        msgElement.classList.remove('message-hidden-by-toggle');
                        return;-error)');
                messages.forEach(msgElement => {
                    if (msgElement.id && msgElement
                    }
                    msgElement.classList.toggle('message-hidden-by-toggle', state.areAll.id.startsWith('streaming-message-')) {
                        msgElement.classList.remove('message-hidden-MessagesHidden);
                });

                requestAnimationFrame(() => {
                    uiUtils.scrollToBottom();
                });by-toggle');
                        return;
                    }
                    msgElement.classList.toggle('message-hidden-
            }
        };

        const apiUtils = {
            async callGeminiApi(messagesForApiby-toggle', state.areAllMessagesHidden);
                });

                requestAnimationFrame(() => {
                    ui, generationConfig, systemInstruction) {
                if (!state.settings.apiKey) {
                    throw new ErrorUtils.scrollToBottom();
                });
            }
        };

        const apiUtils = {
            async("APIキーが設定されていません。");
                }
                state.abortController = new AbortController(); callGeminiApi(messagesForApi, generationConfig, systemInstruction) {
                if (!state.settings.
                const { signal } = state.abortController;

                const useStreaming = state.settings.streamingOutput;
apiKey) {
                    throw new Error("APIキーが設定されていません。");
                }
                state.abortController =                const usePseudo = state.settings.pseudoStreaming;
                const model = state.settings.modelName || new AbortController();
                const { signal } = state.abortController;

                const useStreaming = state DEFAULT_MODEL;
                const apiKey = state.settings.apiKey;

                let endpointMethod = useStreaming
.settings.streamingOutput;
                const usePseudo = state.settings.pseudoStreaming;
                const model =                    ? (usePseudo ? 'generateContent?alt=sse&' : 'streamGenerateContent?alt=sse&') state.settings.modelName || DEFAULT_MODEL;
                const apiKey = state.settings.apiKey;

                
                    : 'generateContent?';

                if (!endpointMethod.endsWith('&') && !endpointMethod.endsWithlet endpointMethod = useStreaming
                    ? (usePseudo ? 'generateContent?alt=sse&' : 'stream('?')) {
                    endpointMethod += endpointMethod.includes('?') ? '&' : '?';
                }GenerateContent?alt=sse&')
                    : 'generateContent?';

                if (!endpointMethod.endsWith

                const endpoint = `${GEMINI_API_BASE_URL}${model}:${endpointMethod}key=${apiKey}`;('&') && !endpointMethod.endsWith('?')) {
                    endpointMethod += endpointMethod.includes('?') ?

                const finalGenerationConfig = { ...generationConfig };
                if (state.settings.presencePenalty !== null '&' : '?';
                }

                const endpoint = `${GEMINI_API_BASE_URL}${model) finalGenerationConfig.presencePenalty = state.settings.presencePenalty;
                if (state.settings.frequencyPenalty !==}:${endpointMethod}key=${apiKey}`;

                const finalGenerationConfig = { ...generationConfig };
                if ( null) finalGenerationConfig.frequencyPenalty = state.settings.frequencyPenalty;

                if (state.settings.state.settings.presencePenalty !== null) finalGenerationConfig.presencePenalty = state.settings.presencePenalty;
                ifthinkingBudget !== null && Number.isInteger(state.settings.thinkingBudget) && state.settings.thinkingBudget >=  (state.settings.frequencyPenalty !== null) finalGenerationConfig.frequencyPenalty = state.settings.frequencyPenalty;0) {
                    finalGenerationConfig.thinkingConfig = {
                        "thinkingBudget": state.settings.thinkingBudget,

                if (state.settings.thinkingBudget !== null && Number.isInteger(state.settings.thinkingBudget) &&
                    };
                }

                const requestBody = {
                    contents: messagesForApi,
                    ...( state.settings.thinkingBudget >= 0) {
                    finalGenerationConfig.thinkingConfig = {
                        "thinkingBudgetObject.keys(finalGenerationConfig).length > 0 && { generationConfig: finalGenerationConfig }),
                    ...(system": state.settings.thinkingBudget,
                    };
                }

                const requestBody = {
                    contentsInstruction && systemInstruction.parts && systemInstruction.parts.length > 0 && systemInstruction.parts[0].text &&: messagesForApi,
                    ...(Object.keys(finalGenerationConfig).length > 0 && { generationConfig: { systemInstruction }),
                     safetySettings : [
                         { category: 'HARM_CATEGORY_HARASSMENT finalGenerationConfig }),
                    ...(systemInstruction && systemInstruction.parts && systemInstruction.parts.length > 0 && systemInstruction', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_CATEGORY_HATE_SPE.parts[0].text && { systemInstruction }),
                     safetySettings : [
                         { category: 'HECH', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_CATEGORY_SEXUALLYARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_EXPLICIT', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_CATEGORY__CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                         { category: 'HDANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                     ]
                };

                constARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                         { category tools = [];
                if (state.settings.enableGrounding) {
                    tools.push({ "google: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                     _search": {} });
                }

                if (tools.length > 0) {
                    requestBody]
                };

                const tools = [];
                if (state.settings.enableGrounding) {
                    tools..tools = tools;
                }

                try {
                    const response = await fetch(endpoint, {
                        method:push({ "google_search": {} });
                }

                if (tools.length > 0) { 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON
                    requestBody.tools = tools;
                }

                try {
                    const response = await fetch(endpoint, {.stringify(requestBody),
                        signal
                    });

                    if (!response.ok) {
                        let
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
 errorMsg = `APIエラー (${response.status}): ${response.statusText}`;
                        try {
                            const errorData =                        body: JSON.stringify(requestBody),
                        signal
                    });

                    if (!response.ok) await response.json();
                            if (errorData.error && errorData.error.message) {
                                {
                        let errorMsg = `APIエラー (${response.status}): ${response.statusText}`;
                        try {
                            const errorData = await response.json();
                            if (errorData.error && errorData.error.message errorMsg = `APIエラー (${response.status}): ${errorData.error.message}`;
                            }
                        } catch () {
                                errorMsg = `APIエラー (${response.status}): ${errorData.error.message}`;
                            }
e) {  }
                        throw new Error(errorMsg);
                    }
                    return response;
                } catch (error) {
                    if (error.name === 'AbortError') {
                         throw new Error                        } catch (e) {  }
                        throw new Error(errorMsg);
                    }
                    return("リクエストがキャンセルされました。");
                    }
                    throw error;
                }
            },
             response;
                } catch (error) {
                    if (error.name === 'AbortError') {
async handleStreamingResponse(response) {
                 if (!response.body) {
                     throw new Error("レス                         throw new Error("リクエストがキャンセルされました。");
                    }
                    throw error;
                }
ポンスボディがありません。");
                 }
                 const reader = response.body.pipeThrough(new Text            },
            async handleStreamingResponse(response) {
                 if (!response.body) {
                     throwDecoderStream()).getReader();
                 let buffer = '';
                 let lastCandidateInfo = null;
                 const processedChunks new Error("レスポンスボディがありません。");
                 }
                 const reader = response.body.pipe = [];
                 let isCancelled = false;
                 let groundingMetadata = null;
                 let currentPartIndex = -1Through(new TextDecoderStream()).getReader();
                 let buffer = '';
                 let lastCandidateInfo = null;
;
                 let finalUsageMetadata = null;

                 try {
                     while (true) {
                         if                 const processedChunks = [];
                 let isCancelled = false;
                 let groundingMetadata = null;
                 let currentPart (state.abortController?.signal.aborted && !isCancelled) {
                             isCancelled = true;
                             await readerIndex = -1;
                 let finalUsageMetadata = null;

                 try {
                     while (true).cancel("User aborted");
                             throw new Error("リクエストがキャンセルされました。");
                         }

                          {
                         if (state.abortController?.signal.aborted && !isCancelled) {
                             isCancelled = true;
                             await reader.cancel("User aborted");
                             throw new Error("リクエストがキャンセルされました。");
let readResult;
                         try {
                             readResult = await reader.read();
                         } catch (read                         }

                         let readResult;
                         try {
                             readResult = await reader.read();
                         Error) {
                             if (readError.name === 'AbortError' || readError.message === "User} catch (readError) {
                             if (readError.name === 'AbortError' || readError. aborted" || readError.message.includes("aborted")) {
                                 if (!isCancelled) {
message === "User aborted" || readError.message.includes("aborted")) {
                                 if (!is                                     isCancelled = true;
                                     throw new Error("リクエストがキャンセルされました。");
                                 Cancelled) {
                                     isCancelled = true;
                                     throw new Error("リクエストがキャンセルされました。}
                                 break;
                             }
                             throw readError;
                         }

                         const { value,");
                                 }
                                 break;
                             }
                             throw readError;
                         }

                          done } = readResult;

                         if (done) {
                             if (buffer.trim()) {
                                 processBufferconst { value, done } = readResult;

                         if (done) {
                             if (buffer.trim(buffer, true);
                             }
                             break;
                         }

                         buffer += value;
                         buffer = processBuffer()) {
                                 processBuffer(buffer, true);
                             }
                             break;
                         }

                         buffer +=(buffer, false);
                     }

                     const finishReason = lastCandidateInfo?.finishReason;
                     const safetyRatings = value;
                         buffer = processBuffer(buffer, false);
                     }

                     const finishReason = lastCandidateInfo?. lastCandidateInfo?.safetyRatings;
                     const finalGroundingMetadata = groundingMetadata;

                     if (!isCancelled && processedfinishReason;
                     const safetyRatings = lastCandidateInfo?.safetyRatings;
                     const finalGroundingMetadata =Chunks.length === 0 && (!finishReason || finishReason === "STOP")) {
                     }

                     return {
                          groundingMetadata;

                     if (!isCancelled && processedChunks.length === 0 && (!finishReason || finishReason === "STOPprocessedChunks: processedChunks,
                         finishReason: isCancelled ? 'ABORTED' : finishReason,
")) {
                     }

                     return {
                         processedChunks: processedChunks,
                         finishReason: isCancelled ? 'AB                         safetyRatings,
                         groundingMetadata: finalGroundingMetadata,
                         usageMetadata: finalUsageMetadata
                     };
                 } catch (error) {
                     const partialChunksOnError = (error.message !== "リクエストがキャンセルORTED' : finishReason,
                         safetyRatings,
                         groundingMetadata: finalGroundingMetadata,
されました.") ? processedChunks : [];
                     throw new Error(`${error.message || error}`, { cause: { original                         usageMetadata: finalUsageMetadata
                     };
                 } catch (error) {
                     const partialChunksOnError = (error.message !== "リクエストがキャンセルされました.") ? processedChunks : [];
                     throw new Error(`${error.messageError: error, partialChunks: partialChunksOnError } });
                 } finally {
                     if (!reader.closed && ! || error}`, { cause: { originalError: error, partialChunks: partialChunksOnError } });
                 } finally {
isCancelled) {
                         try { await reader.cancel("Cleanup cancellation"); } catch(e) {  }
                                          if (!reader.closed && !isCancelled) {
                         try { await reader.cancel("Cleanup cancellation"); } catch}
                 }

                 function processBuffer(currentBuffer, isFinalChunk) {
                     let remainingBuffer = currentBuffer;(e) {  }
                     }
                 }

                 function processBuffer(currentBuffer, isFinalChunk) {

                     while (true) {
                         const newlineIndex = remainingBuffer.indexOf('\n');
                         if (newlineIndex                     let remainingBuffer = currentBuffer;
                     while (true) {
                         const newlineIndex = remainingBuffer. === -1) {
                             if (isFinalChunk && remainingBuffer.trim().startsWith('data: ')) {
                               indexOf('\n');
                         if (newlineIndex === -1) {
                             if (isFinalChunk && remaining  parseSseData(remainingBuffer.trim().substring(6));
                                 remainingBuffer = '';
                             Buffer.trim().startsWith('data: ')) {
                                 parseSseData(remainingBuffer.trim().substring}
                             break;
                         }
                         const line = remainingBuffer.substring(0, newlineIndex).trim(6));
                                 remainingBuffer = '';
                             }
                             break;
                         }
                         const line();
                         remainingBuffer = remainingBuffer.substring(newlineIndex + 1);

                         if (line.startsWith('data: = remainingBuffer.substring(0, newlineIndex).trim();
                         remainingBuffer = remainingBuffer.substring(newlineIndex +  ')) {
                             parseSseData(line.substring(6));
                         } else if (line !== '')1);

                         if (line.startsWith('data: ')) {
                             parseSseData(line.substring {
                         }
                     }
                                          return remainingBuffer;
                 }

                 function parseSseData((6));
                         } else if (line !== '') {
                         }
                     }
                                          return remainingBuffer;jsonString) {
                     try {
                         const chunkData = JSON.parse(jsonString);
                         if (chunk
                 }

                 function parseSseData(jsonString) {
                     try {
                         const chunkDataData.error) {
                             const errorMsg = `モデルエラー: ${chunkData.error.message || JSON.stringify( = JSON.parse(jsonString);
                         if (chunkData.error) {
                             const errorMsg =chunkData.error)}`;
                             lastCandidateInfo = { error: chunkData.error, finishReason: 'ERROR' };
 `モデルエラー: ${chunkData.error.message || JSON.stringify(chunkData.error)}`;
                             last                             throw new Error(errorMsg);
                         }
                         if (chunkData.candidates && chunkData.candidatesCandidateInfo = { error: chunkData.error, finishReason: 'ERROR' };
                             throw new Error(errorMsg);.length > 0) {
                             lastCandidateInfo = chunkData.candidates[0];
                             if (
                         }
                         if (chunkData.candidates && chunkData.candidates.length > 0) {
lastCandidateInfo?.content?.parts) {
                                 lastCandidateInfo.content.parts.forEach((part,                             lastCandidateInfo = chunkData.candidates[0];
                             if (lastCandidateInfo?.content?.parts) partIndex) => {
                                     const textChunk = part.text;
                                     if (typeof textChunk {
                                 lastCandidateInfo.content.parts.forEach((part, partIndex) => {
                                      === 'string') {
                                         if (partIndex > currentPartIndex && currentPartIndex !== -1) {const textChunk = part.text;
                                     if (typeof textChunk === 'string') {
                                         
                                             processedChunks.push(null);
                                         }
                                         processedChunks.push(textChunkif (partIndex > currentPartIndex && currentPartIndex !== -1) {
                                             processedChunks.push(null);
                                         currentPartIndex = partIndex;
                                     }
                                 });
                             }
                             );
                                         }
                                         processedChunks.push(textChunk);
                                         currentPartIndex = partif (lastCandidateInfo.groundingMetadata) {
                                 groundingMetadata = lastCandidateInfo.groundingMetadata;
Index;
                                     }
                                 });
                             }
                             if (lastCandidateInfo.groundingMetadata                             }
                         } else if (chunkData.promptFeedback) {
                             lastCandidateInfo = { finishReason: ') {
                                 groundingMetadata = lastCandidateInfo.groundingMetadata;
                             }
                         } else if (SAFETY', safetyRatings: chunkData.promptFeedback.safetyRatings };
                         }
                         if (chunkData.usageMetadatachunkData.promptFeedback) {
                             lastCandidateInfo = { finishReason: 'SAFETY', safetyRatings: chunkData) {
                             finalUsageMetadata = chunkData.usageMetadata;
                         }
                     } catch (parseError) {
.promptFeedback.safetyRatings };
                         }
                         if (chunkData.usageMetadata) {
                             finalUsageMetadata =                     }
                 }
            }
        };

        appLogic.initializeApp();
    </script>
 chunkData.usageMetadata;
                         }
                     } catch (parseError) {
                     }
                 }
            }</body>
</html>
